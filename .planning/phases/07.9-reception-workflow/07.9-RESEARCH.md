# Phase 7.9: Reception Workflow - Research

**Researched:** 2026-02-06
**Domain:** Internal ERP goods reception workflow (Next.js + Prisma)
**Confidence:** HIGH

## Summary

This phase implements a complete goods reception workflow for warehouse operations. The system already has a simplified NIR (GoodsReceipt) model with DRAFT/COMPLETED/CANCELLED statuses, a Supplier model, and the unified InventoryItem stock system from Phase 7.8. The workflow specification in FLUX_ERP_Receptie_Marfa_NIR_Stoc.html defines a 9-step process with multiple state machines (PurchaseOrder, ReceptionReport, NIR), mandatory validations, photo uploads, in-app notifications, and approval workflows for quantity/price differences.

The implementation requires extending the existing models significantly: adding PurchaseOrder system (replacing the simplified GoodsReceipt flow), ReceptionReport (PV) with line items and difference tracking, photo storage for reception documentation, SupplierInvoice tracking, and extending NIR with a 5-state workflow. The notification system exists but needs targeted user notifications based on role (Office for NIR verification, George for difference approval).

Key architectural decisions: use the existing file upload pattern (local filesystem with database records), extend existing Prisma models rather than replacing, implement state machine transitions in API routes with validation guards, use the existing inventory-stock.ts functions for stock addition when NIR is approved.

**Primary recommendation:** Extend existing GoodsReceipt model with new workflow states, add PurchaseOrder/ReceptionReport models upstream, implement photo upload using existing AWBCommentImage pattern, and add targeted notification creation for workflow transitions.

## Standard Stack

This phase involves internal development only - leveraging existing patterns and libraries.

### Core (Already in Codebase)
| Component | Location | Purpose | Status |
|-----------|----------|---------|--------|
| Next.js 14 | package.json | API routes & React UI | EXISTS |
| Prisma | prisma/schema.prisma | Database models & queries | EXISTS |
| pdf-lib | package.json | PDF generation for documents | EXISTS |
| date-fns | package.json | Date formatting/manipulation | EXISTS |
| Zod | package.json | Request validation | EXISTS |

### Existing Models to Extend
| Model | File | Current State | Extension Needed |
|-------|------|---------------|------------------|
| GoodsReceipt | schema.prisma:2970 | DRAFT/COMPLETED/CANCELLED | Extend to GENERAT/TRIMIS_OFFICE/VERIFICAT/APROBAT/IN_STOC/RESPINS |
| Supplier | schema.prisma:2921 | Complete | Add paymentTermDays field |
| InventoryItem | schema.prisma:2774 | Complete | No changes needed |
| Notification | schema.prisma:63 | Working | No changes needed |

### New Models to Create
| Model | Purpose | Key Fields |
|-------|---------|------------|
| PurchaseOrder | Precomanda - initiates workflow | supplierId, status, expectedDate, documentNumber |
| PurchaseOrderItem | Line items | productId, quantityOrdered, unitPrice |
| PurchaseOrderLabel | Scannable labels for warehouse | purchaseOrderId, labelCode, printed |
| ReceptionReport | PV Receptie | purchaseOrderId, status, warehouseUserId |
| ReceptionReportItem | Line items with verification | quantityExpected, quantityReceived, verified, hasDifference, observations |
| ReceptionPhoto | Photos per reception | receptionReportId, category, storagePath |
| SupplierInvoice | Factura furnizor | supplierId, invoiceNumber, invoiceDate, paymentStatus |

### Functions to Reuse (from inventory-stock.ts)
| Function | Lines | Purpose | When Used |
|----------|-------|---------|-----------|
| `addInventoryStockFromWarehouse()` | After 7.8 | Add stock to warehouse | NIR approval - stock transfer |
| `getPrimaryWarehouse()` | 620-628 | Get destination warehouse | NIR stock operations |
| `syncItemTotalStock()` | internal | Sync InventoryItem.currentStock | After warehouse stock changes |

## Architecture Patterns

### Recommended Project Structure
```
src/
  app/
    api/
      purchase-orders/
        route.ts              # CRUD for PurchaseOrder
        [id]/
          route.ts            # Single PO operations
          labels/route.ts     # Generate/print labels
          start-reception/route.ts  # Transition to IN_RECEPTIE
      reception-reports/
        route.ts              # CRUD for ReceptionReport
        [id]/
          route.ts            # Single report operations
          items/route.ts      # Line item updates
          photos/route.ts     # Photo management
          finalize/route.ts   # Finalize PV -> Generate NIR
      supplier-invoices/
        route.ts              # CRUD for SupplierInvoice
        [id]/route.ts
        upload/route.ts       # File upload for invoice scan
      goods-receipts/         # (existing - extend)
        route.ts              # Update to new workflow
        [id]/
          route.ts            # (existing)
          complete/route.ts   # (existing - refactor)
          send-office/route.ts    # NEW: Transition to TRIMIS_OFFICE
          verify/route.ts         # NEW: Office verification
          approve/route.ts        # NEW: George approval
          reject/route.ts         # NEW: George rejection
          transfer-stock/route.ts # NEW: Final stock transfer
    (dashboard)/
      reception/              # NEW module
        page.tsx              # Reception dashboard
        purchase-orders/
          page.tsx            # PO list
          [id]/page.tsx       # PO detail
          new/page.tsx        # Create PO
        reports/
          page.tsx            # Reception reports list
          [id]/page.tsx       # Report detail/edit
        nir/
          page.tsx            # NIR list with workflow states
          [id]/page.tsx       # NIR detail/approval
  lib/
    reception-workflow.ts     # Workflow state machine logic
    document-numbering.ts     # Auto-increment document numbers
```

### Pattern 1: State Machine with Validation Guards
**What:** Centralized state transitions with pre-conditions
**When to use:** All workflow status changes
**Example:**
```typescript
// Source: Custom pattern based on existing codebase conventions

type PurchaseOrderStatus = 'DRAFT' | 'APROBATA' | 'IN_RECEPTIE' | 'RECEPTIONATA';

interface StateTransition<T> {
  from: T[];
  to: T;
  guard: (entity: any) => Promise<{ valid: boolean; error?: string }>;
  action?: (entity: any, tx: Prisma.TransactionClient) => Promise<void>;
}

const purchaseOrderTransitions: StateTransition<PurchaseOrderStatus>[] = [
  {
    from: ['DRAFT'],
    to: 'APROBATA',
    guard: async (po) => {
      if (!po.supplierId) return { valid: false, error: 'Furnizorul este obligatoriu' };
      if (po.items.length === 0) return { valid: false, error: 'Adaugati produse' };
      return { valid: true };
    }
  },
  {
    from: ['APROBATA'],
    to: 'IN_RECEPTIE',
    guard: async (po) => {
      // Can only start reception if supplier invoice attached
      const hasInvoice = await prisma.supplierInvoice.findFirst({
        where: { purchaseOrderId: po.id }
      });
      if (!hasInvoice) return { valid: false, error: 'Factura furnizor este obligatorie' };
      return { valid: true };
    }
  }
];

async function transitionPurchaseOrder(
  poId: string,
  targetStatus: PurchaseOrderStatus
): Promise<{ success: boolean; error?: string }> {
  const po = await prisma.purchaseOrder.findUnique({
    where: { id: poId },
    include: { items: true }
  });

  const transition = purchaseOrderTransitions.find(
    t => t.from.includes(po.status as PurchaseOrderStatus) && t.to === targetStatus
  );

  if (!transition) {
    return { success: false, error: `Tranziție invalidă: ${po.status} -> ${targetStatus}` };
  }

  const guardResult = await transition.guard(po);
  if (!guardResult.valid) {
    return { success: false, error: guardResult.error };
  }

  await prisma.$transaction(async (tx) => {
    await tx.purchaseOrder.update({
      where: { id: poId },
      data: { status: targetStatus }
    });
    if (transition.action) {
      await transition.action(po, tx);
    }
  });

  return { success: true };
}
```

### Pattern 2: Document Numbering (Daily Auto-Increment)
**What:** Format: PREFIX-DD/MM/YYYY-NNNN with daily reset
**When to use:** PO, PV, NIR document numbers
**Example:**
```typescript
// Source: Based on existing generateReceiptNumber() in goods-receipts/route.ts

async function generateDocumentNumber(
  prefix: 'PC' | 'PV' | 'NIR',
  tx?: Prisma.TransactionClient
): Promise<string> {
  const db = tx || prisma;
  const today = new Date();
  const day = String(today.getDate()).padStart(2, '0');
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const year = today.getFullYear();
  const dateStr = `${day}/${month}/${year}`;
  const searchPrefix = `${prefix}-${dateStr}`;

  // Table to search based on prefix
  const tableMap = {
    'PC': 'purchaseOrder',
    'PV': 'receptionReport',
    'NIR': 'goodsReceipt'
  };
  const fieldMap = {
    'PC': 'documentNumber',
    'PV': 'reportNumber',
    'NIR': 'receiptNumber'
  };

  const lastDoc = await db[tableMap[prefix]].findFirst({
    where: {
      [fieldMap[prefix]]: { startsWith: searchPrefix }
    },
    orderBy: { [fieldMap[prefix]]: 'desc' }
  });

  let nextNumber = 1;
  if (lastDoc) {
    const lastNum = parseInt(lastDoc[fieldMap[prefix]].split('-').pop());
    nextNumber = lastNum + 1;
  }

  return `${searchPrefix}-${String(nextNumber).padStart(4, '0')}`;
}
```

### Pattern 3: Photo Upload (Following AWBCommentImage Pattern)
**What:** File upload with database record and filesystem storage
**When to use:** Reception photos
**Example:**
```typescript
// Source: Based on existing src/app/api/upload/route.ts

// Photo categories as defined in workflow spec
type PhotoCategory = 'overview' | 'etichete' | 'deteriorari' | 'factura';

// Storage path: /uploads/receptii/{purchaseOrderId}/{receptionReportId}/
async function uploadReceptionPhoto(
  file: File,
  receptionReportId: string,
  category: PhotoCategory
): Promise<{ id: string; storagePath: string }> {
  const report = await prisma.receptionReport.findUnique({
    where: { id: receptionReportId },
    include: { purchaseOrder: true }
  });

  const ALLOWED_EXTENSIONS = ['jpg', 'jpeg', 'png', 'webp', 'heic'];
  const rawExt = file.name.split('.').pop()?.toLowerCase() || '';
  const ext = ALLOWED_EXTENSIONS.includes(rawExt) ? rawExt : 'jpg';
  const filename = `${randomUUID()}.${ext}`;

  const folderPath = join(UPLOAD_DIR, 'receptii', report.purchaseOrderId, receptionReportId);
  const filePath = join(folderPath, filename);
  const storagePath = `/uploads/receptii/${report.purchaseOrderId}/${receptionReportId}/${filename}`;

  await mkdir(folderPath, { recursive: true });
  const bytes = await file.arrayBuffer();
  await writeFile(filePath, Buffer.from(bytes));

  const photo = await prisma.receptionPhoto.create({
    data: {
      receptionReportId,
      category,
      filename: file.name,
      storagePath,
      mimeType: file.type,
      size: file.size,
    }
  });

  return { id: photo.id, storagePath };
}
```

### Pattern 4: Targeted Notifications
**What:** Create notifications for specific users based on workflow events
**When to use:** NIR sent to Office, Differences need approval
**Example:**
```typescript
// Source: Based on existing Notification model and patterns

async function notifyOfficeNIRReady(nirId: string): Promise<void> {
  const nir = await prisma.goodsReceipt.findUnique({
    where: { id: nirId },
    include: { supplier: true }
  });

  // Find Office users (Denisa) - users with specific role/permission
  const officeUsers = await prisma.user.findMany({
    where: {
      userPermissions: {
        some: {
          permission: { name: 'reception.verify' }
        }
      },
      isActive: true
    }
  });

  const notifications = officeUsers.map(user => ({
    userId: user.id,
    type: 'nir_ready_verification',
    title: `NIR ${nir.receiptNumber} - Verificare`,
    message: `NIR de la ${nir.supplier?.name || 'furnizor'} așteaptă verificare.${nir.hasDifferences ? ' ⚠️ DIFERENȚE' : ''}`,
    data: {
      nirId: nir.id,
      receiptNumber: nir.receiptNumber,
      supplierId: nir.supplierId,
      hasDifferences: nir.hasDifferences
    },
    actionUrl: `/reception/nir/${nir.id}`
  }));

  await prisma.notification.createMany({ data: notifications });
}

async function notifyGeorgeApprovalNeeded(nirId: string): Promise<void> {
  const nir = await prisma.goodsReceipt.findUnique({
    where: { id: nirId },
    include: { supplier: true }
  });

  // Find George (manager with approval permission)
  const approvers = await prisma.user.findMany({
    where: {
      userPermissions: {
        some: {
          permission: { name: 'reception.approve_differences' }
        }
      },
      isActive: true
    }
  });

  const notifications = approvers.map(user => ({
    userId: user.id,
    type: 'nir_differences_approval',
    title: `⚠️ NIR ${nir.receiptNumber} - Diferențe`,
    message: `NIR cu diferențe necesită aprobare.`,
    data: {
      nirId: nir.id,
      receiptNumber: nir.receiptNumber,
      hasDifferences: true
    },
    actionUrl: `/reception/nir/${nir.id}`
  }));

  await prisma.notification.createMany({ data: notifications });
}
```

### Anti-Patterns to Avoid

- **Direct Status Updates Without Validation:** Never update status directly. Always use state machine with guards.

- **Bypassing Workflow Steps:** UI should disable actions that violate workflow. Backend must also validate.

- **Photo Storage in Database:** Don't store binary photo data in DB. Use filesystem (existing pattern).

- **Duplicate Stock Operations:** Stock transfer happens ONLY at NIR approval (IN_STOC). Never earlier.

- **Missing Audit Trail:** Always log who/when for status changes (existing pattern: createdBy, completedBy, etc.)

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| PDF Generation | Custom PDF rendering | pdf-lib (existing) | Already in use for picking lists, consistent styling |
| Date Formatting | Manual string formatting | date-fns (existing) | Timezone handling, localization |
| Form Validation | Custom validators | Zod schemas | Type-safe, consistent with codebase |
| File Upload | Custom file handling | Existing upload/route.ts pattern | Security sanitization already done |
| Stock Operations | Direct InventoryItem updates | inventory-stock.ts functions | Transaction safety, movement records |
| Auth/Permissions | Custom middleware | hasPermission() from lib/permissions | Existing RBAC system |

**Key insight:** This phase builds on extensive existing infrastructure. The codebase already has patterns for everything needed - extend rather than reinvent.

## Common Pitfalls

### Pitfall 1: Missing Transaction for Multi-Step Operations

**What goes wrong:** Partial updates if one step fails (e.g., NIR created but PV not marked finalized)

**Why it happens:** Multiple Prisma operations without transaction wrapper

**How to avoid:** Use `prisma.$transaction()` for all workflow transitions:
```typescript
await prisma.$transaction(async (tx) => {
  // 1. Update ReceptionReport status
  await tx.receptionReport.update({ ... });
  // 2. Create GoodsReceipt (NIR)
  await tx.goodsReceipt.create({ ... });
  // 3. Update PurchaseOrder status
  await tx.purchaseOrder.update({ ... });
});
```

**Warning signs:** Orphaned records, inconsistent statuses between related entities

### Pitfall 2: NIR Approval Without Difference Resolution

**What goes wrong:** Stock transferred with unresolved quantity/price differences

**Why it happens:** UI allows approval before George reviews differences

**How to avoid:** Hard validation in approve endpoint:
```typescript
if (nir.hasDifferences && !nir.differencesApprovedBy) {
  return { error: 'Diferențele trebuie aprobate de manager' };
}
```

**Warning signs:** Stock counts don't match invoices, financial discrepancies

### Pitfall 3: Photo Requirements Not Enforced

**What goes wrong:** Reception finalized without mandatory photos

**Why it happens:** Validation only in UI, not backend

**How to avoid:** Pre-validation in finalize endpoint:
```typescript
const photos = await prisma.receptionPhoto.findMany({
  where: { receptionReportId }
});
const hasOverview = photos.some(p => p.category === 'overview');
const hasEtichete = photos.some(p => p.category === 'etichete');
const hasFactura = photos.some(p => p.category === 'factura');

if (!hasOverview || !hasEtichete || !hasFactura) {
  return { error: 'Pozele obligatorii lipsesc (overview, etichete, factura)' };
}
```

**Warning signs:** Missing documentation, audit failures

### Pitfall 4: Supplier Mismatch Between Invoice and PO

**What goes wrong:** Invoice attached to wrong purchase order

**Why it happens:** No validation of supplier match

**How to avoid:** Validate at invoice attachment:
```typescript
if (invoice.supplierId !== purchaseOrder.supplierId) {
  return { error: 'Furnizorul de pe factură nu corespunde cu precomanda' };
}
```

**Warning signs:** Accounting errors, supplier payment issues

### Pitfall 5: Double Stock Addition

**What goes wrong:** Same reception adds stock twice

**Why it happens:** Status already IN_STOC but transfer endpoint called again

**How to avoid:** Idempotency check:
```typescript
if (nir.status === 'IN_STOC') {
  return { success: true, alreadyProcessed: true };
}
```

**Warning signs:** Inflated inventory, "InventoryStockMovement" duplicates

### Pitfall 6: Document Number Collision Under Concurrency

**What goes wrong:** Two documents get same number on busy day

**Why it happens:** Race condition in number generation

**How to avoid:** Generate number inside transaction, use SELECT FOR UPDATE or unique constraint:
```typescript
await prisma.$transaction(async (tx) => {
  const docNumber = await generateDocumentNumber('NIR', tx);
  await tx.goodsReceipt.create({
    data: { receiptNumber: docNumber, ... }
  });
});
// Unique constraint on receiptNumber catches edge cases
```

**Warning signs:** Database unique constraint errors

## Code Examples

### Example 1: Prisma Schema Extensions

```prisma
// Source: Extension of existing schema.prisma

// Purchase Order Status
enum PurchaseOrderStatus {
  DRAFT        // In editare
  APROBATA     // Aprobata, asteapta receptie
  IN_RECEPTIE  // Receptie in curs
  RECEPTIONATA // Finalizata
}

// Reception Report Status
enum ReceptionReportStatus {
  DESCHIS       // Deschis, se completeaza
  IN_COMPLETARE // In completare cantitati
  FINALIZAT     // Finalizat, NIR generat
}

// Extended NIR Status (replaces GoodsReceiptStatus)
enum NIRStatus {
  GENERAT       // NIR creat
  TRIMIS_OFFICE // Trimis la Office pentru verificare
  VERIFICAT     // Verificat de Office
  APROBAT       // Aprobat (direct sau dupa aprobare diferente)
  IN_STOC       // Transferat in stoc
  RESPINS       // Respins de George
}

// Supplier Invoice Payment Status
enum PaymentStatus {
  NEPLATITA
  PARTIAL_PLATITA
  PLATITA
}

// Photo Categories
enum PhotoCategory {
  OVERVIEW     // Marfa pe paleti
  ETICHETE     // Close-up etichete
  DETERIORARI  // Damage photos
  FACTURA      // Invoice scan
}

model PurchaseOrder {
  id             String              @id @default(cuid())
  documentNumber String              @unique  // PC-DD/MM/YYYY-NNNN

  supplierId     String
  supplier       Supplier            @relation(fields: [supplierId], references: [id])

  status         PurchaseOrderStatus @default(DRAFT)

  expectedDate   DateTime?           // Data estimata livrare
  notes          String?             @db.Text

  // Totale calculate
  totalItems     Int                 @default(0)
  totalQuantity  Decimal             @default(0) @db.Decimal(10, 3)
  totalValue     Decimal             @default(0) @db.Decimal(12, 2)

  // Workflow tracking
  approvedBy     String?
  approvedByName String?
  approvedAt     DateTime?

  createdBy      String
  createdByName  String
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt

  // Relations
  items            PurchaseOrderItem[]
  labels           PurchaseOrderLabel[]
  receptionReports ReceptionReport[]
  supplierInvoices SupplierInvoice[]

  @@index([status])
  @@index([supplierId])
  @@index([expectedDate])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String        @id @default(cuid())

  purchaseOrderId String
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id])

  quantityOrdered Decimal       @db.Decimal(10, 3)
  unitPrice       Decimal?      @db.Decimal(10, 2)
  totalPrice      Decimal?      @db.Decimal(12, 2)

  notes           String?

  createdAt       DateTime      @default(now())

  @@unique([purchaseOrderId, inventoryItemId])
  @@index([purchaseOrderId])
  @@index([inventoryItemId])
  @@map("purchase_order_items")
}

model PurchaseOrderLabel {
  id              String        @id @default(cuid())

  purchaseOrderId String
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)

  labelCode       String        @unique  // Scannable barcode/QR value
  printed         Boolean       @default(false)
  printedAt       DateTime?
  printedBy       String?

  createdAt       DateTime      @default(now())

  @@index([purchaseOrderId])
  @@index([labelCode])
  @@map("purchase_order_labels")
}

model ReceptionReport {
  id               String                 @id @default(cuid())
  reportNumber     String                 @unique  // PV-DD/MM/YYYY-NNNN

  purchaseOrderId  String
  purchaseOrder    PurchaseOrder          @relation(fields: [purchaseOrderId], references: [id])

  supplierInvoiceId String?
  supplierInvoice   SupplierInvoice?      @relation(fields: [supplierInvoiceId], references: [id])

  status           ReceptionReportStatus  @default(DESCHIS)

  // Gestionar
  warehouseUserId  String
  warehouseUserName String

  // Difference tracking
  hasDifferences   Boolean                @default(false)

  // Finalization
  finalizedAt      DateTime?
  finalizedBy      String?
  finalizedByName  String?
  signatureConfirmed Boolean              @default(false)

  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  // Relations
  items            ReceptionReportItem[]
  photos           ReceptionPhoto[]
  goodsReceipt     GoodsReceipt?          // 1:1 - NIR generated from this PV

  @@index([status])
  @@index([purchaseOrderId])
  @@index([warehouseUserId])
  @@map("reception_reports")
}

model ReceptionReportItem {
  id                 String          @id @default(cuid())

  receptionReportId  String
  receptionReport    ReceptionReport @relation(fields: [receptionReportId], references: [id], onDelete: Cascade)

  inventoryItemId    String
  inventoryItem      InventoryItem   @relation(fields: [inventoryItemId], references: [id])

  quantityExpected   Decimal         @db.Decimal(10, 3)
  quantityReceived   Decimal?        @db.Decimal(10, 3)

  verified           Boolean         @default(false)
  hasDifference      Boolean         @default(false)
  observations       String?         @db.Text  // Required if hasDifference

  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt

  @@unique([receptionReportId, inventoryItemId])
  @@index([receptionReportId])
  @@index([inventoryItemId])
  @@map("reception_report_items")
}

model ReceptionPhoto {
  id                String          @id @default(cuid())

  receptionReportId String
  receptionReport   ReceptionReport @relation(fields: [receptionReportId], references: [id], onDelete: Cascade)

  category          PhotoCategory
  filename          String          // Original filename
  storagePath       String          // /uploads/receptii/{poId}/{reportId}/filename
  mimeType          String
  size              Int             // bytes

  createdAt         DateTime        @default(now())

  @@index([receptionReportId])
  @@index([category])
  @@map("reception_photos")
}

model SupplierInvoice {
  id               String        @id @default(cuid())

  supplierId       String
  supplier         Supplier      @relation(fields: [supplierId], references: [id])

  purchaseOrderId  String?
  purchaseOrder    PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id])

  invoiceNumber    String
  invoiceSeries    String?
  invoiceDate      DateTime

  totalValue       Decimal       @db.Decimal(12, 2)
  vatValue         Decimal?      @db.Decimal(12, 2)
  totalWithVat     Decimal?      @db.Decimal(12, 2)

  paymentStatus    PaymentStatus @default(NEPLATITA)
  paymentDueDate   DateTime?
  paidAt           DateTime?

  // Document scan
  documentPath     String?       // Path to uploaded invoice scan

  notes            String?       @db.Text

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  // Relations
  receptionReports ReceptionReport[]
  goodsReceipts    GoodsReceipt[]

  @@unique([supplierId, invoiceNumber, invoiceSeries])
  @@index([supplierId])
  @@index([purchaseOrderId])
  @@index([paymentStatus])
  @@index([invoiceDate])
  @@map("supplier_invoices")
}

// EXTEND existing GoodsReceipt model - add these fields:
// In schema.prisma, modify GoodsReceipt:
//   status         NIRStatus      @default(GENERAT)  // Changed enum
//   receptionReportId String?    @unique
//   receptionReport   ReceptionReport? @relation(fields: [receptionReportId], references: [id])
//   supplierInvoiceId String?
//   supplierInvoice   SupplierInvoice? @relation(fields: [supplierInvoiceId], references: [id])
//   hasDifferences    Boolean    @default(false)
//   differencesApprovedBy String?
//   differencesApprovedAt DateTime?
//   sentToOfficeAt    DateTime?
//   verifiedAt        DateTime?
//   verifiedBy        String?
//   verifiedByName    String?
//   transferredToStockAt DateTime?
```

### Example 2: NIR Workflow State Machine

```typescript
// Source: Custom implementation following codebase patterns
// File: src/lib/reception-workflow.ts

import prisma from './db';
import { Prisma } from '@prisma/client';

type NIRStatus = 'GENERAT' | 'TRIMIS_OFFICE' | 'VERIFICAT' | 'APROBAT' | 'IN_STOC' | 'RESPINS';

interface TransitionResult {
  success: boolean;
  error?: string;
  nir?: any;
}

const NIR_TRANSITIONS: Record<string, {
  validFrom: NIRStatus[];
  guard: (nir: any, context?: any) => Promise<{ valid: boolean; error?: string }>;
  postAction?: (nir: any, tx: Prisma.TransactionClient, context?: any) => Promise<void>;
}> = {
  TRIMIS_OFFICE: {
    validFrom: ['GENERAT'],
    guard: async (nir) => {
      if (!nir.supplierInvoiceId) {
        return { valid: false, error: 'Factura furnizor este obligatorie' };
      }
      return { valid: true };
    },
    postAction: async (nir, tx) => {
      await tx.goodsReceipt.update({
        where: { id: nir.id },
        data: { sentToOfficeAt: new Date() }
      });
      // Notification happens outside transaction
    }
  },
  VERIFICAT: {
    validFrom: ['TRIMIS_OFFICE'],
    guard: async () => ({ valid: true }),
    postAction: async (nir, tx, context) => {
      await tx.goodsReceipt.update({
        where: { id: nir.id },
        data: {
          verifiedAt: new Date(),
          verifiedBy: context.userId,
          verifiedByName: context.userName
        }
      });
    }
  },
  APROBAT: {
    validFrom: ['VERIFICAT'],
    guard: async (nir) => {
      // If has differences, must be approved by George
      if (nir.hasDifferences && !nir.differencesApprovedBy) {
        return { valid: false, error: 'Diferentele trebuie aprobate de manager' };
      }
      return { valid: true };
    }
  },
  IN_STOC: {
    validFrom: ['APROBAT'],
    guard: async () => ({ valid: true }),
    postAction: async (nir, tx) => {
      // Stock transfer happens in this action
      // Import and use addInventoryStockFromWarehouse for each item
      await tx.goodsReceipt.update({
        where: { id: nir.id },
        data: { transferredToStockAt: new Date() }
      });
    }
  },
  RESPINS: {
    validFrom: ['VERIFICAT'],
    guard: async () => ({ valid: true })
  }
};

export async function transitionNIR(
  nirId: string,
  targetStatus: NIRStatus,
  context: { userId: string; userName: string }
): Promise<TransitionResult> {
  const nir = await prisma.goodsReceipt.findUnique({
    where: { id: nirId },
    include: {
      items: { include: { item: true } },
      supplier: true
    }
  });

  if (!nir) {
    return { success: false, error: 'NIR nu a fost gasit' };
  }

  const transition = NIR_TRANSITIONS[targetStatus];
  if (!transition) {
    return { success: false, error: `Status invalid: ${targetStatus}` };
  }

  if (!transition.validFrom.includes(nir.status as NIRStatus)) {
    return {
      success: false,
      error: `Tranzitie invalida: ${nir.status} -> ${targetStatus}`
    };
  }

  const guardResult = await transition.guard(nir, context);
  if (!guardResult.valid) {
    return { success: false, error: guardResult.error };
  }

  const updatedNir = await prisma.$transaction(async (tx) => {
    const updated = await tx.goodsReceipt.update({
      where: { id: nirId },
      data: { status: targetStatus }
    });

    if (transition.postAction) {
      await transition.postAction(nir, tx, context);
    }

    return updated;
  });

  return { success: true, nir: updatedNir };
}
```

### Example 3: Reception Finalization (PV -> NIR)

```typescript
// Source: Based on existing goods-receipts/[id]/complete/route.ts pattern
// File: src/app/api/reception-reports/[id]/finalize/route.ts

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: 'Neautorizat' }, { status: 401 });
  }

  const { id } = params;

  const report = await prisma.receptionReport.findUnique({
    where: { id },
    include: {
      items: { include: { inventoryItem: true } },
      photos: true,
      purchaseOrder: { include: { supplier: true } },
      supplierInvoice: true
    }
  });

  if (!report) {
    return NextResponse.json({ error: 'Raport negasit' }, { status: 404 });
  }

  // Pre-validation checks (V4, V5, V6 from spec)
  const errors: string[] = [];

  // V4: All quantities filled
  const incompleteItems = report.items.filter(i => i.quantityReceived === null);
  if (incompleteItems.length > 0) {
    errors.push('Completati cantitatea primita pentru toate produsele');
  }

  // V5: Differences require observations
  const differencesWithoutObs = report.items.filter(
    i => i.hasDifference && !i.observations
  );
  if (differencesWithoutObs.length > 0) {
    errors.push(`Completati observatii pentru: ${differencesWithoutObs.map(i => i.inventoryItem.sku).join(', ')}`);
  }

  // All items verified
  const unverifiedItems = report.items.filter(i => !i.verified);
  if (unverifiedItems.length > 0) {
    errors.push('Verificati toate liniile');
  }

  // V6: Required photos
  const photoCategories = report.photos.map(p => p.category);
  if (!photoCategories.includes('OVERVIEW')) errors.push('Lipseste poza overview');
  if (!photoCategories.includes('ETICHETE')) errors.push('Lipseste poza etichete');
  if (!photoCategories.includes('FACTURA')) errors.push('Lipseste poza factura');

  // If damage noted, damage photo required
  const hasDamageNoted = report.items.some(
    i => i.observations?.toLowerCase().includes('deteriora')
  );
  if (hasDamageNoted && !photoCategories.includes('DETERIORARI')) {
    errors.push('Exista deteriorari notate - poza obligatorie');
  }

  // Invoice attached
  if (!report.supplierInvoiceId) {
    errors.push('Factura furnizor este obligatorie');
  }

  // Signature confirmed
  if (!report.signatureConfirmed) {
    errors.push('Confirmati semnatura gestionar');
  }

  if (errors.length > 0) {
    return NextResponse.json({
      success: false,
      errors,
      message: 'Validare esuata'
    }, { status: 400 });
  }

  // All validations passed - create NIR
  const nirNumber = await generateDocumentNumber('NIR');
  const hasDifferences = report.items.some(i => i.hasDifference);

  // Calculate totals
  const totalValue = report.items.reduce((sum, item) => {
    const qty = Number(item.quantityReceived || 0);
    const price = Number(item.inventoryItem.costPrice || 0);
    return sum + (qty * price);
  }, 0);

  const result = await prisma.$transaction(async (tx) => {
    // 1. Mark report as finalized
    await tx.receptionReport.update({
      where: { id },
      data: {
        status: 'FINALIZAT',
        finalizedAt: new Date(),
        finalizedBy: session.user.id,
        finalizedByName: session.user.name || session.user.email
      }
    });

    // 2. Create NIR
    const nir = await tx.goodsReceipt.create({
      data: {
        receiptNumber: nirNumber,
        supplierId: report.purchaseOrder.supplierId,
        warehouseId: null, // Will be set on stock transfer
        supplierInvoiceId: report.supplierInvoiceId,
        receptionReportId: id,
        status: 'GENERAT',
        hasDifferences,
        totalItems: report.items.length,
        totalQuantity: report.items.reduce(
          (sum, i) => sum + Number(i.quantityReceived || 0), 0
        ),
        totalValue,
        createdBy: session.user.id,
        createdByName: session.user.name || session.user.email,
        items: {
          create: report.items.map(item => ({
            itemId: item.inventoryItemId,
            quantity: item.quantityReceived!,
            unitCost: item.inventoryItem.costPrice,
            totalCost: Number(item.quantityReceived || 0) * Number(item.inventoryItem.costPrice || 0),
            notes: item.observations
          }))
        }
      }
    });

    // 3. Update PurchaseOrder status
    await tx.purchaseOrder.update({
      where: { id: report.purchaseOrderId },
      data: { status: 'RECEPTIONATA' }
    });

    return nir;
  });

  // Send notification to Office (outside transaction)
  await notifyOfficeNIRReady(result.id);

  return NextResponse.json({
    success: true,
    data: result,
    message: `NIR ${nirNumber} generat cu succes`
  });
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Direct GoodsReceipt creation | PurchaseOrder -> ReceptionReport -> NIR flow | Phase 7.9 | Full audit trail |
| DRAFT/COMPLETED only | 6-state NIR workflow | Phase 7.9 | Approval controls |
| No photo documentation | Mandatory categorized photos | Phase 7.9 | Audit compliance |
| Product.stockQuantity | InventoryItem.currentStock | Phase 7.8 | Unified stock system |

**Current state (before 7.9):**
- GoodsReceipt exists with simplified DRAFT/COMPLETED/CANCELLED
- No purchase order tracking
- No reception verification workflow
- No photo requirements
- Stock added directly on "complete"

**After Phase 7.9:**
- Full workflow: PO -> Reception (PV) -> NIR -> Stock
- Multi-step approval for differences
- Mandatory documentation (photos, invoice)
- Stock transfer only after full approval
- In-app notifications for workflow participants

## Open Questions

1. **Email Notifications**
   - What we know: Spec mentions email to office@cashflowgrup.net
   - What's unclear: Email service configuration (Resend, SendGrid, etc.)
   - Recommendation: Start with in-app notifications only, add email in follow-up if needed

2. **SPV Alert at 5 Days**
   - What we know: Spec mentions "Setează alertă: verificare SPV la 5 zile"
   - What's unclear: What exactly is SPV verification? Scheduled task?
   - Recommendation: Defer to follow-up task, note requirement

3. **Label Format/Printing**
   - What we know: Labels needed for warehouse, existing print system exists
   - What's unclear: Exact barcode/QR format, printer hardware
   - Recommendation: Simple QR code with PO ID + SKU, PDF generation

4. **Price Difference Detection**
   - What we know: Spec mentions "preț factură ≠ preț precomandă > 2%"
   - What's unclear: Which price field on InventoryItem is "negotiated price"?
   - Recommendation: Use costPrice as reference, add negotiatedPrice to PurchaseOrderItem

## Sources

### Primary (HIGH confidence)
- **prisma/schema.prisma** - Full database models reviewed (GoodsReceipt, Supplier, InventoryItem, Notification, etc.)
- **src/app/api/goods-receipts/** - Existing NIR implementation patterns
- **src/app/api/upload/route.ts** - File upload patterns
- **src/app/api/notifications/route.ts** - Notification API patterns
- **src/lib/inventory-stock.ts** - Stock operation functions
- **FLUX_ERP_Receptie_Marfa_NIR_Stoc.html** - Complete workflow specification

### Secondary (MEDIUM confidence)
- **src/app/api/picking/[id]/print/route.ts** - PDF generation patterns
- **src/app/api/awb/[id]/comments/route.ts** - Comment + image attachment patterns
- **.planning/phases/07.8-stock-unification/07.8-RESEARCH.md** - Stock system context

### Tertiary (LOW confidence)
- None - all findings verified against codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all code reviewed directly in codebase
- Architecture: HIGH - patterns derived from existing working code
- Pitfalls: HIGH - based on workflow spec requirements and existing patterns
- Schema design: HIGH - extends existing patterns consistently

**Research date:** 2026-02-06
**Valid until:** 60 days (internal development, no external dependencies)
