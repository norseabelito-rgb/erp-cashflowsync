---
phase: 07.9-reception-workflow
plan: 02
type: execute
wave: 2
depends_on: ["07.9-01"]
files_modified:
  - src/app/api/purchase-orders/route.ts
  - src/app/api/purchase-orders/[id]/route.ts
  - src/app/api/purchase-orders/[id]/approve/route.ts
  - src/app/api/purchase-orders/[id]/labels/route.ts
  - src/lib/document-numbering.ts
autonomous: true

must_haves:
  truths:
    - "Purchase orders can be created with supplier, products, quantities"
    - "Purchase orders can be approved (DRAFT -> APROBATA)"
    - "Labels can be generated for warehouse scanning"
    - "Document numbers follow PC-DD/MM/YYYY-NNNN format"
  artifacts:
    - path: "src/app/api/purchase-orders/route.ts"
      provides: "CRUD operations for purchase orders"
      exports: ["GET", "POST", "PUT", "DELETE"]
    - path: "src/app/api/purchase-orders/[id]/labels/route.ts"
      provides: "Label generation endpoint"
      exports: ["POST", "GET"]
    - path: "src/lib/document-numbering.ts"
      provides: "Document number generation utility"
      exports: ["generateDocumentNumber"]
  key_links:
    - from: "purchase-orders/route.ts"
      to: "prisma.purchaseOrder"
      via: "database queries"
      pattern: "prisma\\.purchaseOrder\\.(create|findMany)"
    - from: "document-numbering.ts"
      to: "purchase-orders API"
      via: "import"
      pattern: "generateDocumentNumber"
---

<objective>
Create Purchase Orders CRUD API with approval workflow and label generation for warehouse scanning.

Purpose: Enable office staff to create and manage purchase orders that initiate the reception workflow
Output: Complete API for purchase order management with label generation
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.9-reception-workflow/07.9-RESEARCH.md
@.planning/phases/07.9-reception-workflow/07.9-01-SUMMARY.md
@src/app/api/goods-receipts/route.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document numbering utility</name>
  <files>src/lib/document-numbering.ts</files>
  <action>
Create a reusable utility for generating document numbers with daily auto-increment:

```typescript
import prisma from "./db";
import { Prisma } from "@prisma/client";

type DocumentPrefix = 'PC' | 'PV' | 'NIR';

/**
 * Generate document number with format: PREFIX-DD/MM/YYYY-NNNN
 * Daily auto-increment, resets to 0001 each day
 *
 * @param prefix - Document type prefix (PC, PV, NIR)
 * @param tx - Optional transaction client for atomicity
 */
export async function generateDocumentNumber(
  prefix: DocumentPrefix,
  tx?: Prisma.TransactionClient
): Promise<string> {
  const db = tx || prisma;
  const today = new Date();
  const day = String(today.getDate()).padStart(2, '0');
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const year = today.getFullYear();
  const dateStr = `${day}/${month}/${year}`;
  const searchPrefix = `${prefix}-${dateStr}`;

  // Map prefix to table and field
  const config: Record<DocumentPrefix, { table: string; field: string }> = {
    'PC': { table: 'purchaseOrder', field: 'documentNumber' },
    'PV': { table: 'receptionReport', field: 'reportNumber' },
    'NIR': { table: 'goodsReceipt', field: 'receiptNumber' }
  };

  const { table, field } = config[prefix];

  // Find last document number for today
  // Using raw query for flexibility across tables
  let lastDoc: any;

  if (prefix === 'PC') {
    lastDoc = await (db as any).purchaseOrder.findFirst({
      where: { documentNumber: { startsWith: searchPrefix } },
      orderBy: { documentNumber: 'desc' }
    });
  } else if (prefix === 'PV') {
    lastDoc = await (db as any).receptionReport.findFirst({
      where: { reportNumber: { startsWith: searchPrefix } },
      orderBy: { reportNumber: 'desc' }
    });
  } else {
    // NIR - keep existing format for backward compatibility
    // Existing NIRs use NIR-YYYYMM-NNNN format
    // New NIRs from reception workflow use DD/MM/YYYY-NNNN
    lastDoc = await (db as any).goodsReceipt.findFirst({
      where: { receiptNumber: { startsWith: searchPrefix } },
      orderBy: { receiptNumber: 'desc' }
    });
  }

  let nextNumber = 1;
  if (lastDoc) {
    const docNumber = lastDoc[field] as string;
    const parts = docNumber.split('-');
    const lastNum = parseInt(parts[parts.length - 1]);
    if (!isNaN(lastNum)) {
      nextNumber = lastNum + 1;
    }
  }

  return `${searchPrefix}-${String(nextNumber).padStart(4, '0')}`;
}

/**
 * Generate unique label code for purchase order scanning
 * Format: PO-{purchaseOrderId}-{timestamp}-{random}
 */
export function generateLabelCode(purchaseOrderId: string): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 6).toUpperCase();
  return `PO-${purchaseOrderId.substring(0, 8)}-${timestamp}-${random}`;
}
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit src/lib/document-numbering.ts`</verify>
  <done>document-numbering.ts exports generateDocumentNumber and generateLabelCode functions</done>
</task>

<task type="auto">
  <name>Task 2: Create Purchase Orders CRUD API</name>
  <files>src/app/api/purchase-orders/route.ts, src/app/api/purchase-orders/[id]/route.ts, src/app/api/purchase-orders/[id]/approve/route.ts</files>
  <action>
**src/app/api/purchase-orders/route.ts:**
- GET: List purchase orders with pagination, search, status filter, supplier filter
- POST: Create new purchase order (requires inventory.edit permission)
  - Accept: supplierId, expectedDate, notes, items (array of {inventoryItemId, quantityOrdered, unitPrice})
  - Generate documentNumber using generateDocumentNumber('PC')
  - Calculate totals (totalItems, totalQuantity, totalValue)
  - Set createdBy/createdByName from session
  - Return created order with items and supplier

Follow the pattern from goods-receipts/route.ts for auth, permissions, error handling.

**src/app/api/purchase-orders/[id]/route.ts:**
- GET: Single purchase order with supplier, items (with inventoryItem details)
- PUT: Update purchase order (only if status is DRAFT)
  - Can update: supplierId, expectedDate, notes, items
  - Recalculate totals
  - Delete existing items, create new ones (replace strategy)
- DELETE: Delete purchase order (only if status is DRAFT)

**src/app/api/purchase-orders/[id]/approve/route.ts:**
- POST: Approve purchase order (DRAFT -> APROBATA)
  - Validate: order exists, status is DRAFT
  - Validate: has at least one item
  - Validate: supplierId is set
  - Update: status = 'APROBATA', approvedBy, approvedByName, approvedAt
  - Return updated order

Permission required: inventory.edit for all operations.

Error messages in Romanian without diacritics:
- "Precomanda nu a fost gasita"
- "Doar precomenzile in status DRAFT pot fi modificate"
- "Furnizorul este obligatoriu"
- "Adaugati cel putin un produs"
  </action>
  <verify>
    - `curl -X GET http://localhost:3000/api/purchase-orders` returns list
    - `curl -X POST http://localhost:3000/api/purchase-orders -d '{...}'` creates order
  </verify>
  <done>
    - GET /api/purchase-orders lists orders with pagination
    - POST /api/purchase-orders creates order with auto-generated number
    - GET/PUT/DELETE /api/purchase-orders/[id] work for single order
    - POST /api/purchase-orders/[id]/approve transitions to APROBATA
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Labels API</name>
  <files>src/app/api/purchase-orders/[id]/labels/route.ts</files>
  <action>
Create labels endpoint for purchase order:

**POST /api/purchase-orders/[id]/labels:**
- Generate labels for the purchase order (one label per item line)
- Validate: order exists, status is APROBATA or IN_RECEPTIE
- For each item in order:
  - Create PurchaseOrderLabel with unique labelCode (using generateLabelCode)
  - Store: purchaseOrderId, labelCode, printed=false
- Return array of created labels

**GET /api/purchase-orders/[id]/labels:**
- List all labels for this purchase order
- Include: labelCode, printed status, printedAt, item details

**PUT /api/purchase-orders/[id]/labels:**
- Mark labels as printed
- Accept: labelIds array
- Update: printed=true, printedAt=now(), printedBy=session.user.id

Labels are used by warehouse staff to:
1. Scan when goods arrive (identifies which PO)
2. Track which items have been physically labeled

Permission required: inventory.view for GET, inventory.edit for POST/PUT

Include in label response:
- labelCode (for barcode/QR generation on frontend)
- purchaseOrder.documentNumber
- item SKU and name (for human-readable label)
  </action>
  <verify>
    - POST creates labels for approved PO
    - GET returns labels with item details
    - PUT marks labels as printed
  </verify>
  <done>
    - Labels can be generated for approved purchase orders
    - Each label has unique scannable code
    - Labels can be marked as printed with timestamp
  </done>
</task>

</tasks>

<verification>
1. Create purchase order: POST returns order with PC-DD/MM/YYYY-NNNN number
2. List orders: GET returns paginated list with stats
3. Approve order: POST /approve changes status to APROBATA
4. Generate labels: POST /labels creates scannable labels
5. All endpoints require authentication and inventory.* permissions
</verification>

<success_criteria>
- Purchase orders have daily auto-increment document numbers
- CRUD operations work with proper validation
- Approval workflow enforces required fields
- Labels generated with unique scannable codes
- All errors in Romanian without diacritics
</success_criteria>

<output>
After completion, create `.planning/phases/07.9-reception-workflow/07.9-02-SUMMARY.md`
</output>
