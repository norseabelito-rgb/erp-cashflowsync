---
phase: 03-internal-settlement
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/intercompany-service.ts
  - src/app/api/intercompany/preview/route.ts
autonomous: true

must_haves:
  truths:
    - "Settlement preview calculates using acquisition price (costPrice) not order price"
    - "Markup is applied to total acquisition cost, not per-line"
    - "Preview shows warnings for products without costPrice"
    - "Order selection allows excluding specific orders"
  artifacts:
    - path: "src/lib/intercompany-service.ts"
      provides: "Updated price calculation using InventoryItem.costPrice"
      exports: ["generateSettlementPreview", "calculateSettlementFromOrders"]
    - path: "src/app/api/intercompany/preview/route.ts"
      provides: "Extended preview endpoint with order selection"
      exports: ["POST"]
  key_links:
    - from: "intercompany-service.ts"
      to: "prisma.inventoryItem"
      via: "batch SKU lookup"
      pattern: "prisma\\.inventoryItem\\.findMany"
---

<objective>
Update settlement service to calculate using acquisition prices (costPrice) and support order selection.

Purpose: Core business logic fix - settlement must use acquisition price + markup, not customer prices. Add order selection to allow excluding specific orders from settlement.
Output: Updated intercompany-service.ts with correct price calculation and preview endpoint supporting order selection.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-internal-settlement/03-CONTEXT.md
@.planning/phases/03-internal-settlement/03-RESEARCH.md
@.planning/phases/03-internal-settlement/03-01-SUMMARY.md

Source files:
@src/lib/intercompany-service.ts (existing service - needs price calculation fix)
@src/app/api/intercompany/preview/route.ts (existing preview endpoint)
@prisma/schema.prisma (InventoryItem.costPrice at line 2614)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update intercompany-service price calculation</name>
  <files>src/lib/intercompany-service.ts</files>
  <action>
Refactor the service to use acquisition prices (costPrice) instead of order prices.

**1. Add new interfaces** at the top:
```typescript
interface AggregatedProduct {
  sku: string;
  title: string;
  quantity: number;
  totalCostPrice: number;  // Sum of (costPrice * quantity)
  unitCostPrice: number;   // Average unit cost
  hasCostPrice: boolean;   // false if any quantity lacks cost price
}

interface SettlementPreviewExtended extends SettlementPreview {
  warnings: string[];  // Products without costPrice
  orders: Array<{
    id: string;
    orderNumber: string;
    totalPrice: number;      // What customer paid
    costTotal: number;       // Acquisition price total for this order
    processedAt: Date;
    productCount: number;
    paymentType: "cod" | "online";
    selected: boolean;       // For UI selection
  }>;
}
```

**2. Add helper function** to batch-fetch cost prices:
```typescript
async function getCostPricesForSkus(skus: string[]): Promise<Map<string, number | null>> {
  if (skus.length === 0) return new Map();

  const items = await prisma.inventoryItem.findMany({
    where: { sku: { in: skus } },
    select: { sku: true, costPrice: true },
  });

  return new Map(items.map(i => [i.sku, i.costPrice ? Number(i.costPrice) : null]));
}
```

**3. Create new function** `calculateSettlementFromOrders`:
```typescript
export async function calculateSettlementFromOrders(
  companyId: string,
  orderIds: string[]
): Promise<SettlementPreviewExtended | null> {
  // Fetch company and orders with line items
  // Batch-fetch cost prices for all SKUs
  // Aggregate products using costPrice (not lineItem.price)
  // Calculate: subtotal = sum of (costPrice * quantity)
  // Apply markup: total = subtotal * (1 + markup/100)
  // Generate warnings for products without costPrice
  // Return extended preview with per-order cost totals
}
```

**4. Update `generateSettlementPreview`** to:
- Call the eligible orders function from 03-01
- Calculate costTotal per order using InventoryItem.costPrice
- Include payment type classification
- Include warnings array
- Keep backward compatibility with existing return shape

Key calculation logic (replace existing product aggregation):
```typescript
// Get all unique SKUs from orders
const allSkus = new Set<string>();
for (const order of orders) {
  for (const item of order.lineItems) {
    if (item.sku) allSkus.add(item.sku);
  }
}

// Batch fetch cost prices
const costPriceMap = await getCostPricesForSkus(Array.from(allSkus));
const warnings: string[] = [];

// Aggregate products with costPrice
const productMap = new Map<string, AggregatedProduct>();
for (const order of orders) {
  for (const item of order.lineItems) {
    const key = item.sku || item.title;
    const costPrice = costPriceMap.get(item.sku || "") ?? null;

    if (costPrice === null) {
      warnings.push(`${item.sku || item.title}: Pret achizitie lipsa`);
    }

    const lineTotal = (costPrice || 0) * item.quantity;
    // ... aggregate into productMap
  }
}

// Apply markup to total (not per-line)
const subtotal = Array.from(productMap.values()).reduce((sum, p) => sum + p.totalCostPrice, 0);
const markupAmount = Math.round((subtotal * markup) / 100 * 100) / 100;
const total = Math.round((subtotal + markupAmount) * 100) / 100;
```
  </action>
  <verify>
Write a test or run manual verification:
```typescript
// In a test file or Node REPL
const { generateSettlementPreview } = require('./src/lib/intercompany-service');
const result = await generateSettlementPreview('company-id');
console.log('Uses costPrice:', result?.lineItems[0]?.unitCost); // Should be costPrice, not order price
console.log('Warnings:', result?.warnings);
```
  </verify>
  <done>
Settlement preview calculates totals using InventoryItem.costPrice with markup applied to total, and includes warnings for missing cost prices.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend preview API for order selection</name>
  <files>src/app/api/intercompany/preview/route.ts</files>
  <action>
Extend the preview endpoint to support order selection.

**Add POST method** alongside existing GET:
```typescript
// POST: Generate preview for selected orders
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { companyId, orderIds } = body;

    if (!companyId) {
      return NextResponse.json(
        { success: false, error: "companyId este obligatoriu" },
        { status: 400 }
      );
    }

    if (!orderIds || !Array.isArray(orderIds) || orderIds.length === 0) {
      return NextResponse.json(
        { success: false, error: "orderIds este obligatoriu si trebuie sa contina cel putin o comanda" },
        { status: 400 }
      );
    }

    const preview = await calculateSettlementFromOrders(companyId, orderIds);

    if (!preview) {
      return NextResponse.json(
        { success: false, error: "Nu s-a putut genera preview-ul" },
        { status: 400 }
      );
    }

    return NextResponse.json({
      success: true,
      preview,
    });
  } catch (error: any) {
    console.error("[Intercompany Preview POST] Error:", error);
    return NextResponse.json(
      { success: false, error: error.message || "Eroare la generarea preview-ului" },
      { status: 500 }
    );
  }
}
```

**Update existing GET** to include:
- `warnings` array in response
- Per-order `costTotal` and `paymentType`
- `selected: true` for all orders (default pre-selection)

Response shape for both methods:
```typescript
{
  success: true,
  preview: {
    companyId: string,
    companyName: string,
    companyCode: string,
    periodStart: Date,
    periodEnd: Date,
    orders: Array<{
      id: string,
      orderNumber: string,
      totalPrice: number,     // Customer price
      costTotal: number,      // Acquisition price
      processedAt: Date,
      productCount: number,
      paymentType: "cod" | "online",
      selected: boolean,
    }>,
    lineItems: Array<{...}>,
    totals: {
      orderCount: number,
      subtotal: number,       // Sum of costPrice
      markupPercent: number,
      markupAmount: number,
      total: number,          // With markup
    },
    warnings: string[],
  }
}
```
  </action>
  <verify>
Test both endpoints:
```bash
# GET (existing, now with warnings)
curl "http://localhost:3000/api/intercompany/preview?companyId=<id>"

# POST (new, with order selection)
curl -X POST "http://localhost:3000/api/intercompany/preview" \
  -H "Content-Type: application/json" \
  -d '{"companyId": "<id>", "orderIds": ["order1", "order2"]}'
```
Both should return preview with warnings array and per-order costTotal.
  </verify>
  <done>
Preview API supports both GET (all eligible) and POST (selected orders), both returning cost-based calculations with warnings.
  </done>
</task>

</tasks>

<verification>
1. Service uses costPrice: Preview shows unitCost from InventoryItem, not lineItem.price
2. Warnings generated: Products without costPrice appear in warnings array
3. Markup on total: markupAmount = subtotal * markup%, not per-line markup
4. POST endpoint works: Can generate preview for subset of orders
5. Backward compatible: Existing UI still works with updated GET endpoint
</verification>

<success_criteria>
- Settlement calculation uses InventoryItem.costPrice instead of order line item price
- Markup is calculated on subtotal (total acquisition cost), not per line
- Preview includes warnings array listing products without costPrice
- POST endpoint allows generating preview for selected order IDs
- Per-order data includes costTotal and paymentType
</success_criteria>

<output>
After completion, create `.planning/phases/03-internal-settlement/03-02-SUMMARY.md`
</output>
