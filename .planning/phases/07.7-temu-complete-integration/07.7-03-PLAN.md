---
phase: 07.7-temu-complete-integration
plan: 03
type: execute
wave: 2
depends_on: ["07.7-01"]
files_modified:
  - src/lib/temu-order-sync.ts
  - src/lib/invoice-service.ts
autonomous: true

must_haves:
  truths:
    - "Temu orders sync to main Order table with source='temu'"
    - "TemuStore.companyId used for billingCompanyId"
    - "TemuStore.invoiceSeriesName used for invoice series resolution"
    - "Stock decreases on invoice for Temu orders"
  artifacts:
    - path: "src/lib/temu-order-sync.ts"
      provides: "Temu order sync service"
      exports: ["syncTemuOrderToMainOrder", "syncTemuOrdersForStore", "findOrCreateTemuVirtualStore"]
      min_lines: 150
    - path: "src/lib/invoice-service.ts"
      provides: "Extended invoice series resolution for Temu"
      contains: "source === \"temu\""
  key_links:
    - from: "src/lib/temu-order-sync.ts"
      to: "prisma.order.create"
      via: "syncTemuOrderToMainOrder"
      pattern: "source.*temu"
    - from: "src/lib/invoice-service.ts"
      to: "prisma.temuOrder"
      via: "Temu invoice series lookup"
      pattern: "temuStore.*invoiceSeriesName"
---

<objective>
Create Temu order sync service that syncs TemuOrder records to the main Order table, and extend invoice-service to use TemuStore.invoiceSeriesName for Temu orders.

Purpose: Enable Temu orders to flow through the unified Order -> Invoice -> AWB workflow just like Shopify and Trendyol orders, with correct company and invoice series resolution.

Output: Working order sync that creates Order records with source='temu', and invoice generation that uses the correct TemuStore invoice series.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.7-temu-complete-integration/07.7-01-SUMMARY.md

# Pattern reference
@src/lib/trendyol-order-sync.ts
@src/lib/invoice-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Temu Order Sync Service</name>
  <files>src/lib/temu-order-sync.ts</files>
  <action>
Create temu-order-sync.ts following trendyol-order-sync.ts pattern exactly.

1. Define types:
   ```typescript
   export type TemuStoreForSync = {
     id: string;
     name: string;
     appKey: string;
     companyId: string;
     region: string;
     company: { id: string; name: string } | null;
   };

   type TemuOrderWithItems = TemuOrder & {
     lineItems: Array<{
       id: string;
       temuOrderId: string;
       goodsId: string;
       skuId: string;
       title: string;
       quantity: number;
       price: Prisma.Decimal;
       localSku: string | null;
       masterProductId: string | null;
       isMapped: boolean;
     }>;
   };
   ```

2. Implement findOrCreateTemuVirtualStore(temuStore):
   - Create virtual Store with shopifyDomain = `temu-${temuStore.appKey}`
   - Use temuStore.companyId for store.companyId
   - Update companyId if changed (like Trendyol pattern)

3. Implement syncTemuOrderToMainOrder(temuOrder, temuStore):
   - Check if Order already exists (shopifyOrderId = temuOrder.temuOrderId, source = 'temu')
   - If exists: update status only
   - If new: create Order with:
     - shopifyOrderId: temuOrder.temuOrderId
     - shopifyOrderNumber: temuOrder.temuOrderNumber
     - source: "temu"
     - storeId: virtualStore.id
     - billingCompanyId: temuStore.companyId
     - customer info from temuOrder
     - totalPrice, currency from temuOrder
     - status: map Temu status to OrderStatus
   - Create LineItems from temuOrder.lineItems
   - Link TemuOrder to Order (orderId, temuStoreId)
   - Return created/updated Order

4. Implement syncTemuOrdersForStore(store, options):
   - Fetch orders from Temu API using TemuClient
   - For each order: upsert TemuOrder, then sync to main Order
   - Return { synced, created, updated, errors }
   - Support pagination and date range filtering

5. Add helper functions:
   - extractFirstName, extractLastName (from full name)
   - mapTemuStatusToOrderStatus (map Temu statuses to OrderStatus enum)

Use prisma transaction where appropriate for data consistency.
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/temu-order-sync.ts`
Verify no TypeScript errors.
  </verify>
  <done>
TemuStoreForSync type exported.
findOrCreateTemuVirtualStore creates virtual stores.
syncTemuOrderToMainOrder creates Order with source='temu'.
syncTemuOrdersForStore syncs multiple orders.
All functions handle edge cases gracefully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Invoice Service for Temu Orders</name>
  <files>src/lib/invoice-service.ts</files>
  <action>
Extend invoice series resolution in invoice-service.ts to check TemuStore.invoiceSeriesName before Trendyol check.

1. Find the invoice series resolution section (around line 410-450):
   - Currently has: Priority 0 for Trendyol, Priority 1 for oblioSeriesName, etc.

2. Add Temu check BEFORE Trendyol check (or merge into same priority):
   ```typescript
   // Variable to store TemuOrder for logging
   let temuOrder: { temuStore: { invoiceSeriesName: string | null; name: string } | null } | null = null;

   // Priority 0a: TemuStore invoice series (for Temu orders)
   if (order.source === "temu") {
     temuOrder = await prisma.temuOrder.findFirst({
       where: { orderId: order.id },
       include: { temuStore: true },
     });

     if (temuOrder?.temuStore?.invoiceSeriesName) {
       oblioSeriesName = temuOrder.temuStore.invoiceSeriesName;
       seriesSource = "temu_store";
       useOblioNumbering = true;
       console.log(`[Invoice] Folosesc seria TemuStore: ${oblioSeriesName} (${temuOrder.temuStore.name})`);
     }
   }

   // Priority 0b: TrendyolStore invoice series (existing code)
   if (order.source === "trendyol") {
     // ... existing Trendyol code
   }
   ```

3. Update seriesSource type to include "temu_store":
   - Add to the union type at line 407: `"temu_store"`

4. Update logging at line 508 to handle Temu:
   ```typescript
   console.log(`Sursa serie: ${seriesSource}${
     seriesSource === "trendyol_store" && trendyolOrder?.trendyolStore?.name ? ` (${trendyolOrder.trendyolStore.name})` :
     seriesSource === "temu_store" && temuOrder?.temuStore?.name ? ` (${temuOrder.temuStore.name})` : ""
   }`);
   ```

5. Verify stock processing still works:
   - processStockForOrder is called with order - it already handles any source
   - No changes needed to stock.ts

Note: The existing processStockForOrder in stock.ts already works for any order source.
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/invoice-service.ts`
Verify no TypeScript errors.
Check that "temu_store" appears in seriesSource type.
  </verify>
  <done>
Invoice series resolution checks TemuStore.invoiceSeriesName for source='temu' orders.
seriesSource type includes "temu_store".
Logging shows TemuStore name when using Temu series.
Stock processing continues to work (no changes needed).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Temu Status Mapping Helper</name>
  <files>src/lib/temu-status.ts</files>
  <action>
Create temu-status.ts for mapping Temu order statuses to internal OrderStatus, following trendyol-status.ts pattern.

1. Define TemuOrderStatus union type:
   ```typescript
   export type TemuOrderStatus =
     | "PENDING"
     | "PROCESSING"
     | "SHIPPED"
     | "DELIVERED"
     | "CANCELLED"
     | "RETURNED"
     | "REFUNDED"
     | string; // Allow unknown statuses
   ```

2. Implement mapTemuToInternalStatus(temuStatus):
   ```typescript
   export function mapTemuToInternalStatus(temuStatus: string): OrderStatus {
     const normalizedStatus = temuStatus.toUpperCase();

     switch (normalizedStatus) {
       case "PENDING":
       case "AWAITING_PAYMENT":
         return "PENDING";

       case "PROCESSING":
       case "CONFIRMED":
         return "VALIDATED";

       case "SHIPPED":
       case "IN_TRANSIT":
         return "SHIPPED";

       case "DELIVERED":
         return "DELIVERED";

       case "CANCELLED":
         return "CANCELLED";

       case "RETURNED":
       case "RETURN_REQUESTED":
         return "RETURNED";

       default:
         console.log(`[Temu Status] Unknown status: ${temuStatus}, defaulting to PENDING`);
         return "PENDING";
     }
   }
   ```

3. Export helper for reverse mapping if needed:
   ```typescript
   export function mapInternalToTemuStatus(status: OrderStatus): string {
     switch (status) {
       case "PENDING": return "PENDING";
       case "VALIDATED": return "PROCESSING";
       case "SHIPPED": return "SHIPPED";
       case "DELIVERED": return "DELIVERED";
       case "CANCELLED": return "CANCELLED";
       case "RETURNED": return "RETURNED";
       default: return "PENDING";
     }
   }
   ```

Note: Actual Temu status values may differ - these are placeholders.
Log unknown statuses for later adjustment based on real API data.
  </action>
  <verify>
Run: `npx tsc --noEmit src/lib/temu-status.ts`
Verify exports are correct.
  </verify>
  <done>
mapTemuToInternalStatus converts Temu statuses to OrderStatus.
Unknown statuses log warning and default to PENDING.
Module follows trendyol-status.ts pattern.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Exports correct:
   - `grep "export" src/lib/temu-order-sync.ts`
   - `grep "temu_store" src/lib/invoice-service.ts`
3. Integration test (after migration applied):
   - Create a test TemuStore
   - Call syncTemuOrderToMainOrder with mock data
   - Verify Order created with source='temu'
</verification>

<success_criteria>
- Temu orders sync to Order table with source='temu'
- TemuStore.companyId sets billingCompanyId
- Invoice series resolution uses TemuStore.invoiceSeriesName
- Status mapping handles known Temu statuses
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.7-temu-complete-integration/07.7-03-SUMMARY.md`
</output>
