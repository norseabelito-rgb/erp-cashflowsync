---
phase: 05-known-bug-fixes
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/invoice-series.ts
autonomous: true

must_haves:
  truths:
    - "Invoice series auto-correct handles negative/zero numbers"
    - "Invoice series auto-correct handles below startNumber case"
    - "Invoice series auto-correct handles gaps (currentNumber behind last invoice)"
    - "Auto-correction is idempotent (same input = same output)"
    - "Corrections are logged for audit"
  artifacts:
    - path: "src/lib/invoice-series.ts"
      provides: "Robust getNextInvoiceNumber with all edge case handling"
      contains: "lastInvoice"
  key_links:
    - from: "src/lib/invoice-series.ts"
      to: "prisma.invoice.findFirst"
      via: "check last issued invoice number for gap detection"
      pattern: "findFirst.*invoiceNumber.*desc"
---

<objective>
Make invoice series auto-correction handle all edge cases idempotently.

Purpose: Current auto-correct only handles negative/zero case. Need to handle below startNumber and gaps (when currentNumber is behind last issued invoice) to prevent invoice number collisions.

Output:
- Robust getNextInvoiceNumber that handles all edge cases
- Idempotent corrections (running multiple times produces same result)
- Comprehensive logging for audit trail
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-known-bug-fixes/05-CONTEXT.md
@.planning/phases/05-known-bug-fixes/05-RESEARCH.md
@src/lib/invoice-series.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance getNextInvoiceNumber with comprehensive edge case handling</name>
  <files>src/lib/invoice-series.ts</files>
  <action>
Refactor the getNextInvoiceNumber function to handle all edge cases idempotently:

```typescript
export async function getNextInvoiceNumber(seriesId: string): Promise<{
  prefix: string;
  number: number;
  formatted: string;
  seriesId: string;
  padding: number;
  oblioSeries: string | null;
  correctionApplied: boolean;
  correctionMessage: string | null;
} | null> {
  // Use transaction for atomic increment
  const result = await prisma.$transaction(async (tx) => {
    const series = await tx.invoiceSeries.findUnique({
      where: { id: seriesId },
    });

    if (!series || !series.isActive) {
      return null;
    }

    let currentNumber = series.currentNumber;
    let correctionApplied = false;
    const corrections: string[] = [];

    // === EDGE CASE 1: Negative or zero ===
    // Legacy data might have invalid currentNumber
    if (currentNumber < 1) {
      const newNumber = Math.max(1, series.startNumber || 1);
      corrections.push(`Numar negativ/zero corectat: ${currentNumber} -> ${newNumber}`);
      currentNumber = newNumber;
      correctionApplied = true;
    }

    // === EDGE CASE 2: Below startNumber ===
    // currentNumber should never be below the configured startNumber
    if (currentNumber < series.startNumber) {
      corrections.push(`Sub startNumber corectat: ${currentNumber} -> ${series.startNumber}`);
      currentNumber = series.startNumber;
      correctionApplied = true;
    }

    // === EDGE CASE 3: Detect gaps by checking last issued invoice ===
    // If currentNumber is behind or equal to the last issued invoice,
    // we need to jump ahead to avoid collisions
    const lastInvoice = await tx.invoice.findFirst({
      where: {
        seriesId: series.id,
        // Only consider invoices that have been numbered (not drafts)
        invoiceNumber: { not: null }
      },
      orderBy: { invoiceNumber: 'desc' },
      select: { invoiceNumber: true }
    });

    if (lastInvoice && lastInvoice.invoiceNumber !== null) {
      // Parse the invoice number from the formatted string (e.g., "CFG000123" -> 123)
      // The invoiceNumber field stores the formatted string, we need to extract the numeric part
      const lastNumber = extractNumberFromInvoice(lastInvoice.invoiceNumber, series.prefix);

      if (lastNumber !== null && lastNumber >= currentNumber) {
        const newNumber = lastNumber + 1;
        corrections.push(`Gap detectat - ultima factura ${lastNumber}, corectat: ${currentNumber} -> ${newNumber}`);
        currentNumber = newNumber;
        correctionApplied = true;
      }
    }

    // Build correction message for logging/return
    const correctionMessage = correctionApplied
      ? `Auto-corectie seria ${series.prefix}: ${corrections.join('; ')}`
      : null;

    // Only update DB if correction was needed (idempotent)
    if (correctionApplied) {
      await tx.invoiceSeries.update({
        where: { id: seriesId },
        data: { currentNumber: currentNumber },
      });
      console.log(`[InvoiceSeries] ${correctionMessage}`);
    }

    const padding = series.numberPadding || 6;

    // Increment the number for the next invoice
    await tx.invoiceSeries.update({
      where: { id: seriesId },
      data: { currentNumber: currentNumber + 1 },
    });

    return {
      prefix: series.prefix,
      number: currentNumber,
      formatted: `${series.prefix}${currentNumber.toString().padStart(padding, "0")}`,
      seriesId: series.id,
      padding,
      oblioSeries: series.oblioSeries,
      correctionApplied,
      correctionMessage,
    };
  });

  return result;
}

/**
 * Extract the numeric portion from a formatted invoice number.
 * Handles formats like "CFG000123" -> 123, "FA-000001" -> 1
 */
function extractNumberFromInvoice(invoiceNumber: string, prefix: string): number | null {
  // Remove the prefix (case insensitive)
  const withoutPrefix = invoiceNumber.replace(new RegExp(`^${prefix}`, 'i'), '');

  // Remove any separator characters (-, _, etc.)
  const numericPart = withoutPrefix.replace(/^[-_]/, '');

  // Parse the number (parseInt handles leading zeros)
  const parsed = parseInt(numericPart, 10);

  return isNaN(parsed) ? null : parsed;
}
```

Key changes:
1. Added Case 2: currentNumber below startNumber
2. Added Case 3: Gap detection by checking last issued invoice
3. Made corrections idempotent - only updates DB if value actually changes
4. Added extractNumberFromInvoice helper to parse formatted invoice numbers
5. Consolidated all corrections into single log message with details
6. Query uses `invoiceNumber: { not: null }` to skip draft invoices
  </action>
  <verify>
1. Run `npm run build` to verify TypeScript compiles.

2. Test edge cases manually in development:

```typescript
// Test in a script or API route:
import { getNextInvoiceNumber } from "@/lib/invoice-series";

// Test 1: Normal operation (no correction needed)
const result1 = await getNextInvoiceNumber(seriesId);
console.log(result1); // correctionApplied should be false

// Test 2: Simulate gap by manually setting currentNumber lower
await prisma.invoiceSeries.update({
  where: { id: seriesId },
  data: { currentNumber: 1 } // Set artificially low
});
const result2 = await getNextInvoiceNumber(seriesId);
console.log(result2); // Should show gap correction if invoices exist

// Test 3: Call again - should NOT show correction (idempotent)
const result3 = await getNextInvoiceNumber(seriesId);
console.log(result3); // correctionApplied should be false
```

3. Check logs for "[InvoiceSeries] Auto-corectie" messages with details.
  </verify>
  <done>
getNextInvoiceNumber handles all edge cases: negative/zero, below startNumber, and gaps from last invoice. Corrections are idempotent and logged for audit trail.
  </done>
</task>

</tasks>

<verification>
After task complete:
1. Build passes: `npm run build`
2. Edge case 1 handled: Set currentNumber to -5, verify corrected
3. Edge case 2 handled: Set currentNumber below startNumber, verify corrected
4. Edge case 3 handled: Set currentNumber behind last invoice, verify corrected
5. Idempotent: Run twice after correction, second run shows correctionApplied: false
</verification>

<success_criteria>
1. Negative/zero currentNumber corrected to max(1, startNumber)
2. Below startNumber corrected to startNumber
3. Gap detection corrects currentNumber to lastInvoiceNumber + 1
4. All corrections are idempotent (same input = same output)
5. Corrections logged with specific details for audit
6. No infinite correction loops
</success_criteria>

<output>
After completion, create `.planning/phases/05-known-bug-fixes/05-04-SUMMARY.md`
</output>
