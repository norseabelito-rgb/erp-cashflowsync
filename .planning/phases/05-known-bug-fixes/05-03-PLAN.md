---
phase: 05-known-bug-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/app/api/webhooks/meta/route.ts
autonomous: true

must_haves:
  truths:
    - "Duplicate webhook events are silently ignored"
    - "First occurrence of event is saved and processed"
    - "No duplicate notifications created for same event"
    - "Event ID extracted from multiple possible locations with hash fallback"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "AdsWebhookEvent model with externalEventId field"
      contains: "externalEventId"
    - path: "src/app/api/webhooks/meta/route.ts"
      provides: "Deduplication logic before event processing"
      contains: "extractEventId"
  key_links:
    - from: "src/app/api/webhooks/meta/route.ts"
      to: "prisma.adsWebhookEvent.findFirst"
      via: "check externalEventId before processing"
      pattern: "externalEventId.*findFirst"
---

<objective>
Add deduplication to Meta webhook processing to prevent notification spam.

Purpose: Meta webhooks can fire multiple times for the same event, causing duplicate notifications. Add unique event ID tracking to silently ignore duplicates.

Output:
- Schema migration adding externalEventId field
- Webhook handler that checks for duplicates before processing
- Reliable event ID extraction with fallback
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-known-bug-fixes/05-CONTEXT.md
@.planning/phases/05-known-bug-fixes/05-RESEARCH.md
@prisma/schema.prisma
@src/app/api/webhooks/meta/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add externalEventId field to AdsWebhookEvent model</name>
  <files>prisma/schema.prisma</files>
  <action>
Find the AdsWebhookEvent model (around line 2226) and add the externalEventId field:

```prisma
model AdsWebhookEvent {
  id       String      @id @default(cuid())
  platform AdsPlatform

  // Event info
  eventType String // campaign_status_changes, ad_account, etc.
  objectId  String? // ID-ul obiectului afectat
  payload   Json // Raw payload de la Meta

  // Deduplication
  externalEventId String? // Unique event ID from Facebook for deduplication

  // Processing
  processed    Boolean   @default(false)
  processedAt  DateTime?
  processError String?

  receivedAt DateTime @default(now())

  // Index for deduplication lookup (platform + externalEventId)
  @@index([platform, externalEventId])
}
```

After editing the schema, run:
```bash
npx prisma db push
```

Note: We use a composite index instead of unique constraint because:
1. externalEventId is nullable (legacy events)
2. We want fast lookup by platform + eventId
3. Deduplication is enforced in application code
  </action>
  <verify>
Run `npx prisma db push` and verify it succeeds without errors.
Run `npx prisma generate` to update the client.
Verify the field exists: `npx prisma studio` and check AdsWebhookEvent table.
  </verify>
  <done>
AdsWebhookEvent model has externalEventId field with index. Database migrated successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add event deduplication to Meta webhook handler</name>
  <files>src/app/api/webhooks/meta/route.ts</files>
  <action>
Add deduplication logic to the POST handler:

1. Import crypto if not already imported:
```typescript
import crypto from "crypto";
```

2. Add helper function to extract event ID from various payload locations:
```typescript
/**
 * Extract unique event ID from Facebook webhook payload.
 * Facebook provides event IDs in different locations depending on event type.
 * Falls back to MD5 hash of payload if no explicit ID found.
 */
function extractEventId(entry: any, change: any): string {
  // Try multiple locations where Facebook might put the event ID
  const possibleIds = [
    change.value?.id,                          // Most campaign events
    change.value?.event_id,                    // Some conversion events
    entry.id && change.field ? `${entry.id}_${change.field}_${change.value?.time || Date.now()}` : null, // Composite
  ].filter(Boolean);

  if (possibleIds.length > 0) {
    return String(possibleIds[0]);
  }

  // Fallback: generate deterministic hash from payload
  // This ensures the same payload always produces the same ID
  const payloadString = JSON.stringify({
    entryId: entry.id,
    field: change.field,
    value: change.value,
  });

  return crypto
    .createHash('md5')
    .update(payloadString)
    .digest('hex');
}
```

3. Modify the POST handler's event processing loop (around line 173-194) to check for duplicates:
```typescript
for (const entry of entries) {
  const objectId = entry.id;
  const changes = entry.changes || [];

  for (const change of changes) {
    const eventType = change.field;
    const value = change.value;

    // Extract unique event ID for deduplication
    const externalEventId = extractEventId(entry, change);

    // Check for duplicate event
    const existingEvent = await prisma.adsWebhookEvent.findFirst({
      where: {
        platform: "META",
        externalEventId,
      },
    });

    if (existingEvent) {
      console.log(`[Meta Webhook] Duplicate event ${externalEventId}, skipping`);
      continue; // Silent skip per decisions
    }

    // Save event with dedup key
    await prisma.adsWebhookEvent.create({
      data: {
        platform: "META",
        eventType,
        objectId,
        externalEventId, // NEW: store for dedup
        payload: value,
      },
    });

    // Process the event (creates notifications, updates campaigns, etc.)
    await processWebhookEvent(eventType, objectId, value);
  }
}
```

4. Update the logging to include the event ID for debugging:
```typescript
console.log(`[Meta Webhook] Processing ${eventType} for ${objectId} (eventId: ${externalEventId})`);
```
  </action>
  <verify>
1. Run `npm run build` to verify TypeScript compiles.
2. Test manually by sending same webhook payload twice (use curl or Postman):
```bash
# First call - should process
curl -X POST http://localhost:3000/api/webhooks/meta \
  -H "Content-Type: application/json" \
  -d '{"entry":[{"id":"123","changes":[{"field":"campaign_status_changes","value":{"id":"evt_123","campaign_id":"camp_1","status":"PAUSED"}}]}]}'

# Second call with same payload - should skip (check logs)
curl -X POST http://localhost:3000/api/webhooks/meta \
  -H "Content-Type: application/json" \
  -d '{"entry":[{"id":"123","changes":[{"field":"campaign_status_changes","value":{"id":"evt_123","campaign_id":"camp_1","status":"PAUSED"}}]}]}'
```
3. Check server logs for "Duplicate event" message on second call.
4. Verify only one AdsWebhookEvent record created in database.
  </verify>
  <done>
Meta webhook handler checks for duplicate events before processing. Same event received twice results in one database record and one set of notifications. Logs show "Duplicate event" for skipped duplicates.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Build passes: `npm run build`
2. Prisma schema valid: `npx prisma validate`
3. Duplicate webhooks skipped: Send same payload twice, only one record created
4. Logs show deduplication working
</verification>

<success_criteria>
1. AdsWebhookEvent model has externalEventId field indexed
2. Duplicate webhook events are silently skipped
3. First occurrence is saved and processed normally
4. Event ID extracted from multiple payload locations with hash fallback
5. No duplicate notifications created for same event
</success_criteria>

<output>
After completion, create `.planning/phases/05-known-bug-fixes/05-03-SUMMARY.md`
</output>
