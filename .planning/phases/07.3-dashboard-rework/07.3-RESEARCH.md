# Phase 7.3: Dashboard Rework - Research

**Researched:** 2026-02-03
**Domain:** Next.js Dashboard with Global Filters, Metrics, and Navigation
**Confidence:** HIGH

## Summary

This phase involves a complete rework of the dashboard page to provide global filters (date range + store), accurate metrics, clear explanations, and actionable navigation. The research focuses on:

1. URL state management patterns for filter persistence
2. Metric calculation consistency across all cards
3. Tooltip/info icon patterns for metric explanations
4. Clickable card navigation with filter propagation
5. Removing unused sections (Ads, AI Insights)
6. Adding new metrics (Returns, accurate "De Procesat", consistent "Expediate")

The existing codebase already has established patterns for tooltips, date filtering, and URL parameter management that should be leveraged.

**Primary recommendation:** Convert dashboard from server component with partial client interactivity to a client-driven component with useSearchParams for URL-persisted filter state, reusing existing tooltip patterns (ActionTooltip, InfoTooltip) for metric explanations.

## Standard Stack

### Core (Already Installed)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| next | 14.1.3 | App router, searchParams | Already in use, standard Next.js patterns |
| @tanstack/react-query | ^5.28.0 | Server state management | Already used for data fetching in client components |
| date-fns | ^3.3.1 | Date manipulation | Already installed, better than native Date |
| @radix-ui/react-tooltip | ^1.0.7 | Tooltip primitives | Already configured with TooltipProvider |
| @radix-ui/react-popover | ^1.0.7 | Info popover for explanations | Already installed for contextual help |

### Supporting (Already Available)

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| recharts | ^2.12.0 | Charts | Already used for sales chart |
| lucide-react | ^0.344.0 | Icons | Already used throughout |
| @radix-ui/react-select | ^2.0.0 | Store filter dropdown | Already used |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Native searchParams | nuqs library | nuqs adds type-safe URL state, but adds dependency; searchParams pattern already established in codebase |
| Custom date picker | react-day-picker | More features but adds complexity; native HTML date input already used in orders page |
| Server-side filtering | Client-side filtering | Server-side better for large datasets; client-side simpler for dashboard with limited data |

**Installation:** No new packages needed - all required libraries already installed.

## Architecture Patterns

### Recommended Component Structure

```
src/app/(dashboard)/dashboard/
├── page.tsx                    # Main page with filters in searchParams
├── dashboard-filters.tsx       # NEW: Global date range + store filter bar
├── dashboard-stats-api.ts      # NEW: Server action or API route for filtered stats
├── dashboard-metric-card.tsx   # NEW: Reusable metric card with tooltip + click navigation
├── dashboard-charts.tsx        # EXISTING: Already has store filter, extend with date
└── [REMOVE] dashboard-ai-insights.tsx  # Remove AI insights component
```

### Pattern 1: URL State for Filters (Next.js App Router)

**What:** Persist filter state in URL searchParams for shareability and refresh persistence
**When to use:** When filters should survive page refresh and be shareable
**Example:**
```typescript
// Source: Existing pattern from dashboard-charts.tsx
"use client";

import { useRouter, useSearchParams } from "next/navigation";

export function DashboardFilters() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const currentStore = searchParams.get("store") || "all";
  const startDate = searchParams.get("startDate") || "";
  const endDate = searchParams.get("endDate") || "";

  const handleFilterChange = (key: string, value: string) => {
    const params = new URLSearchParams(searchParams.toString());
    if (value === "all" || value === "") {
      params.delete(key);
    } else {
      params.set(key, value);
    }
    router.push(`/dashboard?${params.toString()}`);
  };

  return (/* filter UI */);
}
```

### Pattern 2: Metric Card with Tooltip and Navigation

**What:** Reusable card component with info icon tooltip and click-through navigation
**When to use:** All dashboard stat cards
**Example:**
```typescript
// Source: Derived from existing StatCard and InfoTooltip patterns

interface MetricCardProps {
  title: string;
  value: string | number;
  description: string;
  explanation: string;  // Romanian text for tooltip
  icon: React.ElementType;
  href: string;        // Navigation with filters
  variant?: "default" | "success" | "warning" | "error";
  trend?: number;
}

function MetricCard({ title, value, explanation, href, ...props }: MetricCardProps) {
  return (
    <Link href={href}>
      <Card className="cursor-pointer hover:shadow-lg transition-all">
        <CardHeader className="flex flex-row items-center justify-between pb-2">
          <div className="flex items-center gap-2">
            <CardTitle className="text-sm font-medium">{title}</CardTitle>
            <InfoTooltip content={explanation} />
          </div>
          <Icon className="h-5 w-5" />
        </CardHeader>
        <CardContent>
          <div className="text-3xl font-bold">{value}</div>
          {/* description and trend */}
        </CardContent>
      </Card>
    </Link>
  );
}
```

### Pattern 3: Filtered Stats Query

**What:** Query stats with date range and store filters applied consistently
**When to use:** All metric calculations
**Example:**
```typescript
// Source: Derived from existing getStats function and orders API pattern

async function getFilteredStats(params: {
  storeId?: string;
  startDate?: Date;
  endDate?: Date;
}) {
  const { storeId, startDate, endDate } = params;

  // Build where clause that applies to ALL queries
  const baseWhere = {
    ...(storeId && { storeId }),
    ...(startDate && endDate && {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
    }),
    ...(startDate && !endDate && {
      createdAt: { gte: startDate },
    }),
  };

  // Apply same where clause to all counts
  const [pendingOrders, validatedOrders, shipped, ...] = await Promise.all([
    prisma.order.count({ where: { ...baseWhere, status: "PENDING" } }),
    prisma.order.count({ where: { ...baseWhere, status: "VALIDATED" } }),
    // ... etc
  ]);
}
```

### Anti-Patterns to Avoid

- **Mixed filter scope:** Cards show global metrics while chart is store-filtered (current bug)
- **Hardcoded date ranges:** Using "today" without respecting selected date filter
- **String-based status matching:** Fragile pattern for AWB status categorization (addressed in Phase 7.5)
- **Metric mismatch:** "Expediate" on dashboard not matching "In tranzit" on tracking page

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Date range picker | Custom calendar component | Native HTML date inputs | Already used in orders page, consistent with existing UX |
| Tooltip component | Custom tooltip | Existing InfoTooltip/ActionTooltip | Already styled, tested, follows design system |
| URL state management | Custom state sync | useSearchParams + router.push | Standard Next.js pattern already in codebase |
| Status categorization | New logic in dashboard | Reuse getStatusCategory from tracking page | Single source of truth for AWB status logic |

**Key insight:** The codebase already has established patterns for all required functionality. This phase is about applying existing patterns consistently to the dashboard, not building new infrastructure.

## Common Pitfalls

### Pitfall 1: Filter State Inconsistency

**What goes wrong:** Some cards respect filters while others don't, creating confusing mixed data
**Why it happens:** Server component fetches data once, some queries forget to apply filter params
**How to avoid:** Extract filter params once at page level, pass to all stat queries consistently
**Warning signs:** Card counts don't match when navigating to detail pages

### Pitfall 2: Date Timezone Issues

**What goes wrong:** Date filters return unexpected results (off by one day, missing today's data)
**Why it happens:** JavaScript Date objects, database timestamps, and user timezone all differ
**How to avoid:**
- Use UTC consistently for date comparisons (existing pattern in getStats uses `Date.UTC()`)
- For single-day filter, include full day: `gte: startOfDay, lt: startOfNextDay`
**Warning signs:** "Today" filter shows yesterday's or tomorrow's data

### Pitfall 3: Navigation Filter Loss

**What goes wrong:** Clicking card navigates to detail page but filters not applied
**Why it happens:** href is hardcoded without current filter params
**How to avoid:** Build href dynamically including current date range and store from searchParams
**Warning signs:** User clicks "De Procesat" but lands on unfiltered orders page

### Pitfall 4: Metric Calculation Mismatch

**What goes wrong:** Dashboard "Expediate" count doesn't match tracking page "In tranzit"
**Why it happens:** Different queries or status categorization logic
**How to avoid:** Use SAME query/logic for dashboard stats as detail pages (ideally shared function)
**Warning signs:** Users report confusing numbers, trust erodes in dashboard accuracy

### Pitfall 5: Missing Returns Data

**What goes wrong:** "Retururi" card shows 0 when there are actual returns
**Why it happens:** Returns tracked in AWB status or separate ReturnAWB table, not Order.status
**How to avoid:**
- Check AWB currentStatus for return indicators (using getStatusCategory logic)
- Also check ReturnAWB table for scanned returns
- Clear decision: what counts as a "return" for this card?
**Warning signs:** Discrepancy between card and tracking page "Returnate" count

## Code Examples

Verified patterns from the existing codebase:

### InfoTooltip Usage (from feature-tooltip.tsx)

```typescript
// Source: /src/components/ui/feature-tooltip.tsx
export function InfoTooltip({
  content,
  side = "top",
}: {
  content: string;
  side?: "top" | "right" | "bottom" | "left";
}) {
  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <button
          type="button"
          className="inline-flex items-center justify-center h-4 w-4 rounded-full bg-muted text-muted-foreground hover:bg-muted/80 transition-colors"
        >
          <span className="text-xs font-medium">?</span>
        </button>
      </TooltipTrigger>
      <TooltipContent side={side} className="max-w-xs">
        <p className="text-xs">{content}</p>
      </TooltipContent>
    </Tooltip>
  );
}
```

### URL Filter Management (from dashboard-charts.tsx)

```typescript
// Source: /src/app/(dashboard)/dashboard/dashboard-charts.tsx
const handleStoreChange = (value: string) => {
  const params = new URLSearchParams(searchParams.toString());

  if (value === "all") {
    params.delete("store");
  } else {
    params.set("store", value);
  }

  router.push(`/dashboard?${params.toString()}`);
};
```

### AWB Status Categorization (from tracking page)

```typescript
// Source: /src/app/(dashboard)/tracking/page.tsx
type StatusCategory = 'pending' | 'in_transit' | 'delivered' | 'returned' | 'cancelled' | 'deleted' | 'error' | 'unknown';

function getStatusCategory(status: string | null): StatusCategory {
  if (!status) return 'pending';

  const s = status.toLowerCase();

  if (s.includes('retur') || s.includes('refuz') || s.includes('return')) {
    return 'returned';
  }

  if (s.includes('tranzit') || s.includes('transit') || s.includes('livrare') ||
      s.includes('preluat') || s.includes('ridicat') || s.includes('sortare') ||
      s.includes('depozit') || s.includes('expedit')) {
    return 'in_transit';
  }

  // ... etc
}
```

### Date Filter Pattern (from orders page)

```typescript
// Source: /src/app/(dashboard)/orders/page.tsx
const [startDate, setStartDate] = useState<string>("");
const [endDate, setEndDate] = useState<string>("");

// In query
if (startDate) params.set("startDate", startDate);
if (endDate) params.set("endDate", endDate);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Server component only | Client component with React Query | Already implemented | Enables real-time filter updates |
| Global metrics | Filter-scoped metrics | This phase | Accurate, relevant numbers |
| Static cards | Clickable cards with navigation | This phase | Actionable dashboard |

**Deprecated/outdated:**
- Ads section: User confirmed not useful for daily operations - remove completely
- AI Insights section: Same - remove from dashboard

## Romanian Text for Tooltips (Decision 06-06)

Per prior decision, all tooltips use Romanian text without diacritics:

| Metric | Romanian Explanation |
|--------|---------------------|
| Vanzari Azi | Valoarea totala a comenzilor din perioada selectata |
| De Procesat | Comenzi care asteapta actiune: PENDING (noi) si VALIDATED (validate dar nefacturate) |
| Expediate | Comenzi cu AWB in tranzit - colete preluate de curier dar nelivrate inca |
| Retururi | Comenzi returnate sau in curs de returnare |
| Comenzi Shopify | Comenzi din magazinele Shopify in perioada selectata |
| Comenzi Trendyol | Comenzi din magazinele Trendyol in perioada selectata |

## Open Questions

Things that couldn't be fully resolved:

1. **Returns Counting Logic**
   - What we know: AWB has `currentStatus` that can indicate return, ReturnAWB table tracks scanned returns
   - What's unclear: Should "Retururi" count AWB returns, Order status returns, or ReturnAWB entries?
   - Recommendation: Count AWBs with status category 'returned' for consistency with tracking page

2. **Date Range Default**
   - What we know: Current dashboard shows "today" by default
   - What's unclear: Should default to today, last 7 days, or current month?
   - Recommendation: Default to "today" with prominent date filter, matches user expectation for daily ops

3. **Filter Inheritance in Navigation**
   - What we know: Clicking card should navigate with filters
   - What's unclear: Should only date filter propagate, or store filter too?
   - Recommendation: Pass all active filters (date + store) to target page if that page supports them

## Sources

### Primary (HIGH confidence)
- `/src/app/(dashboard)/dashboard/page.tsx` - Current dashboard implementation
- `/src/app/(dashboard)/tracking/page.tsx` - AWB status categorization logic
- `/src/components/ui/feature-tooltip.tsx` - Existing tooltip patterns
- `/src/lib/design-system.ts` - Established design tokens

### Secondary (MEDIUM confidence)
- `/src/app/(dashboard)/orders/page.tsx` - Date filter UI pattern reference
- `/src/app/api/stats/route.ts` - Alternative stats API with period support

### Tertiary (LOW confidence)
- None - all patterns verified from codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already installed and in use
- Architecture: HIGH - Extending existing patterns, not new infrastructure
- Pitfalls: HIGH - Identified from current implementation bugs documented in roadmap

**Research date:** 2026-02-03
**Valid until:** 2026-03-03 (30 days - stable patterns, internal project)
