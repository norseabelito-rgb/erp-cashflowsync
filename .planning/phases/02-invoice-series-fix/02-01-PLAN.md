---
phase: 02-invoice-series-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/stores/[id]/route.ts
  - src/lib/invoice-series.ts
  - src/lib/invoice-errors.ts
autonomous: true

must_haves:
  truths:
    - "Store API accepts and validates invoiceSeriesId field"
    - "Series validation ensures series belongs to store's company"
    - "Romanian error messages available for all invoice errors"
  artifacts:
    - path: "src/app/api/stores/[id]/route.ts"
      provides: "invoiceSeriesId update endpoint"
      contains: "invoiceSeriesId"
    - path: "src/lib/invoice-series.ts"
      provides: "Series validation for store"
      exports: ["validateSeriesForStore"]
    - path: "src/lib/invoice-errors.ts"
      provides: "Romanian error message mapping"
      exports: ["INVOICE_ERROR_MESSAGES", "getInvoiceErrorMessage"]
  key_links:
    - from: "src/app/api/stores/[id]/route.ts"
      to: "src/lib/invoice-series.ts"
      via: "validateSeriesForStore import"
      pattern: "validateSeriesForStore"
---

<objective>
Extend the Store API to support invoice series assignment and create the Romanian error message system.

Purpose: Enable stores to be associated with specific invoice series (not just company defaults), and ensure all error messages are in Romanian as per user decision.

Output:
- Updated stores/[id] API with invoiceSeriesId validation
- Enhanced invoice-series.ts with series-to-store validation
- New invoice-errors.ts with Romanian messages
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-invoice-series-fix/02-CONTEXT.md
@.planning/phases/02-invoice-series-fix/02-RESEARCH.md
@src/app/api/stores/[id]/route.ts
@src/lib/invoice-series.ts
@prisma/schema.prisma (Store model, InvoiceSeries model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Romanian error messages module</name>
  <files>src/lib/invoice-errors.ts</files>
  <action>
Create a new file `src/lib/invoice-errors.ts` with Romanian error messages for all invoice-related errors:

```typescript
// Error codes and Romanian messages
export const INVOICE_ERROR_MESSAGES: Record<string, string> = {
  ORDER_NOT_FOUND: "Comanda nu a fost gasita.",
  ALREADY_ISSUED: "Factura a fost deja emisa pentru aceasta comanda.",
  TRANSFER_PENDING: "Transferul de stoc nu a fost finalizat. Asteapta finalizarea transferului.",
  NO_COMPANY: "Magazinul nu are o firma de facturare asociata. Mergi la Setari > Magazine pentru a configura.",
  NO_CREDENTIALS: "Credentialele Facturis nu sunt configurate pentru firma. Mergi la Setari > Firme pentru a configura.",
  NO_FACTURIS_CIF: "CIF-ul Facturis nu este configurat pentru firma. Mergi la Setari > Firme pentru a configura.",
  NO_LINE_ITEMS: "Comanda nu are produse. Nu se poate emite factura fara articole.",
  NO_SERIES: "Nu exista serie de facturare configurata pentru acest magazin. Mergi la Setari > Magazine pentru a configura.",
  NO_NUMBER: "Nu s-a putut obtine urmatorul numar de factura. Seria poate fi inactiva.",
  INVALID_ITEM_QUANTITY: "Produsul are cantitate invalida. Cantitatea trebuie sa fie mai mare decat 0.",
  INVALID_ITEM_PRICE: "Produsul are pret negativ. Pretul nu poate fi negativ.",
  CLIENT_ERROR: "Nu s-a putut crea clientul Facturis. Verifica credentialele.",
  FACTURIS_ERROR: "Eroare la comunicarea cu Facturis. Incearca din nou.",
  FACTURIS_AUTH_ERROR: "Autentificare esuata la Facturis. Verifica credentialele in Setari > Firme.",
  FACTURIS_1004: "Seria de facturare nu exista in Facturis. Verifica ca seria configurata in ERP corespunde exact cu cea din contul Facturis (case-sensitive).",
  FACTURIS_UNAVAILABLE: "Facturis nu este disponibil momentan. Incearca din nou in cateva minute.",
  SERIES_INACTIVE: "Seria de facturare este inactiva.",
  SERIES_MISMATCH: "Seria selectata nu apartine firmei magazinului.",
};

export function getInvoiceErrorMessage(errorCode: string, fallbackMessage?: string): string {
  return INVOICE_ERROR_MESSAGES[errorCode] || fallbackMessage || `Eroare necunoscuta: ${errorCode}`;
}
```
  </action>
  <verify>File exists and exports both INVOICE_ERROR_MESSAGES and getInvoiceErrorMessage. TypeScript compiles without errors: `npx tsc --noEmit src/lib/invoice-errors.ts`</verify>
  <done>Romanian error messages module created with all invoice error codes documented</done>
</task>

<task type="auto">
  <name>Task 2: Add validateSeriesForStore function</name>
  <files>src/lib/invoice-series.ts</files>
  <action>
Add a new function to `src/lib/invoice-series.ts` that validates a series can be assigned to a store:

```typescript
/**
 * Validate that a series can be assigned to a store
 * Series must belong to the store's company and be active
 * @param seriesId - The series ID to validate
 * @param storeId - The store ID
 * @returns Object with valid boolean and error message if invalid
 */
export async function validateSeriesForStore(
  seriesId: string,
  storeId: string
): Promise<{ valid: boolean; error?: string }> {
  // Get store with its company
  const store = await prisma.store.findUnique({
    where: { id: storeId },
    select: { companyId: true, name: true }
  });

  if (!store) {
    return { valid: false, error: "Magazinul nu a fost gasit" };
  }

  if (!store.companyId) {
    return { valid: false, error: "Magazinul nu are o firma asociata. Seteaza firma inainte de a configura seria." };
  }

  // Verify series exists, belongs to company, and is active
  const series = await prisma.invoiceSeries.findFirst({
    where: {
      id: seriesId,
      companyId: store.companyId,
      isActive: true,
    }
  });

  if (!series) {
    return {
      valid: false,
      error: "Seria selectata nu apartine firmei magazinului sau este inactiva"
    };
  }

  return { valid: true };
}
```

Place this function after the existing `validateSeriesForCompany` function for consistency.
  </action>
  <verify>Run `npx tsc --noEmit src/lib/invoice-series.ts` to verify TypeScript compiles. Check the function is exported in the module.</verify>
  <done>validateSeriesForStore function added that checks series belongs to store's company and is active</done>
</task>

<task type="auto">
  <name>Task 3: Update Store API to handle invoiceSeriesId</name>
  <files>src/app/api/stores/[id]/route.ts</files>
  <action>
Update the `updateStore` function in `src/app/api/stores/[id]/route.ts` to handle `invoiceSeriesId`:

1. Add `invoiceSeriesId` to the destructured body fields
2. Add validation logic before updating:
   - If `invoiceSeriesId === null`, allow clearing the series
   - If `invoiceSeriesId` is a string, validate using `validateSeriesForStore`
3. Include `invoiceSeries` in the response include

Updated function structure:
```typescript
import { validateSeriesForStore } from "@/lib/invoice-series";

async function updateStore(request: NextRequest, storeId: string) {
  try {
    const body = await request.json();
    const { name, shopifyDomain, accessToken, isActive, companyId, invoiceSeriesId } = body;

    const updateData: any = {};

    if (name !== undefined) updateData.name = name;
    if (shopifyDomain !== undefined) updateData.shopifyDomain = shopifyDomain;
    if (accessToken) updateData.accessToken = accessToken;
    if (isActive !== undefined) updateData.isActive = isActive;
    if (companyId !== undefined) updateData.companyId = companyId;

    // Handle invoiceSeriesId
    if (invoiceSeriesId !== undefined) {
      if (invoiceSeriesId === null) {
        // Allow clearing the series
        updateData.invoiceSeriesId = null;
      } else {
        // Validate series belongs to store's company
        const validation = await validateSeriesForStore(invoiceSeriesId, storeId);
        if (!validation.valid) {
          return NextResponse.json(
            { error: validation.error, success: false },
            { status: 400 }
          );
        }
        updateData.invoiceSeriesId = invoiceSeriesId;
      }
    }

    const store = await prisma.store.update({
      where: { id: storeId },
      data: updateData,
      include: {
        company: { select: { id: true, name: true } },
        invoiceSeries: { select: { id: true, name: true, prefix: true } },
      },
    });

    return NextResponse.json({ store, success: true });
  } catch (error: any) {
    console.error("Error updating store:", error);
    return NextResponse.json(
      { error: "Eroare la actualizarea magazinului", success: false },
      { status: 500 }
    );
  }
}
```

Key changes:
- Import validateSeriesForStore from invoice-series.ts
- Add invoiceSeriesId handling with validation
- Include invoiceSeries in the response
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/app/api/stores/[id]/route.ts`
2. Verify import is correct by checking the build doesn't fail
  </verify>
  <done>Store API accepts invoiceSeriesId, validates it belongs to store's company, and includes series in response</done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files
2. New invoice-errors.ts module is created with Romanian messages
3. invoice-series.ts has new validateSeriesForStore function
4. stores/[id] API accepts and validates invoiceSeriesId field
</verification>

<success_criteria>
- Error messages module exports INVOICE_ERROR_MESSAGES and getInvoiceErrorMessage
- validateSeriesForStore returns valid:true only when series belongs to store's company
- Store API returns 400 with Romanian error when invalid series is provided
- Store API successfully updates invoiceSeriesId when valid
</success_criteria>

<output>
After completion, create `.planning/phases/02-invoice-series-fix/02-01-SUMMARY.md`
</output>
