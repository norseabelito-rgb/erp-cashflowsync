---
phase: 02-invoice-series-fix
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/lib/invoice-series.ts
  - src/app/(dashboard)/invoices/failed/page.tsx
  - src/app/api/invoices/failed/route.ts
  - prisma/schema.prisma
autonomous: false

must_haves:
  truths:
    - "Edge cases (zero/negative currentNumber) are auto-corrected with notification"
    - "Failed invoice attempts are tracked in database"
    - "Failed invoices page shows all failed attempts with retry capability"
    - "Bulk generation shows progress and saves failures for later retry"
  artifacts:
    - path: "src/lib/invoice-series.ts"
      provides: "Enhanced getNextInvoiceNumber with correction notification"
      contains: "correctionApplied"
    - path: "src/app/(dashboard)/invoices/failed/page.tsx"
      provides: "Failed invoices page UI"
      min_lines: 100
    - path: "src/app/api/invoices/failed/route.ts"
      provides: "API for failed invoices"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/(dashboard)/invoices/failed/page.tsx"
      to: "/api/invoices/failed"
      via: "fetch in useQuery"
      pattern: "api/invoices/failed"
---

<objective>
Handle edge cases in invoice series numbering and create a failed invoices page for tracking and retrying failed invoice attempts.

Purpose: Ensure robust handling of edge cases (zero/negative numbers) and provide visibility into invoice generation failures with the ability to retry.

Output:
- Enhanced invoice number generation with auto-correction and notification
- FailedInvoiceAttempt tracking model
- Failed invoices page with retry functionality
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-invoice-series-fix/02-CONTEXT.md
@.planning/phases/02-invoice-series-fix/02-RESEARCH.md
@.planning/phases/02-invoice-series-fix/02-03-SUMMARY.md
@src/lib/invoice-series.ts
@src/lib/invoice-service.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance getNextInvoiceNumber with correction tracking</name>
  <files>src/lib/invoice-series.ts</files>
  <action>
Update `getNextInvoiceNumber` in `src/lib/invoice-series.ts` to return correction information:

1. **Update the return type** to include correction info:
```typescript
export async function getNextInvoiceNumber(seriesId: string): Promise<{
  prefix: string;
  number: number;
  formatted: string;
  seriesId: string;
  padding: number;
  facturisSeries: string | null;
  correctionApplied: boolean;
  correctionMessage: string | null;
} | null> {
```

2. **Track corrections** in the transaction:
```typescript
const result = await prisma.$transaction(async (tx) => {
  const series = await tx.invoiceSeries.findUnique({
    where: { id: seriesId },
  });

  if (!series || !series.isActive) {
    return null;
  }

  let currentNumber = series.currentNumber;
  let correctionApplied = false;
  let correctionMessage: string | null = null;

  // Fix: Ensure currentNumber is at least 1 (fix for legacy data with 0 or negative)
  if (currentNumber < 1) {
    const newNumber = Math.max(1, series.startNumber || 1);
    correctionApplied = true;
    correctionMessage = `Numarul seriei a fost corectat automat de la ${currentNumber} la ${newNumber}`;
    currentNumber = newNumber;

    // Update in database
    await tx.invoiceSeries.update({
      where: { id: seriesId },
      data: { currentNumber: currentNumber },
    });

    console.log(`[InvoiceSeries] Auto-corectie: seria ${series.prefix} de la ${series.currentNumber} la ${currentNumber}`);
  }

  const padding = series.numberPadding || 6;

  // Increment the number for the next invoice
  await tx.invoiceSeries.update({
    where: { id: seriesId },
    data: { currentNumber: currentNumber + 1 },
  });

  return {
    prefix: series.prefix,
    number: currentNumber,
    formatted: `${series.prefix}${currentNumber.toString().padStart(padding, "0")}`,
    seriesId: series.id,
    padding,
    facturisSeries: series.facturisSeries,
    correctionApplied,
    correctionMessage,
  };
});

return result;
```

This ensures that any auto-correction is tracked and can be communicated to the user.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/lib/invoice-series.ts`
2. Test with a series that has currentNumber = 0 (should auto-correct to 1 or startNumber)
3. Verify correctionApplied and correctionMessage are set correctly
  </verify>
  <done>getNextInvoiceNumber returns correction information when auto-correction is applied</done>
</task>

<task type="auto">
  <name>Task 2: Add FailedInvoiceAttempt model to schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add a new model to track failed invoice attempts in `prisma/schema.prisma`:

Find a suitable location (after the Invoice model) and add:
```prisma
// Incercari esuate de emitere factura (pentru retry ulterior)
model FailedInvoiceAttempt {
  id           String   @id @default(cuid())
  orderId      String
  order        Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Detalii eroare
  errorCode    String   // Codul erorii (ex: NO_SERIES, FACTURIS_ERROR)
  errorMessage String   // Mesajul de eroare complet

  // Context
  storeId      String?
  storeName    String?
  companyId    String?
  companyName  String?
  seriesId     String?
  seriesName   String?

  // Status
  status       String   @default("pending") // pending, retried, resolved
  retriedAt    DateTime?
  resolvedAt   DateTime?

  // Tracking
  attemptNumber Int     @default(1)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([orderId])
  @@index([status])
  @@index([createdAt])
  @@map("failed_invoice_attempts")
}
```

Also update the Order model to add the relation (find the Order model and add to relations section):
```prisma
// In Order model, add:
failedInvoiceAttempts FailedInvoiceAttempt[]
```

After updating schema, run:
```bash
npx prisma generate
```

Note: The migration will be handled separately or via the force-migration script.
  </action>
  <verify>
1. `npx prisma validate` passes
2. `npx prisma generate` succeeds
3. New FailedInvoiceAttempt type is available in PrismaClient
  </verify>
  <done>FailedInvoiceAttempt model added to track failed invoice attempts for retry</done>
</task>

<task type="auto">
  <name>Task 3: Create failed invoices API endpoint</name>
  <files>src/app/api/invoices/failed/route.ts</files>
  <action>
Create a new API endpoint for managing failed invoice attempts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/db";
import { issueInvoiceForOrder } from "@/lib/invoice-service";

// GET - List all failed invoice attempts
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const status = searchParams.get("status") || "pending";
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "50");
    const skip = (page - 1) * limit;

    const where = status === "all" ? {} : { status };

    const [attempts, total] = await Promise.all([
      prisma.failedInvoiceAttempt.findMany({
        where,
        include: {
          order: {
            select: {
              id: true,
              shopifyOrderNumber: true,
              customerEmail: true,
              totalPrice: true,
              status: true,
            },
          },
        },
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.failedInvoiceAttempt.count({ where }),
    ]);

    return NextResponse.json({
      attempts,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    });
  } catch (error: any) {
    console.error("Error fetching failed attempts:", error);
    return NextResponse.json(
      { error: "Eroare la incarcarea facturilor esuate" },
      { status: 500 }
    );
  }
}

// POST - Retry a failed invoice
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { attemptId } = body;

    if (!attemptId) {
      return NextResponse.json(
        { error: "ID-ul incercarii este obligatoriu" },
        { status: 400 }
      );
    }

    // Get the failed attempt
    const attempt = await prisma.failedInvoiceAttempt.findUnique({
      where: { id: attemptId },
      include: { order: true },
    });

    if (!attempt) {
      return NextResponse.json(
        { error: "Incercarea nu a fost gasita" },
        { status: 404 }
      );
    }

    if (attempt.status !== "pending") {
      return NextResponse.json(
        { error: "Aceasta incercare a fost deja procesata" },
        { status: 400 }
      );
    }

    // Retry invoice generation
    const result = await issueInvoiceForOrder(attempt.orderId);

    if (result.success) {
      // Mark as resolved
      await prisma.failedInvoiceAttempt.update({
        where: { id: attemptId },
        data: {
          status: "resolved",
          resolvedAt: new Date(),
          retriedAt: new Date(),
        },
      });

      return NextResponse.json({
        success: true,
        message: "Factura a fost emisa cu succes",
        invoice: {
          number: result.invoiceNumber,
          series: result.invoiceSeries,
        },
      });
    } else {
      // Update attempt with new error and increment counter
      await prisma.failedInvoiceAttempt.update({
        where: { id: attemptId },
        data: {
          errorCode: result.errorCode || "UNKNOWN",
          errorMessage: result.error || "Eroare necunoscuta",
          attemptNumber: { increment: 1 },
          retriedAt: new Date(),
        },
      });

      return NextResponse.json({
        success: false,
        error: result.error,
        errorCode: result.errorCode,
      });
    }
  } catch (error: any) {
    console.error("Error retrying invoice:", error);
    return NextResponse.json(
      { error: "Eroare la reincercarea facturii" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/app/api/invoices/failed/route.ts`
2. API responds to GET /api/invoices/failed
3. API responds to POST /api/invoices/failed with attemptId
  </verify>
  <done>Failed invoices API supports listing and retrying failed attempts</done>
</task>

<task type="auto">
  <name>Task 4: Create failed invoices page</name>
  <files>src/app/(dashboard)/invoices/failed/page.tsx</files>
  <action>
Create a new page for viewing and retrying failed invoice attempts:

```tsx
"use client";

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  AlertCircle,
  RefreshCw,
  Check,
  Clock,
  Loader2,
  FileText,
  Store,
  Building2,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "@/hooks/use-toast";
import { PageHeader } from "@/components/ui/page-header";
import { formatDate } from "@/lib/utils";

interface FailedAttempt {
  id: string;
  orderId: string;
  errorCode: string;
  errorMessage: string;
  storeName: string | null;
  companyName: string | null;
  seriesName: string | null;
  status: string;
  attemptNumber: number;
  createdAt: string;
  retriedAt: string | null;
  order: {
    id: string;
    shopifyOrderNumber: string;
    customerEmail: string | null;
    totalPrice: number;
    status: string;
  };
}

export default function FailedInvoicesPage() {
  const queryClient = useQueryClient();
  const [statusFilter, setStatusFilter] = useState("pending");
  const [retryingId, setRetryingId] = useState<string | null>(null);

  // Fetch failed attempts
  const { data, isLoading } = useQuery({
    queryKey: ["failed-invoices", statusFilter],
    queryFn: async () => {
      const res = await fetch(`/api/invoices/failed?status=${statusFilter}`);
      if (!res.ok) throw new Error("Failed to fetch");
      return res.json();
    },
  });

  // Retry mutation
  const retryMutation = useMutation({
    mutationFn: async (attemptId: string) => {
      const res = await fetch("/api/invoices/failed", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ attemptId }),
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Retry failed");
      }
      return res.json();
    },
    onMutate: (attemptId) => {
      setRetryingId(attemptId);
    },
    onSuccess: (data) => {
      if (data.success) {
        toast({
          title: "Succes",
          description: `Factura ${data.invoice?.number} a fost emisa`,
        });
      } else {
        toast({
          title: "Eroare la reincercare",
          description: data.error,
          variant: "destructive",
        });
      }
      queryClient.invalidateQueries({ queryKey: ["failed-invoices"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Eroare",
        description: error.message,
        variant: "destructive",
      });
    },
    onSettled: () => {
      setRetryingId(null);
    },
  });

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "pending":
        return <Badge variant="destructive"><Clock className="h-3 w-3 mr-1" />In asteptare</Badge>;
      case "retried":
        return <Badge variant="secondary"><RefreshCw className="h-3 w-3 mr-1" />Reincercat</Badge>;
      case "resolved":
        return <Badge variant="default" className="bg-green-500"><Check className="h-3 w-3 mr-1" />Rezolvat</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-6">
      <PageHeader
        title="Facturi esuate"
        description="Facturi care nu au putut fi emise. Poti reincerca dupa ce rezolvi problema."
      />

      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <AlertCircle className="h-5 w-5 text-destructive" />
                Incercari esuate
              </CardTitle>
              <CardDescription>
                {data?.pagination?.total || 0} incercari in total
              </CardDescription>
            </div>
            <Select value={statusFilter} onValueChange={setStatusFilter}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Filtreaza dupa status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="pending">In asteptare</SelectItem>
                <SelectItem value="resolved">Rezolvate</SelectItem>
                <SelectItem value="all">Toate</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <div className="flex justify-center py-8">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : data?.attempts?.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <FileText className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Nu exista facturi esuate</p>
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Comanda</TableHead>
                  <TableHead>Magazin</TableHead>
                  <TableHead>Eroare</TableHead>
                  <TableHead>Incercari</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Data</TableHead>
                  <TableHead className="text-right">Actiuni</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {data?.attempts?.map((attempt: FailedAttempt) => (
                  <TableRow key={attempt.id}>
                    <TableCell className="font-medium">
                      {attempt.order.shopifyOrderNumber}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-1">
                        <Store className="h-3 w-3 text-muted-foreground" />
                        {attempt.storeName || "-"}
                      </div>
                      {attempt.companyName && (
                        <div className="flex items-center gap-1 text-xs text-muted-foreground">
                          <Building2 className="h-3 w-3" />
                          {attempt.companyName}
                        </div>
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="max-w-[300px]">
                        <Badge variant="outline" className="mb-1">
                          {attempt.errorCode}
                        </Badge>
                        <p className="text-sm text-muted-foreground truncate">
                          {attempt.errorMessage}
                        </p>
                      </div>
                    </TableCell>
                    <TableCell>{attempt.attemptNumber}</TableCell>
                    <TableCell>{getStatusBadge(attempt.status)}</TableCell>
                    <TableCell className="text-sm text-muted-foreground">
                      {formatDate(attempt.createdAt)}
                    </TableCell>
                    <TableCell className="text-right">
                      {attempt.status === "pending" && (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => retryMutation.mutate(attempt.id)}
                          disabled={retryingId === attempt.id}
                        >
                          {retryingId === attempt.id ? (
                            <Loader2 className="h-4 w-4 animate-spin" />
                          ) : (
                            <>
                              <RefreshCw className="h-4 w-4 mr-1" />
                              Reincearca
                            </>
                          )}
                        </Button>
                      )}
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```
  </action>
  <verify>
1. Page loads at /invoices/failed
2. Shows list of failed attempts (may be empty initially)
3. Retry button triggers API call
4. Status filter works
  </verify>
  <done>Failed invoices page shows all failed attempts with retry capability and status filtering</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 implementation:
1. Romanian error messages system
2. Store-series mapping in settings
3. Automatic series selection in invoice generation
4. Edge case handling with correction tracking
5. Failed invoices page with retry capability
  </what-built>
  <how-to-verify>
1. Go to Settings > Magazine and edit a store
   - Verify series dropdown appears when company is selected
   - Select a series and save
2. Go to Settings > Serii Facturare
   - Scroll down to see "Sumar mapari" table
   - Verify it shows store status correctly
3. Create/view an order and attempt to issue invoice
   - For store WITH series: invoice should use that series
   - For store WITHOUT series: should use company default
   - For store WITHOUT series and NO company default: should show Romanian error
4. Check /invoices/failed page
   - Should show any failed attempts (if any exist)
   - Retry button should work
5. Verify all error messages are in Romanian
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. getNextInvoiceNumber returns correctionApplied and correctionMessage
2. FailedInvoiceAttempt model exists in Prisma schema
3. /api/invoices/failed endpoint works for GET and POST
4. /invoices/failed page loads and displays failed attempts
5. Retry functionality works and updates status
6. All messages in Romanian
</verification>

<success_criteria>
- Edge cases (zero/negative numbers) are auto-corrected and tracked
- Failed invoice attempts are persisted in database
- Failed invoices page shows all pending failures
- Retry button successfully re-attempts invoice generation
- User can filter by status (pending, resolved, all)
- Phase 2 success criteria met: invoices use correct series automatically
</success_criteria>

<output>
After completion, create `.planning/phases/02-invoice-series-fix/02-04-SUMMARY.md`
</output>
