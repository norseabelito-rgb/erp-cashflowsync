---
phase: 02-invoice-series-fix
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/lib/invoice-series.ts
  - src/app/api/invoices/failed/route.ts
  - prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "Edge cases (zero/negative currentNumber) are auto-corrected with notification"
    - "Failed invoice attempts are tracked in database"
    - "Failed invoices API supports listing and retry"
  artifacts:
    - path: "src/lib/invoice-series.ts"
      provides: "Enhanced getNextInvoiceNumber with correction notification"
      contains: "correctionApplied"
    - path: "prisma/schema.prisma"
      provides: "FailedInvoiceAttempt model"
      contains: "FailedInvoiceAttempt"
    - path: "src/app/api/invoices/failed/route.ts"
      provides: "API for failed invoices"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/invoices/failed/route.ts"
      to: "src/lib/invoice-service.ts"
      via: "issueInvoiceForOrder import"
      pattern: "issueInvoiceForOrder"
---

<objective>
Handle edge cases in invoice series numbering and create the backend infrastructure for tracking failed invoice attempts.

Purpose: Ensure robust handling of edge cases (zero/negative numbers) and provide database storage and API for failed invoice tracking. The UI will be created in a separate plan (02-05).

Output:
- Enhanced invoice number generation with auto-correction and notification
- FailedInvoiceAttempt tracking model in Prisma
- Failed invoices API endpoint (GET/POST)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-invoice-series-fix/02-CONTEXT.md
@.planning/phases/02-invoice-series-fix/02-RESEARCH.md
@.planning/phases/02-invoice-series-fix/02-03-SUMMARY.md
@src/lib/invoice-series.ts
@src/lib/invoice-service.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance getNextInvoiceNumber with correction tracking</name>
  <files>src/lib/invoice-series.ts</files>
  <action>
Update `getNextInvoiceNumber` in `src/lib/invoice-series.ts` to return correction information:

1. **Update the return type** to include correction info:
```typescript
export async function getNextInvoiceNumber(seriesId: string): Promise<{
  prefix: string;
  number: number;
  formatted: string;
  seriesId: string;
  padding: number;
  facturisSeries: string | null;
  correctionApplied: boolean;
  correctionMessage: string | null;
} | null> {
```

2. **Track corrections** in the transaction:
```typescript
const result = await prisma.$transaction(async (tx) => {
  const series = await tx.invoiceSeries.findUnique({
    where: { id: seriesId },
  });

  if (!series || !series.isActive) {
    return null;
  }

  let currentNumber = series.currentNumber;
  let correctionApplied = false;
  let correctionMessage: string | null = null;

  // Fix: Ensure currentNumber is at least 1 (fix for legacy data with 0 or negative)
  if (currentNumber < 1) {
    const newNumber = Math.max(1, series.startNumber || 1);
    correctionApplied = true;
    correctionMessage = `Numarul seriei a fost corectat automat de la ${currentNumber} la ${newNumber}`;
    currentNumber = newNumber;

    // Update in database
    await tx.invoiceSeries.update({
      where: { id: seriesId },
      data: { currentNumber: currentNumber },
    });

    console.log(`[InvoiceSeries] Auto-corectie: seria ${series.prefix} de la ${series.currentNumber} la ${currentNumber}`);
  }

  const padding = series.numberPadding || 6;

  // Increment the number for the next invoice
  await tx.invoiceSeries.update({
    where: { id: seriesId },
    data: { currentNumber: currentNumber + 1 },
  });

  return {
    prefix: series.prefix,
    number: currentNumber,
    formatted: `${series.prefix}${currentNumber.toString().padStart(padding, "0")}`,
    seriesId: series.id,
    padding,
    facturisSeries: series.facturisSeries,
    correctionApplied,
    correctionMessage,
  };
});

return result;
```

This ensures that any auto-correction is tracked and can be communicated to the user.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/lib/invoice-series.ts`
2. Test with a series that has currentNumber = 0 (should auto-correct to 1 or startNumber)
3. Verify correctionApplied and correctionMessage are set correctly
  </verify>
  <done>getNextInvoiceNumber returns correction information when auto-correction is applied</done>
</task>

<task type="auto">
  <name>Task 2: Add FailedInvoiceAttempt model to schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add a new model to track failed invoice attempts in `prisma/schema.prisma`:

Find a suitable location (after the Invoice model) and add:
```prisma
// Incercari esuate de emitere factura (pentru retry ulterior)
model FailedInvoiceAttempt {
  id           String   @id @default(cuid())
  orderId      String
  order        Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Detalii eroare
  errorCode    String   // Codul erorii (ex: NO_SERIES, FACTURIS_ERROR)
  errorMessage String   // Mesajul de eroare complet

  // Context
  storeId      String?
  storeName    String?
  companyId    String?
  companyName  String?
  seriesId     String?
  seriesName   String?

  // Status
  status       String   @default("pending") // pending, retried, resolved
  retriedAt    DateTime?
  resolvedAt   DateTime?

  // Tracking
  attemptNumber Int     @default(1)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([orderId])
  @@index([status])
  @@index([createdAt])
  @@map("failed_invoice_attempts")
}
```

Also update the Order model to add the relation (find the Order model and add to relations section):
```prisma
// In Order model, add:
failedInvoiceAttempts FailedInvoiceAttempt[]
```

After updating schema, run:
```bash
npx prisma generate
```

Note: The migration will be handled separately or via the force-migration script.
  </action>
  <verify>
1. `npx prisma validate` passes
2. `npx prisma generate` succeeds
3. New FailedInvoiceAttempt type is available in PrismaClient
  </verify>
  <done>FailedInvoiceAttempt model added to track failed invoice attempts for retry</done>
</task>

<task type="auto">
  <name>Task 3: Create failed invoices API endpoint</name>
  <files>src/app/api/invoices/failed/route.ts</files>
  <action>
Create a new API endpoint for managing failed invoice attempts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/db";
import { issueInvoiceForOrder } from "@/lib/invoice-service";

// GET - List all failed invoice attempts
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const status = searchParams.get("status") || "pending";
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "50");
    const skip = (page - 1) * limit;

    const where = status === "all" ? {} : { status };

    const [attempts, total] = await Promise.all([
      prisma.failedInvoiceAttempt.findMany({
        where,
        include: {
          order: {
            select: {
              id: true,
              shopifyOrderNumber: true,
              customerEmail: true,
              totalPrice: true,
              status: true,
            },
          },
        },
        orderBy: { createdAt: "desc" },
        skip,
        take: limit,
      }),
      prisma.failedInvoiceAttempt.count({ where }),
    ]);

    return NextResponse.json({
      attempts,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    });
  } catch (error: any) {
    console.error("Error fetching failed attempts:", error);
    return NextResponse.json(
      { error: "Eroare la incarcarea facturilor esuate" },
      { status: 500 }
    );
  }
}

// POST - Retry a failed invoice
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { attemptId } = body;

    if (!attemptId) {
      return NextResponse.json(
        { error: "ID-ul incercarii este obligatoriu" },
        { status: 400 }
      );
    }

    // Get the failed attempt
    const attempt = await prisma.failedInvoiceAttempt.findUnique({
      where: { id: attemptId },
      include: { order: true },
    });

    if (!attempt) {
      return NextResponse.json(
        { error: "Incercarea nu a fost gasita" },
        { status: 404 }
      );
    }

    if (attempt.status !== "pending") {
      return NextResponse.json(
        { error: "Aceasta incercare a fost deja procesata" },
        { status: 400 }
      );
    }

    // Retry invoice generation
    const result = await issueInvoiceForOrder(attempt.orderId);

    if (result.success) {
      // Mark as resolved
      await prisma.failedInvoiceAttempt.update({
        where: { id: attemptId },
        data: {
          status: "resolved",
          resolvedAt: new Date(),
          retriedAt: new Date(),
        },
      });

      return NextResponse.json({
        success: true,
        message: "Factura a fost emisa cu succes",
        invoice: {
          number: result.invoiceNumber,
          series: result.invoiceSeries,
        },
      });
    } else {
      // Update attempt with new error and increment counter
      await prisma.failedInvoiceAttempt.update({
        where: { id: attemptId },
        data: {
          errorCode: result.errorCode || "UNKNOWN",
          errorMessage: result.error || "Eroare necunoscuta",
          attemptNumber: { increment: 1 },
          retriedAt: new Date(),
        },
      });

      return NextResponse.json({
        success: false,
        error: result.error,
        errorCode: result.errorCode,
      });
    }
  } catch (error: any) {
    console.error("Error retrying invoice:", error);
    return NextResponse.json(
      { error: "Eroare la reincercarea facturii" },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/app/api/invoices/failed/route.ts`
2. API responds to GET /api/invoices/failed
3. API responds to POST /api/invoices/failed with attemptId
  </verify>
  <done>Failed invoices API supports listing and retrying failed attempts</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit src/lib/invoice-series.ts src/app/api/invoices/failed/route.ts`
2. Prisma validates: `npx prisma validate`
3. Prisma generates: `npx prisma generate`
4. API endpoint responds: `curl -s localhost:3000/api/invoices/failed | jq '.attempts'`
</verification>

<success_criteria>
- Edge cases (zero/negative numbers) are auto-corrected and tracked via correctionApplied
- FailedInvoiceAttempt model exists in Prisma schema
- Failed invoices API responds to GET with pagination
- Failed invoices API responds to POST for retry functionality
</success_criteria>

<output>
After completion, create `.planning/phases/02-invoice-series-fix/02-04-SUMMARY.md`
</output>
