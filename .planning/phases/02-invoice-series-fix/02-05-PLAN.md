---
phase: 02-invoice-series-fix
plan: 05
type: execute
wave: 4
depends_on: ["02-04"]
files_modified:
  - src/app/(dashboard)/invoices/failed/page.tsx
autonomous: false

must_haves:
  truths:
    - "Failed invoices page shows all failed attempts with retry capability"
    - "User can filter failed attempts by status"
    - "Retry button triggers invoice regeneration"
  artifacts:
    - path: "src/app/(dashboard)/invoices/failed/page.tsx"
      provides: "Failed invoices page UI"
      min_lines: 100
  key_links:
    - from: "src/app/(dashboard)/invoices/failed/page.tsx"
      to: "/api/invoices/failed"
      via: "fetch in useQuery"
      pattern: "api/invoices/failed"
---

<objective>
Create the failed invoices page UI and perform final phase verification.

Purpose: Provide visibility into invoice generation failures with the ability to retry, and verify that all Phase 2 functionality works end-to-end.

Output:
- Failed invoices page with retry functionality
- Complete Phase 2 verification
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-invoice-series-fix/02-CONTEXT.md
@.planning/phases/02-invoice-series-fix/02-04-SUMMARY.md
@src/app/api/invoices/failed/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create failed invoices page</name>
  <files>src/app/(dashboard)/invoices/failed/page.tsx</files>
  <action>
Create a new page for viewing and retrying failed invoice attempts:

```tsx
"use client";

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  AlertCircle,
  RefreshCw,
  Check,
  Clock,
  Loader2,
  FileText,
  Store,
  Building2,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "@/hooks/use-toast";
import { PageHeader } from "@/components/ui/page-header";
import { formatDate } from "@/lib/utils";

interface FailedAttempt {
  id: string;
  orderId: string;
  errorCode: string;
  errorMessage: string;
  storeName: string | null;
  companyName: string | null;
  seriesName: string | null;
  status: string;
  attemptNumber: number;
  createdAt: string;
  retriedAt: string | null;
  order: {
    id: string;
    shopifyOrderNumber: string;
    customerEmail: string | null;
    totalPrice: number;
    status: string;
  };
}

export default function FailedInvoicesPage() {
  const queryClient = useQueryClient();
  const [statusFilter, setStatusFilter] = useState("pending");
  const [retryingId, setRetryingId] = useState<string | null>(null);

  // Fetch failed attempts
  const { data, isLoading } = useQuery({
    queryKey: ["failed-invoices", statusFilter],
    queryFn: async () => {
      const res = await fetch(`/api/invoices/failed?status=${statusFilter}`);
      if (!res.ok) throw new Error("Failed to fetch");
      return res.json();
    },
  });

  // Retry mutation
  const retryMutation = useMutation({
    mutationFn: async (attemptId: string) => {
      const res = await fetch("/api/invoices/failed", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ attemptId }),
      });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || "Retry failed");
      }
      return res.json();
    },
    onMutate: (attemptId) => {
      setRetryingId(attemptId);
    },
    onSuccess: (data) => {
      if (data.success) {
        toast({
          title: "Succes",
          description: `Factura ${data.invoice?.number} a fost emisa`,
        });
      } else {
        toast({
          title: "Eroare la reincercare",
          description: data.error,
          variant: "destructive",
        });
      }
      queryClient.invalidateQueries({ queryKey: ["failed-invoices"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Eroare",
        description: error.message,
        variant: "destructive",
      });
    },
    onSettled: () => {
      setRetryingId(null);
    },
  });

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "pending":
        return <Badge variant="destructive"><Clock className="h-3 w-3 mr-1" />In asteptare</Badge>;
      case "retried":
        return <Badge variant="secondary"><RefreshCw className="h-3 w-3 mr-1" />Reincercat</Badge>;
      case "resolved":
        return <Badge variant="default" className="bg-green-500"><Check className="h-3 w-3 mr-1" />Rezolvat</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-6">
      <PageHeader
        title="Facturi esuate"
        description="Facturi care nu au putut fi emise. Poti reincerca dupa ce rezolvi problema."
      />

      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <AlertCircle className="h-5 w-5 text-destructive" />
                Incercari esuate
              </CardTitle>
              <CardDescription>
                {data?.pagination?.total || 0} incercari in total
              </CardDescription>
            </div>
            <Select value={statusFilter} onValueChange={setStatusFilter}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Filtreaza dupa status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="pending">In asteptare</SelectItem>
                <SelectItem value="resolved">Rezolvate</SelectItem>
                <SelectItem value="all">Toate</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <div className="flex justify-center py-8">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : data?.attempts?.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <FileText className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Nu exista facturi esuate</p>
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Comanda</TableHead>
                  <TableHead>Magazin</TableHead>
                  <TableHead>Eroare</TableHead>
                  <TableHead>Incercari</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Data</TableHead>
                  <TableHead className="text-right">Actiuni</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {data?.attempts?.map((attempt: FailedAttempt) => (
                  <TableRow key={attempt.id}>
                    <TableCell className="font-medium">
                      {attempt.order.shopifyOrderNumber}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-1">
                        <Store className="h-3 w-3 text-muted-foreground" />
                        {attempt.storeName || "-"}
                      </div>
                      {attempt.companyName && (
                        <div className="flex items-center gap-1 text-xs text-muted-foreground">
                          <Building2 className="h-3 w-3" />
                          {attempt.companyName}
                        </div>
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="max-w-[300px]">
                        <Badge variant="outline" className="mb-1">
                          {attempt.errorCode}
                        </Badge>
                        <p className="text-sm text-muted-foreground truncate">
                          {attempt.errorMessage}
                        </p>
                      </div>
                    </TableCell>
                    <TableCell>{attempt.attemptNumber}</TableCell>
                    <TableCell>{getStatusBadge(attempt.status)}</TableCell>
                    <TableCell className="text-sm text-muted-foreground">
                      {formatDate(attempt.createdAt)}
                    </TableCell>
                    <TableCell className="text-right">
                      {attempt.status === "pending" && (
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => retryMutation.mutate(attempt.id)}
                          disabled={retryingId === attempt.id}
                        >
                          {retryingId === attempt.id ? (
                            <Loader2 className="h-4 w-4 animate-spin" />
                          ) : (
                            <>
                              <RefreshCw className="h-4 w-4 mr-1" />
                              Reincearca
                            </>
                          )}
                        </Button>
                      )}
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/app/\\(dashboard\\)/invoices/failed/page.tsx`
2. Page renders without console errors (start dev server and navigate to /invoices/failed)
  </verify>
  <done>Failed invoices page shows all failed attempts with retry capability and status filtering</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 implementation:
1. Romanian error messages system (02-01)
2. Store-series mapping in settings with manual creation guidance (02-02)
3. Automatic series selection in invoice generation (02-03)
4. Edge case handling with correction tracking (02-04)
5. Failed invoices page with retry capability (02-05)
  </what-built>
  <how-to-verify>
1. Go to Settings > Magazine and edit a store
   - Verify series dropdown appears when company is selected
   - Select a series and save
2. Go to Settings > Serii Facturare
   - Verify guidance note about manual series creation (Facturis has no series API)
   - Scroll down to see "Sumar mapari" table
   - Verify it shows store status correctly
3. Create/view an order and attempt to issue invoice
   - For store WITH series: invoice should use that series
   - For store WITHOUT series: should use company default
   - For store WITHOUT series and NO company default: should show Romanian error
4. Check /invoices/failed page
   - Should show any failed attempts (if any exist)
   - Retry button should work
5. Verify all error messages are in Romanian
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles for all files
2. /invoices/failed page loads
3. Status filter changes displayed attempts
4. Retry button triggers POST to API
</verification>

<success_criteria>
- Failed invoices page shows all pending failures
- Retry button successfully re-attempts invoice generation
- User can filter by status (pending, resolved, all)
- Phase 2 success criteria met: invoices use correct series automatically
</success_criteria>

<output>
After completion, create `.planning/phases/02-invoice-series-fix/02-05-SUMMARY.md`
</output>
