# Phase 7.10: Courier Manifest & Invoice Reconciliation - Research

**Researched:** 2026-02-07
**Domain:** Courier manifest processing, bulk invoice operations, PIN-based approval workflows
**Confidence:** HIGH

## Summary

This phase implements an automated workflow for courier manifest processing with two main paths: (1) return manifest verification triggering bulk invoice cancellation (stornare) in Oblio, and (2) delivery manifest processing to automatically mark invoices as paid (incasate). The phase also includes a stuck shipments report, PIN-based exception approval, and a returns page pagination fix.

The existing codebase already contains:
- **Oblio integration** (`src/lib/oblio.ts`) with `cancelInvoice()` and full OAuth 2.0 auth - ready for use
- **FanCourier integration** (`src/lib/fancourier.ts`) with `/reports/awb` endpoint that can fetch AWBs by date
- **Returns scanning** (`src/lib/returns.ts`) with `ReturnAWB` model and warehouse scanning workflow
- **AWB status categorization** (`src/lib/awb-status.ts`) with return status detection
- **Audit logging** (`AuditLog` model) for compliance tracking
- **bcryptjs** for password hashing (existing in auth.ts)

**Primary recommendation:** Extend existing integrations rather than building new ones. Use the existing `/reports/awb` FanCourier endpoint for delivery manifest fetching, extend Oblio client with a `collectInvoice()` method for payment marking, and add PIN hash storage to the existing Settings model.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Daily workflow: Retururi scanare -> Raport -> Verificare Office -> Stornare bulk
- Daily workflow: Borderou livrari -> Procesare automata -> Facturi incasate
- Daily report: Colete >3 zile fara rezolutie
- Restrictii: No manual stornare/incasare without manifest presence (except PIN approval)
- PIN stored as bcrypt hash in Settings table
- 6-digit PIN with 5-minute session expiry
- FanCourier as default carrier
- Oblio as invoicing provider (OAuth 2.0 with email + token)
- Fire-and-forget notification pattern (.catch() error handling, non-blocking)
- Database models: CourierManifest, ManifestItem, PINApprovalRequest as defined in CONTEXT.md

### Claude's Discretion
- UI component structure and styling
- API route organization within the established patterns
- Error handling and retry strategies
- Caching strategies for manifest data
- Manifest storage duration and cleanup policies

### Deferred Ideas (OUT OF SCOPE)
- Multi-courier support beyond FanCourier
- Automated dispute resolution
- Integration with courier's real-time webhook notifications
- Historical manifest analytics/reporting beyond stuck shipments
</user_constraints>

## Standard Stack

The established libraries/tools for this domain:

### Core (Already in Codebase)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| bcryptjs | ^2.4.3 | PIN hashing | Already used for user passwords in auth.ts |
| Prisma | ^5.x | Database ORM | Already used throughout codebase |
| @tanstack/react-query | ^5.x | Server state | Already used for data fetching |
| date-fns | ^2.x | Date manipulation | Already used for date formatting |

### Supporting (Existing Integrations)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| OblioAPI class | - | Invoice operations | cancelInvoice(), collectInvoice() |
| FanCourierAPI class | - | AWB reports | getAllAWBsForDate(), trackAWB() |
| Notification system | - | Office alerts | Phase 7.9 established patterns |

### No New Dependencies Needed
All required functionality can be achieved with existing libraries.

## Architecture Patterns

### Recommended Project Structure
```
src/
├── app/api/
│   ├── manifests/
│   │   ├── route.ts              # GET list, POST create manifest
│   │   └── [id]/
│   │       ├── route.ts          # GET/PATCH manifest details
│   │       ├── confirm/route.ts  # POST confirm manifest
│   │       └── process/route.ts  # POST process (bulk stornare/incasare)
│   ├── returns/
│   │   └── manifest/route.ts     # Generate return manifest from scanned AWBs
│   ├── reports/
│   │   └── stuck-shipments/route.ts
│   └── pin/
│       ├── verify/route.ts       # POST verify PIN
│       └── request/route.ts      # POST create approval request
├── app/(dashboard)/
│   ├── returns/
│   │   └── manifest/page.tsx     # Return manifest generation/verification
│   ├── reports/
│   │   └── stuck-shipments/page.tsx
│   └── settings/
│       └── security/page.tsx     # PIN configuration
├── lib/
│   ├── manifest/
│   │   ├── return-manifest.ts    # Return manifest business logic
│   │   ├── delivery-manifest.ts  # Delivery manifest business logic
│   │   └── stuck-shipments.ts    # Stuck shipments query logic
│   └── pin/
│       └── pin-service.ts        # PIN hashing, verification, session
└── components/
    ├── manifest/
    │   ├── ManifestTable.tsx
    │   └── ManifestConfirmDialog.tsx
    └── pin/
        └── PINApprovalDialog.tsx
```

### Pattern 1: Manifest Processing Workflow
**What:** State machine for manifest lifecycle: DRAFT -> PENDING_VERIFICATION -> CONFIRMED -> PROCESSED
**When to use:** All manifest operations must follow this state progression

```typescript
// Source: Existing pattern from codebase
async function processReturnManifest(manifestId: string, userId: string) {
  const manifest = await prisma.courierManifest.findUnique({
    where: { id: manifestId },
    include: { items: { include: { invoice: true } } }
  });

  if (manifest.status !== 'CONFIRMED') {
    throw new Error('Manifest must be CONFIRMED before processing');
  }

  const results = { success: 0, failed: 0, errors: [] };

  for (const item of manifest.items) {
    if (!item.invoice) continue;

    try {
      const oblioClient = createOblioClient(/* company */);
      const result = await oblioClient.cancelInvoice(
        item.invoice.invoiceSeriesName,
        item.invoice.invoiceNumber
      );

      if (result.success) {
        await prisma.manifestItem.update({
          where: { id: item.id },
          data: { status: 'PROCESSED', processedAt: new Date() }
        });
        results.success++;
      } else {
        await prisma.manifestItem.update({
          where: { id: item.id },
          data: { status: 'ERROR', errorMessage: result.error }
        });
        results.failed++;
        results.errors.push({ itemId: item.id, error: result.error });
      }
    } catch (error) {
      // Log and continue - don't fail entire batch
      results.failed++;
    }
  }

  await prisma.courierManifest.update({
    where: { id: manifestId },
    data: { status: 'PROCESSED' }
  });

  return results;
}
```

### Pattern 2: PIN Verification with Session
**What:** Stateless PIN verification that returns a time-limited session token
**When to use:** Any exception operation (manual stornare/incasare without manifest)

```typescript
// Source: Based on existing bcrypt usage in auth.ts
import bcrypt from 'bcryptjs';

const PIN_SESSION_DURATION_MS = 5 * 60 * 1000; // 5 minutes

interface PINSession {
  valid: boolean;
  expiresAt: Date;
  sessionToken?: string;
}

async function verifyPIN(enteredPIN: string): Promise<PINSession> {
  const settings = await prisma.settings.findUnique({
    where: { id: 'default' }
  });

  if (!settings?.pinHash) {
    return { valid: false, expiresAt: new Date() };
  }

  const isValid = await bcrypt.compare(enteredPIN, settings.pinHash);

  if (!isValid) {
    // Log failed attempt for security audit
    await prisma.auditLog.create({
      data: {
        action: 'pin.failed_attempt',
        entityType: 'Settings',
        metadata: { timestamp: new Date().toISOString() }
      }
    });
    return { valid: false, expiresAt: new Date() };
  }

  const expiresAt = new Date(Date.now() + PIN_SESSION_DURATION_MS);
  const sessionToken = crypto.randomUUID();

  return { valid: true, expiresAt, sessionToken };
}
```

### Pattern 3: Blocking Manual Operations
**What:** Middleware/hook pattern to intercept manual stornare/incasare operations
**When to use:** Invoice cancellation and payment marking UI actions

```typescript
// Source: Pattern based on existing permission checks
async function checkCanCancelInvoice(invoiceId: string): Promise<{
  allowed: boolean;
  reason?: string;
  requiresPIN?: boolean;
}> {
  const invoice = await prisma.invoice.findUnique({
    where: { id: invoiceId },
    include: {
      order: { include: { awb: true } }
    }
  });

  // Check if invoice exists in a confirmed return manifest
  const inReturnManifest = await prisma.manifestItem.findFirst({
    where: {
      invoiceId: invoiceId,
      manifest: {
        type: 'RETURN',
        status: { in: ['CONFIRMED', 'PROCESSED'] }
      }
    }
  });

  if (inReturnManifest) {
    return { allowed: true };
  }

  // Not in manifest - requires PIN approval
  return {
    allowed: false,
    reason: 'Invoice not found in confirmed return manifest',
    requiresPIN: true
  };
}
```

### Anti-Patterns to Avoid
- **Processing without state check:** Never process items directly - always verify manifest status first
- **Storing PIN in plaintext:** Always use bcrypt hash
- **Synchronous bulk operations:** Use parallel processing with individual error handling
- **Fire-and-forget for critical operations:** Unlike notifications, manifest processing must track success/failure

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| PIN hashing | Custom hash function | bcryptjs | Already in codebase, cryptographically secure |
| Invoice cancellation | Direct API calls | OblioAPI.cancelInvoice() | Method exists at line 460 of oblio.ts |
| AWB date listing | Custom FanCourier calls | FanCourierAPI.getAllAWBsForDate() | Method exists at line 604 of fancourier.ts |
| Return status detection | String matching | getStatusCategory() from awb-status.ts | Comprehensive status mapping exists |
| Audit logging | Custom tables | AuditLog model | RBAC audit system exists |

**Key insight:** 90% of the infrastructure exists. The phase is primarily about connecting existing pieces with new workflow logic.

## Common Pitfalls

### Pitfall 1: Pagination Bug in Returns API
**What goes wrong:** Returns API defaults to `limit: 100` without pagination support
**Why it happens:** The `/api/returns` route.ts line 27-28 sets a hard limit with no offset parameter
**How to avoid:** Add cursor-based or offset-based pagination to the API
**Warning signs:** Users report "only 100 items showing"

```typescript
// Current (problematic)
const limit = searchParams.get("limit") ? parseInt(searchParams.get("limit")!) : 100;

// Fixed
const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 100);
const offset = parseInt(searchParams.get("offset") || "0");
// Add skip: offset to Prisma query
```

### Pitfall 2: Bulk Operation Partial Failure
**What goes wrong:** Entire batch fails if one invoice cancellation fails
**Why it happens:** Not wrapping individual operations in try/catch
**How to avoid:** Process each item independently, collect results, report partial success
**Warning signs:** Users report "all invoices failed" when only one had an issue

### Pitfall 3: Race Condition in Manifest Confirmation
**What goes wrong:** Multiple users confirm the same manifest simultaneously
**Why it happens:** No optimistic locking or status check before update
**How to avoid:** Use Prisma's `updateMany` with status condition, or add version field
**Warning signs:** Manifest processed multiple times, duplicate stornare

### Pitfall 4: PIN Session Not Invalidated
**What goes wrong:** PIN session reused beyond intended operation
**Why it happens:** Session stored client-side without server validation
**How to avoid:** Store session server-side with operation binding, delete after use
**Warning signs:** Users performing multiple exceptions with single PIN entry

### Pitfall 5: Missing Audit Trail for PIN Operations
**What goes wrong:** Compliance fails due to incomplete logging
**Why it happens:** Forgetting to create AuditLog entries for exception approvals
**How to avoid:** Create audit log atomically with the PIN-approved operation
**Warning signs:** Auditor asks "who approved this manual stornare?"

## Code Examples

Verified patterns from existing codebase:

### Oblio Invoice Cancellation
```typescript
// Source: src/lib/oblio.ts lines 459-478
async cancelInvoice(
  seriesName: string,
  number: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await this.request<any>("PUT", "/docs/invoice/cancel", {
      cif: this.credentials.cif,
      seriesName,
      number,
    });
    return { success: true };
  } catch (error: any) {
    return {
      success: false,
      error: error.message,
    };
  }
}
```

### Oblio Payment Marking (To Be Added)
```typescript
// Source: Based on official Oblio API docs (oblio.eu/api)
async collectInvoice(
  seriesName: string,
  number: string,
  collectType: string = "Ramburs",
  collectDate?: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await this.request<any>("PUT", "/docs/invoice/collect", {
      cif: this.credentials.cif,
      seriesName,
      number,
      collect: {
        type: collectType,
        issueDate: collectDate || formatDateForOblio(new Date()),
      },
    });
    return { success: true };
  } catch (error: any) {
    return {
      success: false,
      error: error.message,
    };
  }
}
```

### FanCourier AWB List by Date
```typescript
// Source: src/lib/fancourier.ts lines 604-646
async getAllAWBsForDate(date: string): Promise<{
  success: boolean;
  data?: any[];
  error?: string;
}> {
  try {
    const allData: any[] = [];
    let page = 1;
    let hasMore = true;

    while (hasMore) {
      const response = await this.authRequest("GET", "/reports/awb", null, {
        clientId: this.clientId,
        date: date,
        perPage: 100,
        page: page,
      });

      if (response.data.status === "success" && response.data.data) {
        allData.push(...response.data.data);
        hasMore = response.data.data.length === 100;
        page++;
      } else {
        hasMore = false;
      }
    }

    return { success: true, data: allData };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}
```

### bcrypt Password Hashing
```typescript
// Source: src/lib/auth.ts lines 5, 193
import bcrypt from "bcryptjs";

// Hash PIN before storing
const pinHash = await bcrypt.hash(pin, 10);

// Verify PIN
const isValid = await bcrypt.compare(enteredPIN, storedHash);
```

### Return Status Detection
```typescript
// Source: src/lib/returns.ts lines 90-100
const isReturnStatus = [
  "returned",
  "S6",   // Refuz primire
  "S7",   // Refuz plata transport
  "S15",  // Refuz predare ramburs
  "S16",  // Retur la termen
  "S33",  // Retur solicitat
  "S43",  // Retur
].some((s) =>
  directMatch.currentStatus?.toLowerCase().includes(s.toLowerCase())
);
```

### Notification Pattern (Fire-and-Forget)
```typescript
// Source: Phase 7.9 established pattern
import { createNotification, NotificationType } from "@/lib/notifications";

// Non-blocking notification
createNotification({
  type: NotificationType.MANIFEST_READY,
  userId: officeUserId,
  title: "Manifest retururi gata de verificare",
  message: `${manifest.items.length} AWB-uri de verificat`,
  actionUrl: `/returns/manifest/${manifest.id}`
}).catch(console.error);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Facturis integration | Oblio integration | Phase 7.x | OAuth 2.0 auth, different API structure |
| Manual AWB status checks | FANCOURIER_STATUSES lookup | Phase 7.5 | Reliable code-based categorization |
| Simple user passwords | bcryptjs hashing | Initial auth setup | Secure password/PIN storage |

**Deprecated/outdated:**
- Facturis: Completely replaced by Oblio - do not use Facturis patterns

## API Integration Details

### FanCourier API - Delivery Manifest

Based on existing `getAllAWBsForDate()` method at line 604:

**Endpoint:** `GET /reports/awb`
**Parameters:**
- `clientId`: Company client ID
- `date`: Date in YYYY-MM-DD format
- `perPage`: Max 100 per page
- `page`: Page number

**Response:** AWB list with delivery status information

**Note:** There is no dedicated "delivery manifest" endpoint. Use the existing `/reports/awb` endpoint and filter by status (S2 = delivered) for delivered AWBs.

### Oblio API - Invoice Operations

**Cancel Invoice (Stornare):**
- Endpoint: `PUT /api/docs/invoice/cancel`
- Already implemented in `OblioAPI.cancelInvoice()`

**Mark as Paid (Incasare):**
- Endpoint: `PUT /api/docs/invoice/collect`
- Parameters: `cif`, `seriesName`, `number`, `collect` object
- `collect.type`: "Ramburs" for COD payments, "Ordin de plata" for bank transfer
- Needs to be added to OblioAPI class

### FanCourier API - Manual Manifest Upload Fallback

If FanCourier API doesn't provide filtered manifest by status, implement CSV/Excel upload:
- Office downloads borderou from FanCourier portal
- Uploads CSV to ERP
- ERP parses and creates ManifestItems

## Database Schema Extensions

### Settings Model Extension
```prisma
model Settings {
  // ... existing fields

  // PIN for exception approvals (bcrypt hash)
  pinHash String?

  // Last PIN change timestamp
  pinChangedAt DateTime?
}
```

### New Models (from CONTEXT.md)
```prisma
model CourierManifest {
  id            String          @id @default(cuid())
  type          ManifestType    // RETURN, DELIVERY
  status        ManifestStatus  // DRAFT, PENDING_VERIFICATION, CONFIRMED, PROCESSED
  documentDate  DateTime
  courierRef    String?
  createdAt     DateTime        @default(now())
  confirmedAt   DateTime?
  confirmedById String?
  confirmedBy   User?           @relation(fields: [confirmedById], references: [id])
  items         ManifestItem[]

  @@map("courier_manifests")
}

model ManifestItem {
  id              String          @id @default(cuid())
  manifestId      String
  manifest        CourierManifest @relation(fields: [manifestId], references: [id])
  awbNumber       String
  originalAwb     String?         // For returns: original outbound AWB
  invoiceId       String?
  invoice         Invoice?        @relation(fields: [invoiceId], references: [id])
  processedAt     DateTime?
  status          String          @default("PENDING") // PENDING, PROCESSED, ERROR
  errorMessage    String?

  @@index([manifestId])
  @@index([invoiceId])
  @@map("manifest_items")
}

model PINApprovalRequest {
  id            String   @id @default(cuid())
  type          String   // STORNARE, INCASARE
  status        String   @default("PENDING") // PENDING, APPROVED, REJECTED, EXPIRED
  invoiceId     String
  requestedById String
  reason        String?
  createdAt     DateTime @default(now())
  expiresAt     DateTime // 5 min from creation
  resolvedAt    DateTime?

  @@index([status])
  @@index([invoiceId])
  @@map("pin_approval_requests")
}
```

### Invoice Model Extension
```prisma
model Invoice {
  // ... existing fields

  // Source tracking for cancellations
  cancellationSource String? // "manifest_return" | "pin_approval"

  // Source tracking for payments
  paymentSource String? // "manifest_delivery" | "pin_approval"

  // Manifest relations
  manifestItems ManifestItem[]
}
```

## Open Questions

Things that couldn't be fully resolved:

1. **FanCourier Manifest Filtering by Status**
   - What we know: `/reports/awb` endpoint returns all AWBs for a date
   - What's unclear: Whether there's a status filter parameter (documentation PDF was too large to fetch)
   - Recommendation: Use existing `getAllAWBsForDate()` and filter client-side by S2 status for deliveries

2. **Oblio Credit Note vs Cancel**
   - What we know: `cancelInvoice()` marks document as cancelled
   - What's unclear: Whether a separate storno/credit note document is created automatically
   - Recommendation: Test with Oblio API - the response includes a link to the cancelled document

3. **Returns Page Pagination Root Cause**
   - What we know: API defaults to limit 100, no offset parameter
   - What's unclear: Whether the issue is API-only or also UI pagination component
   - Recommendation: Add offset parameter to API and verify UI passes pagination params

## Sources

### Primary (HIGH confidence)
- `src/lib/oblio.ts` - Existing Oblio integration with cancelInvoice()
- `src/lib/fancourier.ts` - Existing FanCourier integration with getAllAWBsForDate()
- `src/lib/auth.ts` - bcryptjs usage pattern
- `src/lib/returns.ts` - Return scanning business logic
- `src/lib/awb-status.ts` - Status categorization logic
- `prisma/schema.prisma` - Existing data models
- [Oblio API Documentation](https://www.oblio.eu/api) - Cancel and collect endpoints

### Secondary (MEDIUM confidence)
- [FanCourier API Documentation](https://www.fancourier.ro/wp-content/uploads/2025/09/EN_FANCourier_API_130825-1.pdf) - Borderou endpoints (page 37)
- CONTEXT.md for Phase 7.10 - User-defined workflows and requirements

### Tertiary (LOW confidence)
- Web search results for FanCourier manifest API specifics - need to verify against official PDF

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in codebase
- Architecture: HIGH - Patterns follow existing codebase conventions
- API integrations: MEDIUM - Oblio verified, FanCourier partially (docs too large)
- Pitfalls: HIGH - Based on actual code analysis

**Research date:** 2026-02-07
**Valid until:** 2026-03-07 (30 days - stable domain)
