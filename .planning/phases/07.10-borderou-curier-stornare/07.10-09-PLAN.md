---
phase: 07.10-borderou-curier-stornare
plan: 09
type: execute
wave: 4
depends_on: ["07.10-01", "07.10-02", "07.10-04", "07.10-06", "07.10-07"]
files_modified:
  - src/lib/manifest/operation-guard.ts
  - src/app/api/invoices/[id]/cancel/route.ts
  - src/app/api/invoices/[id]/collect/route.ts
  - src/components/invoice/InvoiceActionGuard.tsx
  - src/components/pin/PINDialog.tsx
autonomous: true

must_haves:
  truths:
    - "Manual invoice cancellation blocked unless in return manifest or PIN approved"
    - "Manual payment marking blocked unless in delivery manifest or PIN approved"
    - "PIN dialog appears when operation is blocked"
    - "Operations with PIN approval are logged in audit trail"
  artifacts:
    - path: "src/lib/manifest/operation-guard.ts"
      provides: "Check functions for manifest presence and PIN requirements"
      exports: ["canCancelInvoice", "canMarkInvoicePaid"]
    - path: "src/app/api/invoices/[id]/cancel/route.ts"
      provides: "POST endpoint for manual invoice cancellation with guard"
      exports: ["POST"]
    - path: "src/app/api/invoices/[id]/collect/route.ts"
      provides: "POST endpoint for manual payment marking with guard"
      exports: ["POST"]
    - path: "src/components/pin/PINDialog.tsx"
      provides: "Reusable PIN input dialog component"
      min_lines: 80
  key_links:
    - from: "src/app/api/invoices/[id]/cancel/route.ts"
      to: "src/lib/manifest/operation-guard.ts"
      via: "canCancelInvoice"
      pattern: "canCancelInvoice"
    - from: "src/components/invoice/InvoiceActionGuard.tsx"
      to: "src/components/pin/PINDialog.tsx"
      via: "PIN dialog import"
      pattern: "PINDialog"
---

<objective>
Implement manual operation blocking: prevent manual stornare/incasare unless invoice exists in appropriate manifest, or user provides valid PIN approval.

Purpose: Enforce manifest-based workflow while allowing emergency exceptions with proper authorization.
Output: Operation guard service, API endpoints with guards, and PIN dialog component.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.10-borderou-curier-stornare/07.10-RESEARCH.md
@src/lib/pin-service.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create operation guard service</name>
  <files>src/lib/manifest/operation-guard.ts</files>
  <action>
Create src/lib/manifest/operation-guard.ts:

```typescript
/**
 * Operation Guard Service
 *
 * Checks whether manual invoice operations (cancel/mark paid) are allowed.
 * Operations are blocked unless:
 * 1. Invoice exists in appropriate manifest (return manifest for cancel, delivery manifest for payment)
 * 2. User provides valid PIN approval
 *
 * This enforces the manifest-based workflow while allowing authorized exceptions.
 */

import prisma from "../db";
import { ManifestType, ManifestStatus, PINApprovalStatus, PINApprovalType, CancellationSource, PaymentSource } from "@prisma/client";
import { verifyPIN } from "../pin-service";

export interface OperationCheckResult {
  allowed: boolean;
  reason?: string;
  requiresPIN: boolean;
  manifestId?: string;
  manifestType?: ManifestType;
}

/**
 * Check if an invoice can be manually cancelled
 *
 * Allowed if:
 * - Invoice is in a CONFIRMED or PROCESSED return manifest
 * - OR user provides valid PIN
 */
export async function canCancelInvoice(invoiceId: string): Promise<OperationCheckResult> {
  // Check if invoice exists in a return manifest
  const manifestItem = await prisma.manifestItem.findFirst({
    where: {
      invoiceId,
      manifest: {
        type: ManifestType.RETURN,
        status: { in: [ManifestStatus.CONFIRMED, ManifestStatus.PROCESSED] }
      }
    },
    include: {
      manifest: true
    }
  });

  if (manifestItem) {
    return {
      allowed: true,
      requiresPIN: false,
      manifestId: manifestItem.manifestId,
      manifestType: ManifestType.RETURN
    };
  }

  // Not in manifest - requires PIN
  return {
    allowed: false,
    reason: "Factura nu exista intr-un manifest de retururi confirmat",
    requiresPIN: true
  };
}

/**
 * Check if an invoice can be manually marked as paid
 *
 * Allowed if:
 * - Invoice is in a CONFIRMED or PROCESSED delivery manifest
 * - OR user provides valid PIN
 */
export async function canMarkInvoicePaid(invoiceId: string): Promise<OperationCheckResult> {
  // Check if invoice exists in a delivery manifest
  const manifestItem = await prisma.manifestItem.findFirst({
    where: {
      invoiceId,
      manifest: {
        type: ManifestType.DELIVERY,
        status: { in: [ManifestStatus.CONFIRMED, ManifestStatus.PROCESSED] }
      }
    },
    include: {
      manifest: true
    }
  });

  if (manifestItem) {
    return {
      allowed: true,
      requiresPIN: false,
      manifestId: manifestItem.manifestId,
      manifestType: ManifestType.DELIVERY
    };
  }

  // Not in manifest - requires PIN
  return {
    allowed: false,
    reason: "Factura nu exista intr-un manifest de livrari confirmat",
    requiresPIN: true
  };
}

/**
 * Execute operation with PIN override
 * Creates audit trail and returns success/failure
 */
export async function executeWithPINApproval(
  invoiceId: string,
  operationType: PINApprovalType,
  pin: string,
  userId: string,
  reason: string
): Promise<{ success: boolean; error?: string }> {
  // Verify PIN
  const pinResult = await verifyPIN(pin, userId);

  if (!pinResult.valid) {
    return { success: false, error: pinResult.error || "PIN invalid" };
  }

  // Create approval request record
  const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes

  await prisma.pINApprovalRequest.create({
    data: {
      type: operationType,
      status: PINApprovalStatus.APPROVED,
      invoiceId,
      requestedById: userId,
      reason,
      expiresAt,
      resolvedAt: new Date(),
      resolvedById: userId
    }
  });

  // Log the approval
  await prisma.auditLog.create({
    data: {
      userId,
      action: operationType === PINApprovalType.STORNARE
        ? "invoice.cancel_manual_approved"
        : "invoice.payment_manual_approved",
      entityType: "Invoice",
      entityId: invoiceId,
      metadata: {
        reason,
        approvedAt: new Date().toISOString(),
        source: "pin_approval"
      }
    }
  });

  return { success: true };
}

/**
 * Check the combined status of an invoice for all operations
 */
export async function getInvoiceOperationStatus(invoiceId: string): Promise<{
  canCancel: OperationCheckResult;
  canMarkPaid: OperationCheckResult;
  invoice: {
    status: string;
    paymentStatus: string;
    cancelledAt: Date | null;
    paidAt: Date | null;
  } | null;
}> {
  const invoice = await prisma.invoice.findUnique({
    where: { id: invoiceId },
    select: {
      status: true,
      paymentStatus: true,
      cancelledAt: true,
      paidAt: true
    }
  });

  const [canCancel, canMarkPaid] = await Promise.all([
    canCancelInvoice(invoiceId),
    canMarkInvoicePaid(invoiceId)
  ]);

  return {
    canCancel,
    canMarkPaid,
    invoice
  };
}
```
  </action>
  <verify>File exports canCancelInvoice, canMarkInvoicePaid, executeWithPINApproval</verify>
  <done>Operation guard service created with manifest checking and PIN approval</done>
</task>

<task type="auto">
  <name>Task 2: Create guarded invoice API endpoints</name>
  <files>
    src/app/api/invoices/[id]/cancel/route.ts
    src/app/api/invoices/[id]/collect/route.ts
  </files>
  <action>
Create src/app/api/invoices/[id]/cancel/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { canCancelInvoice, executeWithPINApproval } from "@/lib/manifest/operation-guard";
import { createOblioClient } from "@/lib/oblio";
import prisma from "@/lib/db";
import { CancellationSource, PINApprovalType } from "@prisma/client";

/**
 * POST /api/invoices/[id]/cancel
 * Cancel an invoice (stornare) with manifest/PIN guard
 *
 * Body: { pin?: string, reason?: string }
 * If invoice not in manifest, requires PIN approval
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canCancel = await hasPermission(session.user.id, "invoices.cancel");
    if (!canCancel) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a storna facturi" },
        { status: 403 }
      );
    }

    const { id } = await params;
    const body = await request.json().catch(() => ({}));
    const { pin, reason } = body;

    // Get invoice with company
    const invoice = await prisma.invoice.findUnique({
      where: { id },
      include: { company: true }
    });

    if (!invoice) {
      return NextResponse.json(
        { error: "Factura nu a fost gasita" },
        { status: 404 }
      );
    }

    if (invoice.status === "cancelled" || invoice.cancelledAt) {
      return NextResponse.json(
        { error: "Factura este deja stornata" },
        { status: 400 }
      );
    }

    // Check if operation is allowed
    const check = await canCancelInvoice(id);

    if (!check.allowed && check.requiresPIN) {
      // Not in manifest - require PIN
      if (!pin) {
        return NextResponse.json(
          {
            success: false,
            blocked: true,
            reason: check.reason,
            requiresPIN: true
          },
          { status: 403 }
        );
      }

      // Verify PIN
      const pinResult = await executeWithPINApproval(
        id,
        PINApprovalType.STORNARE,
        pin,
        session.user.id,
        reason || "Stornare manuala fara manifest"
      );

      if (!pinResult.success) {
        return NextResponse.json(
          { success: false, error: pinResult.error },
          { status: 400 }
        );
      }
    }

    // Proceed with cancellation
    if (!invoice.company) {
      return NextResponse.json(
        { error: "Factura nu are o firma asociata" },
        { status: 400 }
      );
    }

    const oblioClient = createOblioClient(invoice.company);
    if (!oblioClient) {
      return NextResponse.json(
        { error: "Credentiale Oblio neconfigurate" },
        { status: 400 }
      );
    }

    const cancelResult = await oblioClient.cancelInvoice(
      invoice.invoiceSeriesName || "",
      invoice.invoiceNumber || ""
    );

    if (!cancelResult.success) {
      return NextResponse.json(
        { success: false, error: cancelResult.error },
        { status: 400 }
      );
    }

    // Update invoice
    const source = check.allowed
      ? CancellationSource.MANIFEST_RETURN
      : CancellationSource.PIN_APPROVAL;

    await prisma.invoice.update({
      where: { id },
      data: {
        status: "cancelled",
        cancelledAt: new Date(),
        cancelReason: reason || (check.allowed ? "Return manifest" : "PIN approval"),
        cancellationSource: source,
        cancelledFromManifestId: check.manifestId || null
      }
    });

    // Audit log
    await prisma.auditLog.create({
      data: {
        userId: session.user.id,
        action: "invoice.cancelled",
        entityType: "Invoice",
        entityId: id,
        metadata: {
          invoiceNumber: invoice.invoiceNumber,
          invoiceSeries: invoice.invoiceSeriesName,
          source,
          reason,
          manifestId: check.manifestId || null
        }
      }
    });

    return NextResponse.json({ success: true, source });
  } catch (error: any) {
    console.error("Error in POST /api/invoices/[id]/cancel:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

Create src/app/api/invoices/[id]/collect/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { canMarkInvoicePaid, executeWithPINApproval } from "@/lib/manifest/operation-guard";
import { createOblioClient } from "@/lib/oblio";
import prisma from "@/lib/db";
import { PaymentSource, PINApprovalType } from "@prisma/client";

/**
 * POST /api/invoices/[id]/collect
 * Mark an invoice as paid with manifest/PIN guard
 *
 * Body: { pin?: string, reason?: string, collectType?: string }
 * If invoice not in manifest, requires PIN approval
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canEdit = await hasPermission(session.user.id, "invoices.edit");
    if (!canEdit) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a modifica facturi" },
        { status: 403 }
      );
    }

    const { id } = await params;
    const body = await request.json().catch(() => ({}));
    const { pin, reason, collectType = "Ramburs" } = body;

    // Get invoice with company and order
    const invoice = await prisma.invoice.findUnique({
      where: { id },
      include: {
        company: true,
        order: true
      }
    });

    if (!invoice) {
      return NextResponse.json(
        { error: "Factura nu a fost gasita" },
        { status: 404 }
      );
    }

    if (invoice.paymentStatus === "paid" || invoice.paidAt) {
      return NextResponse.json(
        { error: "Factura este deja incasata" },
        { status: 400 }
      );
    }

    if (invoice.status === "cancelled") {
      return NextResponse.json(
        { error: "Nu se poate incasa o factura stornata" },
        { status: 400 }
      );
    }

    // Check if operation is allowed
    const check = await canMarkInvoicePaid(id);

    if (!check.allowed && check.requiresPIN) {
      // Not in manifest - require PIN
      if (!pin) {
        return NextResponse.json(
          {
            success: false,
            blocked: true,
            reason: check.reason,
            requiresPIN: true
          },
          { status: 403 }
        );
      }

      // Verify PIN
      const pinResult = await executeWithPINApproval(
        id,
        PINApprovalType.INCASARE,
        pin,
        session.user.id,
        reason || "Incasare manuala fara manifest"
      );

      if (!pinResult.success) {
        return NextResponse.json(
          { success: false, error: pinResult.error },
          { status: 400 }
        );
      }
    }

    // Proceed with payment marking
    if (!invoice.company) {
      return NextResponse.json(
        { error: "Factura nu are o firma asociata" },
        { status: 400 }
      );
    }

    const oblioClient = createOblioClient(invoice.company);
    if (!oblioClient) {
      return NextResponse.json(
        { error: "Credentiale Oblio neconfigurate" },
        { status: 400 }
      );
    }

    const collectResult = await oblioClient.collectInvoice(
      invoice.invoiceSeriesName || "",
      invoice.invoiceNumber || "",
      collectType
    );

    if (!collectResult.success) {
      return NextResponse.json(
        { success: false, error: collectResult.error },
        { status: 400 }
      );
    }

    // Update invoice
    const source = check.allowed
      ? PaymentSource.MANIFEST_DELIVERY
      : PaymentSource.PIN_APPROVAL;

    const paidAmount = invoice.order?.totalPrice || 0;

    await prisma.invoice.update({
      where: { id },
      data: {
        paymentStatus: "paid",
        paidAt: new Date(),
        paidAmount,
        paymentSource: source,
        paidFromManifestId: check.manifestId || null
      }
    });

    // Audit log
    await prisma.auditLog.create({
      data: {
        userId: session.user.id,
        action: "invoice.paid",
        entityType: "Invoice",
        entityId: id,
        metadata: {
          invoiceNumber: invoice.invoiceNumber,
          invoiceSeries: invoice.invoiceSeriesName,
          source,
          reason,
          collectType,
          manifestId: check.manifestId || null
        }
      }
    });

    return NextResponse.json({ success: true, source });
  } catch (error: any) {
    console.error("Error in POST /api/invoices/[id]/collect:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- POST /api/invoices/[id]/cancel returns blocked:true if not in manifest and no PIN
- POST /api/invoices/[id]/collect returns blocked:true if not in manifest and no PIN
- Both endpoints accept PIN for override and create audit logs
  </verify>
  <done>Guarded invoice API endpoints created with manifest checking and PIN override</done>
</task>

<task type="auto">
  <name>Task 3: Create PIN dialog and action guard components</name>
  <files>
    src/components/pin/PINDialog.tsx
    src/components/invoice/InvoiceActionGuard.tsx
  </files>
  <action>
Create src/components/pin/PINDialog.tsx:

```typescript
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Lock, AlertTriangle } from "lucide-react";

interface PINDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (pin: string, reason: string) => Promise<void>;
  title: string;
  description: string;
  actionLabel?: string;
  isLoading?: boolean;
  error?: string | null;
}

export function PINDialog({
  open,
  onClose,
  onConfirm,
  title,
  description,
  actionLabel = "Confirma",
  isLoading = false,
  error = null
}: PINDialogProps) {
  const [pin, setPin] = useState("");
  const [reason, setReason] = useState("");

  const handleConfirm = async () => {
    if (pin.length !== 6) return;
    await onConfirm(pin, reason);
  };

  const handleClose = () => {
    setPin("");
    setReason("");
    onClose();
  };

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Lock className="h-5 w-5" />
            {title}
          </DialogTitle>
          <DialogDescription>{description}</DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <Alert variant="destructive" className="bg-yellow-50 border-yellow-200">
            <AlertTriangle className="h-4 w-4 text-yellow-600" />
            <AlertDescription className="text-yellow-800">
              Aceasta operatie necesita aprobare PIN deoarece nu exista in borderou.
            </AlertDescription>
          </Alert>

          <div className="space-y-2">
            <Label htmlFor="pin">PIN (6 cifre)</Label>
            <Input
              id="pin"
              type="password"
              maxLength={6}
              value={pin}
              onChange={(e) => setPin(e.target.value.replace(/\D/g, "").slice(0, 6))}
              placeholder="******"
              className="text-center text-lg tracking-widest"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="reason">Motiv (optional)</Label>
            <Textarea
              id="reason"
              value={reason}
              onChange={(e) => setReason(e.target.value)}
              placeholder="De ce este necesara aceasta operatie..."
              rows={2}
            />
          </div>

          {error && (
            <Alert variant="destructive">
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleClose} disabled={isLoading}>
            Anuleaza
          </Button>
          <Button
            onClick={handleConfirm}
            disabled={pin.length !== 6 || isLoading}
          >
            {isLoading ? "Se verifica..." : actionLabel}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

Create src/components/invoice/InvoiceActionGuard.tsx:

```typescript
"use client";

import { useState } from "react";
import { PINDialog } from "@/components/pin/PINDialog";
import { toast } from "sonner";

interface InvoiceActionGuardProps {
  invoiceId: string;
  action: "cancel" | "collect";
  onSuccess?: () => void;
  children: (props: { execute: () => void; isLoading: boolean }) => React.ReactNode;
}

export function InvoiceActionGuard({
  invoiceId,
  action,
  onSuccess,
  children
}: InvoiceActionGuardProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [showPINDialog, setShowPINDialog] = useState(false);
  const [pinError, setPinError] = useState<string | null>(null);

  const endpoint = action === "cancel"
    ? `/api/invoices/${invoiceId}/cancel`
    : `/api/invoices/${invoiceId}/collect`;

  const actionTitle = action === "cancel" ? "Stornare" : "Incasare";

  async function executeAction() {
    setIsLoading(true);
    setPinError(null);

    try {
      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({})
      });

      const data = await res.json();

      if (data.blocked && data.requiresPIN) {
        // Show PIN dialog
        setShowPINDialog(true);
        return;
      }

      if (!data.success) {
        toast.error(data.error || `Eroare la ${actionTitle.toLowerCase()}`);
        return;
      }

      toast.success(`${actionTitle} realizata cu succes`);
      onSuccess?.();
    } catch (err: any) {
      toast.error(err.message);
    } finally {
      setIsLoading(false);
    }
  }

  async function executeWithPIN(pin: string, reason: string) {
    setIsLoading(true);
    setPinError(null);

    try {
      const res = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ pin, reason })
      });

      const data = await res.json();

      if (!data.success) {
        setPinError(data.error || "PIN invalid");
        setIsLoading(false);
        return;
      }

      toast.success(`${actionTitle} realizata cu succes (aprobare PIN)`);
      setShowPINDialog(false);
      onSuccess?.();
    } catch (err: any) {
      setPinError(err.message);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <>
      {children({ execute: executeAction, isLoading })}

      <PINDialog
        open={showPINDialog}
        onClose={() => {
          setShowPINDialog(false);
          setPinError(null);
        }}
        onConfirm={executeWithPIN}
        title={`Aprobare ${actionTitle}`}
        description={
          action === "cancel"
            ? "Factura nu exista in manifestul de retururi. Introduceti PIN-ul pentru a storna manual."
            : "Factura nu exista in manifestul de livrari. Introduceti PIN-ul pentru a marca ca incasata manual."
        }
        actionLabel={actionTitle}
        isLoading={isLoading}
        error={pinError}
      />
    </>
  );
}
```
  </action>
  <verify>
- PINDialog shows 6-digit PIN input with reason field
- InvoiceActionGuard wrapper shows PIN dialog when operation is blocked
- Both components handle loading and error states
  </verify>
  <done>PIN dialog and invoice action guard components created for UI integration</done>
</task>

</tasks>

<verification>
1. canCancelInvoice returns requiresPIN:true if not in return manifest
2. canMarkInvoicePaid returns requiresPIN:true if not in delivery manifest
3. API endpoints return blocked:true with requiresPIN when guard fails
4. PIN dialog collects 6-digit PIN and optional reason
5. InvoiceActionGuard integrates with any invoice action button
6. Successful PIN approval creates PINApprovalRequest and AuditLog records
</verification>

<success_criteria>
- Manual invoice cancellation blocked unless in manifest or PIN approved
- Manual payment marking blocked unless in manifest or PIN approved
- PIN dialog appears when operation requires authorization
- All PIN-approved operations logged in audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/07.10-borderou-curier-stornare/07.10-09-SUMMARY.md`
</output>
