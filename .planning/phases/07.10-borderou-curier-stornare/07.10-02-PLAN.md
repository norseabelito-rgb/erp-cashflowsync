---
phase: 07.10-borderou-curier-stornare
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/pin-service.ts
  - src/app/api/pin/verify/route.ts
  - src/app/api/settings/pin/route.ts
  - src/app/(dashboard)/settings/security/page.tsx
  - src/lib/permissions.ts
autonomous: true

must_haves:
  truths:
    - "PIN can be set and changed by authorized users"
    - "PIN is stored as bcrypt hash (never plaintext)"
    - "PIN verification returns session token with 5-minute expiry"
    - "Failed PIN attempts are logged for security audit"
  artifacts:
    - path: "src/lib/pin-service.ts"
      provides: "PIN hashing, verification, session management"
      exports: ["hashPIN", "verifyPIN", "setPIN"]
    - path: "src/app/api/pin/verify/route.ts"
      provides: "POST endpoint for PIN verification"
      exports: ["POST"]
    - path: "src/app/api/settings/pin/route.ts"
      provides: "POST endpoint for setting PIN"
      exports: ["POST"]
    - path: "src/app/(dashboard)/settings/security/page.tsx"
      provides: "UI for PIN configuration"
      min_lines: 80
  key_links:
    - from: "src/app/api/pin/verify/route.ts"
      to: "src/lib/pin-service.ts"
      via: "verifyPIN import"
      pattern: "import.*verifyPIN.*pin-service"
    - from: "src/lib/pin-service.ts"
      to: "bcryptjs"
      via: "bcrypt import"
      pattern: "import.*bcrypt"
---

<objective>
Implement PIN security system for exception approvals: 6-digit PIN with bcrypt hashing, verification with 5-minute session, and settings UI.

Purpose: Enable secure exception workflow for manual stornare/incasare without manifest.
Output: PIN service with verify/set endpoints and settings security page.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.10-borderou-curier-stornare/07.10-RESEARCH.md
@src/lib/auth.ts (bcrypt usage pattern)
@src/lib/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PIN service with hashing and verification</name>
  <files>src/lib/pin-service.ts</files>
  <action>
Create src/lib/pin-service.ts with the following implementation:

```typescript
/**
 * PIN Service for Exception Approvals
 *
 * Handles PIN hashing, verification, and session management for manual
 * stornare/incasare operations that bypass manifest-based workflows.
 *
 * Security: PIN is stored as bcrypt hash, never plaintext.
 * Session: 5-minute expiry, one-time use for critical operations.
 */

import bcrypt from "bcryptjs";
import prisma from "./db";
import crypto from "crypto";

const PIN_SESSION_DURATION_MS = 5 * 60 * 1000; // 5 minutes
const BCRYPT_ROUNDS = 10;

export interface PINSession {
  valid: boolean;
  expiresAt: Date;
  sessionToken?: string;
  error?: string;
}

/**
 * Hash a 6-digit PIN for storage
 */
export async function hashPIN(pin: string): Promise<string> {
  if (!/^\d{6}$/.test(pin)) {
    throw new Error("PIN must be exactly 6 digits");
  }
  return bcrypt.hash(pin, BCRYPT_ROUNDS);
}

/**
 * Set or update the PIN in Settings
 * Requires: settings.security permission
 */
export async function setPIN(pin: string, userId: string): Promise<{
  success: boolean;
  error?: string;
}> {
  try {
    if (!/^\d{6}$/.test(pin)) {
      return { success: false, error: "PIN must be exactly 6 digits" };
    }

    const pinHash = await hashPIN(pin);

    await prisma.settings.upsert({
      where: { id: "default" },
      update: {
        pinHash,
        pinChangedAt: new Date()
      },
      create: {
        id: "default",
        pinHash,
        pinChangedAt: new Date()
      }
    });

    // Log PIN change for audit
    await prisma.auditLog.create({
      data: {
        userId,
        action: "pin.changed",
        entityType: "Settings",
        entityId: "default",
        metadata: {
          timestamp: new Date().toISOString(),
          action: "PIN updated"
        }
      }
    });

    return { success: true };
  } catch (error: any) {
    console.error("Error setting PIN:", error);
    return { success: false, error: error.message };
  }
}

/**
 * Verify a PIN and return a session token if valid
 * Session token has 5-minute expiry for one-time use
 */
export async function verifyPIN(
  enteredPIN: string,
  userId?: string
): Promise<PINSession> {
  try {
    const settings = await prisma.settings.findUnique({
      where: { id: "default" }
    });

    if (!settings?.pinHash) {
      return {
        valid: false,
        expiresAt: new Date(),
        error: "PIN not configured"
      };
    }

    const isValid = await bcrypt.compare(enteredPIN, settings.pinHash);

    if (!isValid) {
      // Log failed attempt for security audit
      await prisma.auditLog.create({
        data: {
          userId: userId || null,
          action: "pin.failed_attempt",
          entityType: "Settings",
          entityId: "default",
          metadata: {
            timestamp: new Date().toISOString(),
            reason: "Invalid PIN entered"
          }
        }
      });

      return {
        valid: false,
        expiresAt: new Date(),
        error: "Invalid PIN"
      };
    }

    // Generate session token
    const sessionToken = crypto.randomUUID();
    const expiresAt = new Date(Date.now() + PIN_SESSION_DURATION_MS);

    // Log successful verification
    await prisma.auditLog.create({
      data: {
        userId: userId || null,
        action: "pin.verified",
        entityType: "Settings",
        entityId: "default",
        metadata: {
          timestamp: new Date().toISOString(),
          sessionExpiresAt: expiresAt.toISOString()
        }
      }
    });

    return {
      valid: true,
      expiresAt,
      sessionToken
    };
  } catch (error: any) {
    console.error("Error verifying PIN:", error);
    return {
      valid: false,
      expiresAt: new Date(),
      error: error.message
    };
  }
}

/**
 * Check if PIN is configured in the system
 */
export async function isPINConfigured(): Promise<boolean> {
  const settings = await prisma.settings.findUnique({
    where: { id: "default" },
    select: { pinHash: true }
  });
  return !!settings?.pinHash;
}

/**
 * Validate session token format (UUID v4)
 * Note: This only validates format, not actual session validity
 * For a production system, consider storing sessions in database or Redis
 */
export function isValidSessionTokenFormat(token: string): boolean {
  const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidV4Regex.test(token);
}
```
  </action>
  <verify>File exists with hashPIN, verifyPIN, setPIN, isPINConfigured exports</verify>
  <done>PIN service created with bcrypt hashing, 5-minute session tokens, and audit logging</done>
</task>

<task type="auto">
  <name>Task 2: Create PIN verification and settings API endpoints</name>
  <files>
    src/app/api/pin/verify/route.ts
    src/app/api/settings/pin/route.ts
  </files>
  <action>
Create src/app/api/pin/verify/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { verifyPIN } from "@/lib/pin-service";

/**
 * POST /api/pin/verify
 * Verify PIN and return session token for exception operations
 *
 * Body: { pin: string }
 * Returns: { valid: boolean, expiresAt?: string, sessionToken?: string, error?: string }
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const body = await request.json();
    const { pin } = body;

    if (!pin || typeof pin !== "string") {
      return NextResponse.json(
        { valid: false, error: "PIN is required" },
        { status: 400 }
      );
    }

    const result = await verifyPIN(pin, session.user.id);

    if (!result.valid) {
      return NextResponse.json({
        valid: false,
        error: result.error || "Invalid PIN"
      });
    }

    return NextResponse.json({
      valid: true,
      expiresAt: result.expiresAt.toISOString(),
      sessionToken: result.sessionToken
    });
  } catch (error: any) {
    console.error("Error in POST /api/pin/verify:", error);
    return NextResponse.json(
      { valid: false, error: "Error verifying PIN" },
      { status: 500 }
    );
  }
}
```

Create src/app/api/settings/pin/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { setPIN, isPINConfigured, verifyPIN } from "@/lib/pin-service";

/**
 * GET /api/settings/pin
 * Check if PIN is configured
 */
export async function GET() {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    // Check permission
    const canManage = await hasPermission(session.user.id, "settings.security");
    if (!canManage) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a gestiona setarile de securitate" },
        { status: 403 }
      );
    }

    const configured = await isPINConfigured();

    return NextResponse.json({
      success: true,
      configured
    });
  } catch (error: any) {
    console.error("Error in GET /api/settings/pin:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

/**
 * POST /api/settings/pin
 * Set or change PIN
 *
 * Body: { newPin: string, currentPin?: string }
 * If PIN is already set, currentPin is required
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    // Check permission
    const canManage = await hasPermission(session.user.id, "settings.security");
    if (!canManage) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a gestiona setarile de securitate" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { newPin, currentPin } = body;

    if (!newPin || typeof newPin !== "string") {
      return NextResponse.json(
        { success: false, error: "New PIN is required" },
        { status: 400 }
      );
    }

    if (!/^\d{6}$/.test(newPin)) {
      return NextResponse.json(
        { success: false, error: "PIN must be exactly 6 digits" },
        { status: 400 }
      );
    }

    // Check if PIN is already configured
    const isConfigured = await isPINConfigured();

    if (isConfigured) {
      // Require current PIN to change
      if (!currentPin) {
        return NextResponse.json(
          { success: false, error: "Current PIN is required to change PIN" },
          { status: 400 }
        );
      }

      // Verify current PIN
      const verification = await verifyPIN(currentPin, session.user.id);
      if (!verification.valid) {
        return NextResponse.json(
          { success: false, error: "Current PIN is incorrect" },
          { status: 400 }
        );
      }
    }

    // Set new PIN
    const result = await setPIN(newPin, session.user.id);

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error },
        { status: 400 }
      );
    }

    return NextResponse.json({
      success: true,
      message: isConfigured ? "PIN changed successfully" : "PIN set successfully"
    });
  } catch (error: any) {
    console.error("Error in POST /api/settings/pin:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
Both API endpoints exist:
- GET/POST /api/settings/pin returns proper responses
- POST /api/pin/verify returns session token on valid PIN
  </verify>
  <done>PIN API endpoints created for verification and settings management</done>
</task>

<task type="auto">
  <name>Task 3: Add settings.security permission and create Security settings page</name>
  <files>
    src/lib/permissions.ts
    src/app/(dashboard)/settings/security/page.tsx
  </files>
  <action>
First, add 'settings.security' to src/lib/permissions.ts in the PERMISSIONS object (if not exists):

```typescript
// In the settings section of PERMISSIONS object
"settings.security": {
  code: "settings.security",
  name: "Manage Security Settings",
  description: "Can set and change PIN for exception approvals",
  category: "settings",
}
```

Then create src/app/(dashboard)/settings/security/page.tsx:

```typescript
"use client";

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { PageHeader } from "@/components/PageHeader";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Shield, Check, AlertTriangle, Eye, EyeOff } from "lucide-react";
import { toast } from "sonner";

export default function SecuritySettingsPage() {
  const { data: session } = useSession();
  const [isConfigured, setIsConfigured] = useState<boolean | null>(null);
  const [currentPin, setCurrentPin] = useState("");
  const [newPin, setNewPin] = useState("");
  const [confirmPin, setConfirmPin] = useState("");
  const [showCurrentPin, setShowCurrentPin] = useState(false);
  const [showNewPin, setShowNewPin] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    checkPINStatus();
  }, []);

  async function checkPINStatus() {
    try {
      const res = await fetch("/api/settings/pin");
      if (res.ok) {
        const data = await res.json();
        setIsConfigured(data.configured);
      }
    } catch (err) {
      console.error("Error checking PIN status:", err);
    }
  }

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setError(null);

    // Validate new PIN
    if (!/^\d{6}$/.test(newPin)) {
      setError("PIN must be exactly 6 digits");
      return;
    }

    if (newPin !== confirmPin) {
      setError("PIN confirmation does not match");
      return;
    }

    // If already configured, require current PIN
    if (isConfigured && !currentPin) {
      setError("Current PIN is required");
      return;
    }

    setIsLoading(true);

    try {
      const res = await fetch("/api/settings/pin", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          newPin,
          currentPin: isConfigured ? currentPin : undefined
        })
      });

      const data = await res.json();

      if (!data.success) {
        setError(data.error || "Failed to set PIN");
        return;
      }

      toast.success(isConfigured ? "PIN schimbat cu succes" : "PIN setat cu succes");

      // Reset form
      setCurrentPin("");
      setNewPin("");
      setConfirmPin("");
      setIsConfigured(true);
    } catch (err: any) {
      setError(err.message || "Error setting PIN");
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="container mx-auto py-6 space-y-6">
      <PageHeader
        title="Setari Securitate"
        description="Configurare PIN pentru aprobari exceptii"
      />

      <Card className="max-w-md">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Shield className="h-5 w-5" />
            PIN Aprobare Exceptii
          </CardTitle>
          <CardDescription>
            PIN-ul de 6 cifre este necesar pentru a aproba operatiuni manuale
            (stornare/incasare) care nu sunt bazate pe manifest curier.
          </CardDescription>
        </CardHeader>
        <CardContent>
          {isConfigured === null ? (
            <p className="text-sm text-muted-foreground">Loading...</p>
          ) : (
            <>
              <div className="mb-4">
                {isConfigured ? (
                  <Alert>
                    <Check className="h-4 w-4" />
                    <AlertDescription>
                      PIN configurat. Pentru a schimba, introduceti PIN-ul curent.
                    </AlertDescription>
                  </Alert>
                ) : (
                  <Alert variant="destructive">
                    <AlertTriangle className="h-4 w-4" />
                    <AlertDescription>
                      PIN nu este configurat. Setati un PIN pentru a activa aprobari exceptii.
                    </AlertDescription>
                  </Alert>
                )}
              </div>

              <form onSubmit={handleSubmit} className="space-y-4">
                {isConfigured && (
                  <div className="space-y-2">
                    <Label htmlFor="currentPin">PIN Curent</Label>
                    <div className="relative">
                      <Input
                        id="currentPin"
                        type={showCurrentPin ? "text" : "password"}
                        value={currentPin}
                        onChange={(e) => setCurrentPin(e.target.value.replace(/\D/g, "").slice(0, 6))}
                        maxLength={6}
                        placeholder="******"
                        className="pr-10"
                      />
                      <button
                        type="button"
                        onClick={() => setShowCurrentPin(!showCurrentPin)}
                        className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground"
                      >
                        {showCurrentPin ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                      </button>
                    </div>
                  </div>
                )}

                <div className="space-y-2">
                  <Label htmlFor="newPin">{isConfigured ? "PIN Nou" : "PIN"}</Label>
                  <div className="relative">
                    <Input
                      id="newPin"
                      type={showNewPin ? "text" : "password"}
                      value={newPin}
                      onChange={(e) => setNewPin(e.target.value.replace(/\D/g, "").slice(0, 6))}
                      maxLength={6}
                      placeholder="******"
                      className="pr-10"
                    />
                    <button
                      type="button"
                      onClick={() => setShowNewPin(!showNewPin)}
                      className="absolute right-3 top-1/2 -translate-y-1/2 text-muted-foreground"
                    >
                      {showNewPin ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                    </button>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    PIN trebuie sa contina exact 6 cifre
                  </p>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="confirmPin">Confirmare PIN</Label>
                  <Input
                    id="confirmPin"
                    type="password"
                    value={confirmPin}
                    onChange={(e) => setConfirmPin(e.target.value.replace(/\D/g, "").slice(0, 6))}
                    maxLength={6}
                    placeholder="******"
                  />
                </div>

                {error && (
                  <Alert variant="destructive">
                    <AlertTriangle className="h-4 w-4" />
                    <AlertDescription>{error}</AlertDescription>
                  </Alert>
                )}

                <Button type="submit" disabled={isLoading} className="w-full">
                  {isLoading
                    ? "Se salveaza..."
                    : isConfigured
                      ? "Schimba PIN"
                      : "Seteaza PIN"
                  }
                </Button>
              </form>
            </>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```
  </action>
  <verify>
- Security settings page renders at /settings/security
- PIN input only allows 6 digits
- Form requires current PIN when changing existing PIN
- Success message shows on PIN save
  </verify>
  <done>Security settings page created with PIN set/change functionality</done>
</task>

</tasks>

<verification>
1. `src/lib/pin-service.ts` exists with hashPIN, verifyPIN, setPIN exports
2. `src/app/api/pin/verify/route.ts` exists and returns session token
3. `src/app/api/settings/pin/route.ts` exists with GET and POST handlers
4. `src/app/(dashboard)/settings/security/page.tsx` exists with PIN form
5. bcrypt is used for PIN hashing (not plaintext storage)
6. Audit logs created for PIN changes and verification attempts
</verification>

<success_criteria>
- PIN can be set by users with settings.security permission
- PIN change requires current PIN verification
- PIN verification returns 5-minute session token
- Failed PIN attempts are logged in audit trail
- Security settings page accessible at /settings/security
</success_criteria>

<output>
After completion, create `.planning/phases/07.10-borderou-curier-stornare/07.10-02-SUMMARY.md`
</output>
