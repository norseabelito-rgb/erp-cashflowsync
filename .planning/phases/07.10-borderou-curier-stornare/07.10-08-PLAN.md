---
phase: 07.10-borderou-curier-stornare
plan: 08
type: execute
wave: 3
depends_on: ["07.10-01"]
files_modified:
  - src/lib/manifest/stuck-shipments.ts
  - src/app/api/reports/stuck-shipments/route.ts
  - src/app/(dashboard)/reports/stuck-shipments/page.tsx
autonomous: true

must_haves:
  truths:
    - "Stuck shipments report shows AWBs older than 3 days without resolution"
    - "Report includes order number, AWB, invoice series, customer phone"
    - "Report can be exported to CSV"
  artifacts:
    - path: "src/lib/manifest/stuck-shipments.ts"
      provides: "Stuck shipments query logic"
      exports: ["getStuckShipments"]
    - path: "src/app/api/reports/stuck-shipments/route.ts"
      provides: "GET endpoint for stuck shipments report"
      exports: ["GET"]
    - path: "src/app/(dashboard)/reports/stuck-shipments/page.tsx"
      provides: "Stuck shipments report UI with table and CSV export"
      min_lines: 100
  key_links:
    - from: "src/lib/manifest/stuck-shipments.ts"
      to: "prisma.aWB"
      via: "database query"
      pattern: "prisma\\.aWB\\.findMany"
---

<objective>
Implement stuck shipments report: AWBs older than 3 days that are neither delivered nor returned. Include order number, AWB, invoice series, and customer phone.

Purpose: Provide visibility into shipments that require manual intervention or follow-up.
Output: Stuck shipments API endpoint and report page with CSV export.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.10-borderou-curier-stornare/07.10-RESEARCH.md
@src/lib/awb-status.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stuck shipments query service</name>
  <files>src/lib/manifest/stuck-shipments.ts</files>
  <action>
Create src/lib/manifest/stuck-shipments.ts:

```typescript
/**
 * Stuck Shipments Service
 *
 * Identifies AWBs that are "stuck" - older than N days without resolution.
 * Resolution means: delivered (S2), returned (S6/S7/etc), or cancelled.
 *
 * Used for daily monitoring of shipments that need attention.
 */

import prisma from "../db";

// Status codes that indicate "resolved" (not stuck)
const RESOLVED_STATUS_CODES = [
  // Delivered
  "S2", "2", "livrat", "delivered",
  // Returned
  "S6", "S7", "S15", "S16", "S33", "S43",
  "refuz", "retur", "returned",
  // Cancelled
  "cancelled", "anulat"
];

export interface StuckShipment {
  id: string;
  awbNumber: string;
  orderNumber: string | null;
  shopifyOrderNumber: string | null;
  invoiceSeries: string | null;
  invoiceNumber: string | null;
  customerPhone: string | null;
  customerName: string | null;
  createdAt: Date;
  lastStatusUpdate: Date | null;
  currentStatus: string | null;
  statusCode: string | null;
  daysOld: number;
}

export interface StuckShipmentsResult {
  shipments: StuckShipment[];
  total: number;
  minDays: number;
}

/**
 * Get AWBs that are older than X days and not resolved
 *
 * @param minDays - Minimum age in days to be considered "stuck" (default: 3)
 * @param limit - Max results to return (default: 100)
 * @param offset - Offset for pagination (default: 0)
 */
export async function getStuckShipments({
  minDays = 3,
  limit = 100,
  offset = 0
}: {
  minDays?: number;
  limit?: number;
  offset?: number;
} = {}): Promise<StuckShipmentsResult> {
  // Calculate cutoff date
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - minDays);
  cutoffDate.setHours(0, 0, 0, 0);

  // Find AWBs older than cutoff that aren't resolved
  const awbs = await prisma.aWB.findMany({
    where: {
      createdAt: {
        lt: cutoffDate
      },
      // Not deleted
      deleted: false,
      // Has an AWB number (was successfully created)
      awbNumber: { not: null },
      // Invoice not cancelled
      order: {
        invoice: {
          OR: [
            { status: { not: "cancelled" } },
            { status: null }
          ]
        }
      }
    },
    include: {
      order: {
        include: {
          invoice: {
            select: {
              invoiceSeriesName: true,
              invoiceNumber: true,
              paymentStatus: true
            }
          }
        }
      }
    },
    orderBy: { createdAt: 'asc' },
    take: limit + 100, // Fetch extra to filter
    skip: offset
  });

  // Filter out resolved statuses
  const stuckAwbs = awbs.filter(awb => {
    const statusCode = awb.statusCode || awb.currentStatus || "";
    const isResolved = RESOLVED_STATUS_CODES.some(code =>
      statusCode.toLowerCase().includes(code.toLowerCase())
    );
    return !isResolved;
  });

  // Map to result format
  const shipments: StuckShipment[] = stuckAwbs.slice(0, limit).map(awb => {
    const order = awb.order;
    const billingAddress = order?.billingAddress as any || {};
    const shippingAddress = order?.shippingAddress as any || {};

    // Extract phone - try billing first, then shipping
    const phone = billingAddress?.phone || shippingAddress?.phone || null;
    const name = billingAddress?.name || shippingAddress?.name ||
                 `${billingAddress?.firstName || ""} ${billingAddress?.lastName || ""}`.trim() || null;

    // Calculate days since creation
    const daysOld = Math.floor(
      (Date.now() - new Date(awb.createdAt).getTime()) / (1000 * 60 * 60 * 24)
    );

    return {
      id: awb.id,
      awbNumber: awb.awbNumber || "",
      orderNumber: order?.orderNumber || null,
      shopifyOrderNumber: order?.shopifyOrderNumber || null,
      invoiceSeries: order?.invoice?.invoiceSeriesName || null,
      invoiceNumber: order?.invoice?.invoiceNumber || null,
      customerPhone: phone,
      customerName: name,
      createdAt: awb.createdAt,
      lastStatusUpdate: awb.lastStatusCheck || null,
      currentStatus: awb.currentStatus || null,
      statusCode: awb.statusCode || null,
      daysOld
    };
  });

  // Get total count
  const totalCount = await prisma.aWB.count({
    where: {
      createdAt: { lt: cutoffDate },
      deleted: false,
      awbNumber: { not: null }
    }
  });

  return {
    shipments,
    total: totalCount,
    minDays
  };
}

/**
 * Export stuck shipments to CSV format
 */
export function stuckShipmentsToCSV(shipments: StuckShipment[]): string {
  const headers = [
    "AWB",
    "Nr. Comanda",
    "Shopify Order",
    "Serie Factura",
    "Nr. Factura",
    "Telefon Client",
    "Nume Client",
    "Zile Vechi",
    "Status Curent",
    "Data Creare"
  ];

  const rows = shipments.map(s => [
    s.awbNumber,
    s.orderNumber || "",
    s.shopifyOrderNumber || "",
    s.invoiceSeries || "",
    s.invoiceNumber || "",
    s.customerPhone || "",
    s.customerName || "",
    s.daysOld.toString(),
    s.currentStatus || "",
    new Date(s.createdAt).toLocaleDateString("ro-RO")
  ]);

  // Escape CSV values
  const escape = (val: string) => {
    if (val.includes(",") || val.includes('"') || val.includes("\n")) {
      return `"${val.replace(/"/g, '""')}"`;
    }
    return val;
  };

  const csvRows = [
    headers.join(","),
    ...rows.map(row => row.map(escape).join(","))
  ];

  return csvRows.join("\n");
}
```
  </action>
  <verify>File exports getStuckShipments and stuckShipmentsToCSV functions</verify>
  <done>Stuck shipments query service created with resolved status filtering</done>
</task>

<task type="auto">
  <name>Task 2: Create stuck shipments API endpoint</name>
  <files>src/app/api/reports/stuck-shipments/route.ts</files>
  <action>
Create src/app/api/reports/stuck-shipments/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { getStuckShipments, stuckShipmentsToCSV } from "@/lib/manifest/stuck-shipments";

/**
 * GET /api/reports/stuck-shipments
 * Get stuck shipments report (AWBs >N days without resolution)
 *
 * Query params:
 * - minDays: Minimum days to be considered stuck (default: 3)
 * - limit: Max results (default: 100)
 * - offset: Pagination offset (default: 0)
 * - format: "json" (default) or "csv"
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    // Check permission for viewing reports
    const canView = await hasPermission(session.user.id, "tracking.view");
    if (!canView) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a vizualiza rapoartele" },
        { status: 403 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const minDays = parseInt(searchParams.get("minDays") || "3");
    const limit = parseInt(searchParams.get("limit") || "100");
    const offset = parseInt(searchParams.get("offset") || "0");
    const format = searchParams.get("format") || "json";

    const result = await getStuckShipments({ minDays, limit, offset });

    // CSV export
    if (format === "csv") {
      const csv = stuckShipmentsToCSV(result.shipments);
      const date = new Date().toISOString().split("T")[0];

      return new NextResponse(csv, {
        headers: {
          "Content-Type": "text/csv; charset=utf-8",
          "Content-Disposition": `attachment; filename="stuck-shipments-${date}.csv"`
        }
      });
    }

    // JSON response
    return NextResponse.json({
      success: true,
      data: {
        shipments: result.shipments,
        total: result.total,
        minDays: result.minDays,
        limit,
        offset
      }
    });
  } catch (error: any) {
    console.error("Error in GET /api/reports/stuck-shipments:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>GET /api/reports/stuck-shipments returns shipments list and supports CSV export</verify>
  <done>Stuck shipments API endpoint created with JSON and CSV format support</done>
</task>

<task type="auto">
  <name>Task 3: Create stuck shipments report page</name>
  <files>src/app/(dashboard)/reports/stuck-shipments/page.tsx</files>
  <action>
Create src/app/(dashboard)/reports/stuck-shipments/page.tsx:

```typescript
"use client";

import { useState, useEffect } from "react";
import { PageHeader } from "@/components/PageHeader";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { toast } from "sonner";
import {
  AlertTriangle,
  Download,
  RefreshCw,
  Phone,
  Clock,
  Package
} from "lucide-react";

interface StuckShipment {
  id: string;
  awbNumber: string;
  orderNumber: string | null;
  shopifyOrderNumber: string | null;
  invoiceSeries: string | null;
  invoiceNumber: string | null;
  customerPhone: string | null;
  customerName: string | null;
  createdAt: string;
  currentStatus: string | null;
  daysOld: number;
}

export default function StuckShipmentsPage() {
  const [shipments, setShipments] = useState<StuckShipment[]>([]);
  const [total, setTotal] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [minDays, setMinDays] = useState(3);

  useEffect(() => {
    loadShipments();
  }, [minDays]);

  async function loadShipments() {
    setIsLoading(true);
    try {
      const res = await fetch(`/api/reports/stuck-shipments?minDays=${minDays}&limit=200`);
      const data = await res.json();
      if (data.success) {
        setShipments(data.data.shipments);
        setTotal(data.data.total);
      }
    } catch (err) {
      console.error(err);
      toast.error("Eroare la incarcarea raportului");
    } finally {
      setIsLoading(false);
    }
  }

  async function downloadCSV() {
    try {
      const res = await fetch(`/api/reports/stuck-shipments?minDays=${minDays}&format=csv`);
      if (!res.ok) throw new Error("Download failed");

      const blob = await res.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `stuck-shipments-${new Date().toISOString().split("T")[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(url);

      toast.success("CSV descarcat");
    } catch (err) {
      console.error(err);
      toast.error("Eroare la descarcare");
    }
  }

  const getDaysOldBadge = (days: number) => {
    if (days > 7) {
      return <Badge variant="destructive">{days} zile</Badge>;
    } else if (days > 5) {
      return <Badge variant="default" className="bg-orange-100 text-orange-800">{days} zile</Badge>;
    } else {
      return <Badge variant="secondary">{days} zile</Badge>;
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-6">
      <PageHeader
        title="Colete Blocate"
        description="AWB-uri mai vechi de 3 zile fara rezolutie (nici livrate, nici returnate)"
      />

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <AlertTriangle className="h-5 w-5 text-yellow-500" />
            Filtru Raport
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex gap-4 items-end">
            <div className="space-y-2">
              <Label>Zile minime</Label>
              <Input
                type="number"
                min={1}
                max={30}
                value={minDays}
                onChange={(e) => setMinDays(parseInt(e.target.value) || 3)}
                className="w-24"
              />
            </div>
            <Button onClick={loadShipments} variant="outline">
              <RefreshCw className="h-4 w-4 mr-2" />
              Actualizeaza
            </Button>
            <Button onClick={downloadCSV} variant="outline">
              <Download className="h-4 w-4 mr-2" />
              Export CSV
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Total Blocate</p>
                <p className="text-2xl font-bold">{shipments.length}</p>
              </div>
              <Package className="h-8 w-8 text-muted-foreground" />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">{'>'} 7 zile</p>
                <p className="text-2xl font-bold text-red-600">
                  {shipments.filter(s => s.daysOld > 7).length}
                </p>
              </div>
              <Clock className="h-8 w-8 text-red-400" />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">5-7 zile</p>
                <p className="text-2xl font-bold text-orange-600">
                  {shipments.filter(s => s.daysOld >= 5 && s.daysOld <= 7).length}
                </p>
              </div>
              <Clock className="h-8 w-8 text-orange-400" />
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Table */}
      <Card>
        <CardHeader>
          <CardTitle>Colete Blocate ({shipments.length})</CardTitle>
          <CardDescription>
            AWB-uri create acum mai mult de {minDays} zile care nu sunt nici livrate, nici returnate
          </CardDescription>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <p className="text-muted-foreground">Loading...</p>
          ) : shipments.length === 0 ? (
            <div className="text-center py-8">
              <Package className="h-12 w-12 mx-auto text-green-500 mb-4" />
              <p className="text-lg font-medium text-green-700">
                Nicio expeditie blocata!
              </p>
              <p className="text-muted-foreground">
                Toate coletele au fost livrate sau returnate in timp util.
              </p>
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Vechime</TableHead>
                  <TableHead>AWB</TableHead>
                  <TableHead>Nr. Comanda</TableHead>
                  <TableHead>Factura</TableHead>
                  <TableHead>Client</TableHead>
                  <TableHead>Telefon</TableHead>
                  <TableHead>Status Curent</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {shipments.map((s) => (
                  <TableRow key={s.id}>
                    <TableCell>{getDaysOldBadge(s.daysOld)}</TableCell>
                    <TableCell className="font-mono text-sm">{s.awbNumber}</TableCell>
                    <TableCell>
                      {s.shopifyOrderNumber || s.orderNumber || "-"}
                    </TableCell>
                    <TableCell>
                      {s.invoiceSeries && s.invoiceNumber ? (
                        <span className="font-mono text-sm">
                          {s.invoiceSeries}{s.invoiceNumber}
                        </span>
                      ) : (
                        <span className="text-muted-foreground">-</span>
                      )}
                    </TableCell>
                    <TableCell>{s.customerName || "-"}</TableCell>
                    <TableCell>
                      {s.customerPhone ? (
                        <a
                          href={`tel:${s.customerPhone}`}
                          className="flex items-center gap-1 text-blue-600 hover:underline"
                        >
                          <Phone className="h-3 w-3" />
                          {s.customerPhone}
                        </a>
                      ) : (
                        "-"
                      )}
                    </TableCell>
                    <TableCell>
                      <span className="text-sm">{s.currentStatus || "Necunoscut"}</span>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```
  </action>
  <verify>
- Page displays stuck shipments table with all required columns
- Minimum days filter works
- CSV export downloads file
- Phone numbers are clickable tel: links
- Stats cards show breakdown by age
  </verify>
  <done>Stuck shipments report page created with filtering, stats, and CSV export</done>
</task>

</tasks>

<verification>
1. getStuckShipments returns AWBs older than N days without resolved status
2. GET /api/reports/stuck-shipments returns JSON or CSV based on format param
3. /reports/stuck-shipments page shows table with order, AWB, invoice, phone columns
4. CSV export includes all relevant columns
5. Age badges color-coded by severity (>7 days = red, 5-7 = orange)
6. Empty state shows when no stuck shipments exist
</verification>

<success_criteria>
- Stuck shipments report shows AWBs >3 days without delivery or return
- Report includes order number, AWB, invoice series, customer phone
- CSV export available for offline processing
- Stats summary shows breakdown by age
</success_criteria>

<output>
After completion, create `.planning/phases/07.10-borderou-curier-stornare/07.10-08-SUMMARY.md`
</output>
