---
phase: 07.10-borderou-curier-stornare
plan: 06
type: execute
wave: 3
depends_on: ["07.10-01", "07.10-04"]
files_modified:
  - src/lib/manifest/bulk-stornare.ts
  - src/app/api/manifests/returns/[id]/process/route.ts
  - src/app/(dashboard)/returns/manifest/page.tsx
  - src/components/manifest/ReturnManifestTable.tsx
autonomous: true

must_haves:
  truths:
    - "Office can view return manifest with AWB and invoice details"
    - "Office can confirm manifest after verification"
    - "Bulk stornare processes all invoices in confirmed manifest via Oblio"
    - "Processing results show success/failure for each invoice"
  artifacts:
    - path: "src/lib/manifest/bulk-stornare.ts"
      provides: "Bulk invoice cancellation logic"
      exports: ["processReturnManifestStornare"]
    - path: "src/app/api/manifests/returns/[id]/process/route.ts"
      provides: "POST endpoint to trigger bulk stornare"
      exports: ["POST"]
    - path: "src/app/(dashboard)/returns/manifest/page.tsx"
      provides: "Return manifest verification UI"
      min_lines: 150
  key_links:
    - from: "src/lib/manifest/bulk-stornare.ts"
      to: "src/lib/oblio.ts"
      via: "cancelInvoice"
      pattern: "cancelInvoice"
    - from: "src/app/api/manifests/returns/[id]/process/route.ts"
      to: "src/lib/manifest/bulk-stornare.ts"
      via: "processReturnManifestStornare"
      pattern: "processReturnManifestStornare"
---

<objective>
Implement Office verification UI for return manifests and bulk stornare processing via Oblio cancelInvoice API.

Purpose: Enable Office to verify return manifest against courier report and trigger bulk invoice cancellation.
Output: Return manifest page with verification UI and process endpoint for bulk stornare.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.10-borderou-curier-stornare/07.10-RESEARCH.md
@src/lib/oblio.ts
@src/lib/manifest/return-manifest.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bulk stornare service</name>
  <files>src/lib/manifest/bulk-stornare.ts</files>
  <action>
Create src/lib/manifest/bulk-stornare.ts:

```typescript
/**
 * Bulk Stornare Service
 *
 * Processes return manifests by cancelling all associated invoices in Oblio.
 * Each item is processed independently - failures don't stop the batch.
 * Results are tracked per item with error messages.
 */

import prisma from "../db";
import { ManifestStatus, ManifestItemStatus, CancellationSource } from "@prisma/client";
import { createOblioClient } from "../oblio";

export interface BulkStornareResult {
  success: boolean;
  totalProcessed: number;
  successCount: number;
  errorCount: number;
  skippedCount: number;
  errors: Array<{
    itemId: string;
    awbNumber: string;
    invoiceNumber: string | null;
    error: string;
  }>;
}

/**
 * Process a return manifest - cancel all linked invoices in Oblio
 *
 * Preconditions:
 * - Manifest must be in CONFIRMED status
 * - Only items with invoiceId are processed
 * - Each invoice is cancelled individually (no transaction rollback)
 *
 * @param manifestId - ID of the return manifest to process
 * @param userId - User performing the operation (for audit)
 */
export async function processReturnManifestStornare(
  manifestId: string,
  userId: string
): Promise<BulkStornareResult> {
  // Get manifest with items and invoices
  const manifest = await prisma.courierManifest.findUnique({
    where: { id: manifestId },
    include: {
      items: {
        include: {
          invoice: {
            include: {
              company: true
            }
          }
        }
      }
    }
  });

  if (!manifest) {
    return {
      success: false,
      totalProcessed: 0,
      successCount: 0,
      errorCount: 1,
      skippedCount: 0,
      errors: [{ itemId: "", awbNumber: "", invoiceNumber: null, error: "Manifest not found" }]
    };
  }

  if (manifest.status !== ManifestStatus.CONFIRMED) {
    return {
      success: false,
      totalProcessed: 0,
      successCount: 0,
      errorCount: 1,
      skippedCount: 0,
      errors: [{
        itemId: "",
        awbNumber: "",
        invoiceNumber: null,
        error: `Manifest must be CONFIRMED before processing (current: ${manifest.status})`
      }]
    };
  }

  const result: BulkStornareResult = {
    success: true,
    totalProcessed: 0,
    successCount: 0,
    errorCount: 0,
    skippedCount: 0,
    errors: []
  };

  // Process each item independently
  for (const item of manifest.items) {
    result.totalProcessed++;

    // Skip items without invoice
    if (!item.invoiceId || !item.invoice) {
      result.skippedCount++;
      await prisma.manifestItem.update({
        where: { id: item.id },
        data: {
          status: ManifestItemStatus.ERROR,
          errorMessage: "No invoice linked to this AWB"
        }
      });
      continue;
    }

    const invoice = item.invoice;

    // Skip already cancelled invoices
    if (invoice.status === "cancelled" || invoice.cancelledAt) {
      result.skippedCount++;
      await prisma.manifestItem.update({
        where: { id: item.id },
        data: {
          status: ManifestItemStatus.PROCESSED,
          processedAt: new Date(),
          errorMessage: "Invoice already cancelled"
        }
      });
      continue;
    }

    // Skip invoices without company (can't get Oblio credentials)
    if (!invoice.company) {
      result.errorCount++;
      result.errors.push({
        itemId: item.id,
        awbNumber: item.awbNumber,
        invoiceNumber: invoice.invoiceNumber,
        error: "Invoice has no company association"
      });
      await prisma.manifestItem.update({
        where: { id: item.id },
        data: {
          status: ManifestItemStatus.ERROR,
          errorMessage: "Invoice has no company association"
        }
      });
      continue;
    }

    // Create Oblio client for the invoice's company
    const oblioClient = createOblioClient(invoice.company);
    if (!oblioClient) {
      result.errorCount++;
      result.errors.push({
        itemId: item.id,
        awbNumber: item.awbNumber,
        invoiceNumber: invoice.invoiceNumber,
        error: "Oblio credentials not configured for company"
      });
      await prisma.manifestItem.update({
        where: { id: item.id },
        data: {
          status: ManifestItemStatus.ERROR,
          errorMessage: "Oblio credentials not configured"
        }
      });
      continue;
    }

    // Cancel invoice in Oblio
    try {
      const cancelResult = await oblioClient.cancelInvoice(
        invoice.invoiceSeriesName || "",
        invoice.invoiceNumber || ""
      );

      if (cancelResult.success) {
        result.successCount++;

        // Update invoice and manifest item
        await prisma.$transaction([
          prisma.invoice.update({
            where: { id: invoice.id },
            data: {
              status: "cancelled",
              cancelledAt: new Date(),
              cancelReason: `Return manifest ${manifestId}`,
              cancellationSource: CancellationSource.MANIFEST_RETURN,
              cancelledFromManifestId: manifestId
            }
          }),
          prisma.manifestItem.update({
            where: { id: item.id },
            data: {
              status: ManifestItemStatus.PROCESSED,
              processedAt: new Date()
            }
          })
        ]);

        // Audit log
        await prisma.auditLog.create({
          data: {
            userId,
            action: "invoice.cancelled_bulk",
            entityType: "Invoice",
            entityId: invoice.id,
            metadata: {
              manifestId,
              awbNumber: item.awbNumber,
              invoiceNumber: invoice.invoiceNumber,
              invoiceSeries: invoice.invoiceSeriesName,
              source: "manifest_return"
            }
          }
        });
      } else {
        result.errorCount++;
        result.errors.push({
          itemId: item.id,
          awbNumber: item.awbNumber,
          invoiceNumber: invoice.invoiceNumber,
          error: cancelResult.error || "Oblio cancellation failed"
        });

        await prisma.manifestItem.update({
          where: { id: item.id },
          data: {
            status: ManifestItemStatus.ERROR,
            errorMessage: cancelResult.error || "Oblio cancellation failed"
          }
        });
      }
    } catch (error: any) {
      result.errorCount++;
      result.errors.push({
        itemId: item.id,
        awbNumber: item.awbNumber,
        invoiceNumber: invoice.invoiceNumber,
        error: error.message
      });

      await prisma.manifestItem.update({
        where: { id: item.id },
        data: {
          status: ManifestItemStatus.ERROR,
          errorMessage: error.message
        }
      });
    }
  }

  // Update manifest status to PROCESSED
  await prisma.courierManifest.update({
    where: { id: manifestId },
    data: {
      status: ManifestStatus.PROCESSED,
      processedAt: new Date()
    }
  });

  // Overall success if at least one item succeeded
  result.success = result.successCount > 0;

  return result;
}
```
  </action>
  <verify>File exports processReturnManifestStornare with proper error handling per item</verify>
  <done>Bulk stornare service created with per-item processing and audit logging</done>
</task>

<task type="auto">
  <name>Task 2: Create process endpoint for return manifest</name>
  <files>src/app/api/manifests/returns/[id]/process/route.ts</files>
  <action>
Create src/app/api/manifests/returns/[id]/process/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { processReturnManifestStornare } from "@/lib/manifest/bulk-stornare";

/**
 * POST /api/manifests/returns/[id]/process
 * Process a confirmed return manifest - cancel all invoices in Oblio
 *
 * Requires: invoices.cancel permission
 * Precondition: Manifest must be in CONFIRMED status
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    // Check permission for invoice cancellation
    const canCancel = await hasPermission(session.user.id, "invoices.cancel");
    if (!canCancel) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a storna facturi" },
        { status: 403 }
      );
    }

    const { id } = await params;

    const result = await processReturnManifestStornare(id, session.user.id);

    if (!result.success && result.totalProcessed === 0) {
      return NextResponse.json(
        {
          success: false,
          error: result.errors[0]?.error || "Processing failed"
        },
        { status: 400 }
      );
    }

    return NextResponse.json({
      success: true,
      totalProcessed: result.totalProcessed,
      successCount: result.successCount,
      errorCount: result.errorCount,
      skippedCount: result.skippedCount,
      errors: result.errors
    });
  } catch (error: any) {
    console.error("Error in POST /api/manifests/returns/[id]/process:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>POST /api/manifests/returns/[id]/process triggers bulk stornare and returns results</verify>
  <done>Process endpoint created for triggering bulk stornare on confirmed manifest</done>
</task>

<task type="auto">
  <name>Task 3: Create return manifest verification UI</name>
  <files>
    src/app/(dashboard)/returns/manifest/page.tsx
    src/components/manifest/ReturnManifestTable.tsx
  </files>
  <action>
Create src/components/manifest/ReturnManifestTable.tsx:

```typescript
"use client";

import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, XCircle, Clock, AlertTriangle } from "lucide-react";

interface ManifestItem {
  id: string;
  awbNumber: string;
  originalAwb: string | null;
  status: string;
  errorMessage: string | null;
  invoice: {
    invoiceNumber: string | null;
    invoiceSeriesName: string | null;
    status: string;
    paymentStatus: string;
  } | null;
  order: {
    orderNumber: string | null;
    shopifyOrderNumber: string | null;
  } | null;
}

interface ReturnManifestTableProps {
  items: ManifestItem[];
}

export function ReturnManifestTable({ items }: ReturnManifestTableProps) {
  const getStatusIcon = (status: string) => {
    switch (status) {
      case "PROCESSED":
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case "ERROR":
        return <XCircle className="h-4 w-4 text-red-500" />;
      default:
        return <Clock className="h-4 w-4 text-yellow-500" />;
    }
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "PROCESSED":
        return <Badge variant="default" className="bg-green-100 text-green-800">Procesat</Badge>;
      case "ERROR":
        return <Badge variant="destructive">Eroare</Badge>;
      default:
        return <Badge variant="secondary">In asteptare</Badge>;
    }
  };

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="w-[50px]">Status</TableHead>
          <TableHead>AWB Retur</TableHead>
          <TableHead>AWB Original</TableHead>
          <TableHead>Comanda</TableHead>
          <TableHead>Factura</TableHead>
          <TableHead>Status Factura</TableHead>
          <TableHead>Eroare</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {items.map((item) => (
          <TableRow key={item.id}>
            <TableCell>{getStatusIcon(item.status)}</TableCell>
            <TableCell className="font-mono text-sm">{item.awbNumber}</TableCell>
            <TableCell className="font-mono text-sm">{item.originalAwb || "-"}</TableCell>
            <TableCell>
              {item.order?.shopifyOrderNumber || item.order?.orderNumber || "-"}
            </TableCell>
            <TableCell>
              {item.invoice ? (
                <span className="font-mono text-sm">
                  {item.invoice.invoiceSeriesName}{item.invoice.invoiceNumber}
                </span>
              ) : (
                <span className="text-muted-foreground">-</span>
              )}
            </TableCell>
            <TableCell>
              {item.invoice ? (
                <Badge variant={item.invoice.status === "cancelled" ? "destructive" : "secondary"}>
                  {item.invoice.status === "cancelled" ? "Stornata" : item.invoice.status}
                </Badge>
              ) : (
                "-"
              )}
            </TableCell>
            <TableCell>
              {item.errorMessage ? (
                <span className="text-xs text-red-600 flex items-center gap-1">
                  <AlertTriangle className="h-3 w-3" />
                  {item.errorMessage}
                </span>
              ) : (
                "-"
              )}
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```

Create src/app/(dashboard)/returns/manifest/page.tsx:

```typescript
"use client";

import { useState, useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { PageHeader } from "@/components/PageHeader";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ReturnManifestTable } from "@/components/manifest/ReturnManifestTable";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import {
  FileText,
  CheckCircle,
  Play,
  RefreshCw,
  Plus,
  AlertTriangle
} from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";

interface Manifest {
  id: string;
  status: string;
  documentDate: string;
  createdAt: string;
  confirmedAt: string | null;
  processedAt: string | null;
  confirmedBy: { name: string } | null;
  items: Array<{
    id: string;
    awbNumber: string;
    originalAwb: string | null;
    status: string;
    errorMessage: string | null;
    invoice: {
      invoiceNumber: string | null;
      invoiceSeriesName: string | null;
      status: string;
      paymentStatus: string;
    } | null;
    order: {
      orderNumber: string | null;
      shopifyOrderNumber: string | null;
    } | null;
  }>;
}

export default function ReturnManifestPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const manifestId = searchParams.get("id");

  const [manifest, setManifest] = useState<Manifest | null>(null);
  const [manifests, setManifests] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);

  useEffect(() => {
    if (manifestId) {
      loadManifest(manifestId);
    } else {
      loadManifestList();
    }
  }, [manifestId]);

  async function loadManifest(id: string) {
    setIsLoading(true);
    try {
      const res = await fetch(`/api/manifests/returns/${id}`);
      const data = await res.json();
      if (data.success) {
        setManifest(data.data);
      }
    } catch (err) {
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  }

  async function loadManifestList() {
    setIsLoading(true);
    try {
      const res = await fetch("/api/manifests/returns");
      const data = await res.json();
      if (data.success) {
        setManifests(data.data.manifests);
      }
    } catch (err) {
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  }

  async function generateNewManifest() {
    setIsGenerating(true);
    try {
      const res = await fetch("/api/manifests/returns", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({})
      });
      const data = await res.json();

      if (data.success) {
        toast.success(`Manifest generat cu ${data.itemCount} AWB-uri`);
        router.push(`/returns/manifest?id=${data.manifestId}`);
      } else {
        toast.error(data.error || "Eroare la generarea manifestului");
      }
    } catch (err: any) {
      toast.error(err.message);
    } finally {
      setIsGenerating(false);
    }
  }

  async function confirmManifest() {
    if (!manifest) return;

    try {
      const res = await fetch(`/api/manifests/returns/${manifest.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status: "CONFIRMED" })
      });
      const data = await res.json();

      if (data.success) {
        toast.success("Manifest confirmat");
        loadManifest(manifest.id);
      } else {
        toast.error(data.error);
      }
    } catch (err: any) {
      toast.error(err.message);
    }
  }

  async function processManifest() {
    if (!manifest) return;

    setIsProcessing(true);
    try {
      const res = await fetch(`/api/manifests/returns/${manifest.id}/process`, {
        method: "POST"
      });
      const data = await res.json();

      if (data.success || data.successCount > 0) {
        toast.success(
          `Procesare completa: ${data.successCount} stornate, ${data.errorCount} erori, ${data.skippedCount} omise`
        );
        loadManifest(manifest.id);
      } else {
        toast.error(data.error || "Eroare la procesare");
      }
    } catch (err: any) {
      toast.error(err.message);
    } finally {
      setIsProcessing(false);
    }
  }

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "DRAFT":
        return <Badge variant="secondary">Draft</Badge>;
      case "PENDING_VERIFICATION":
        return <Badge variant="outline">In verificare</Badge>;
      case "CONFIRMED":
        return <Badge className="bg-blue-100 text-blue-800">Confirmat</Badge>;
      case "PROCESSED":
        return <Badge className="bg-green-100 text-green-800">Procesat</Badge>;
      default:
        return <Badge>{status}</Badge>;
    }
  };

  // Detail view
  if (manifestId && manifest) {
    const pendingCount = manifest.items.filter(i => i.status === "PENDING").length;
    const processedCount = manifest.items.filter(i => i.status === "PROCESSED").length;
    const errorCount = manifest.items.filter(i => i.status === "ERROR").length;

    return (
      <div className="container mx-auto py-6 space-y-6">
        <PageHeader
          title="Manifest Retururi"
          description={`${manifest.items.length} AWB-uri din ${new Date(manifest.documentDate).toLocaleDateString("ro-RO")}`}
          backHref="/returns/manifest"
        />

        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="flex items-center gap-2">
                  <FileText className="h-5 w-5" />
                  Manifest {getStatusBadge(manifest.status)}
                </CardTitle>
                <CardDescription>
                  Creat: {new Date(manifest.createdAt).toLocaleString("ro-RO")}
                  {manifest.confirmedAt && (
                    <> | Confirmat: {new Date(manifest.confirmedAt).toLocaleString("ro-RO")} de {manifest.confirmedBy?.name}</>
                  )}
                </CardDescription>
              </div>
              <div className="flex gap-2">
                {manifest.status === "DRAFT" && (
                  <Button onClick={confirmManifest}>
                    <CheckCircle className="h-4 w-4 mr-2" />
                    Confirma
                  </Button>
                )}
                {manifest.status === "CONFIRMED" && (
                  <AlertDialog>
                    <AlertDialogTrigger asChild>
                      <Button variant="destructive" disabled={isProcessing}>
                        <Play className="h-4 w-4 mr-2" />
                        {isProcessing ? "Se proceseaza..." : "Storneaza Toate"}
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Confirmare Stornare</AlertDialogTitle>
                        <AlertDialogDescription>
                          Vei storna {pendingCount} facturi din Oblio. Aceasta actiune este ireversibila.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel>Anuleaza</AlertDialogCancel>
                        <AlertDialogAction onClick={processManifest}>
                          Continua Stornare
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
                )}
                <Button variant="outline" onClick={() => loadManifest(manifest.id)}>
                  <RefreshCw className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            {/* Stats */}
            <div className="flex gap-4 mb-4">
              <div className="text-sm">
                <span className="text-muted-foreground">Total:</span>{" "}
                <span className="font-medium">{manifest.items.length}</span>
              </div>
              <div className="text-sm">
                <span className="text-muted-foreground">Procesate:</span>{" "}
                <span className="font-medium text-green-600">{processedCount}</span>
              </div>
              <div className="text-sm">
                <span className="text-muted-foreground">Erori:</span>{" "}
                <span className="font-medium text-red-600">{errorCount}</span>
              </div>
              <div className="text-sm">
                <span className="text-muted-foreground">In asteptare:</span>{" "}
                <span className="font-medium">{pendingCount}</span>
              </div>
            </div>

            {errorCount > 0 && (
              <Alert variant="destructive" className="mb-4">
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription>
                  {errorCount} facturi au esuat la stornare. Verificati erorile si reincercati.
                </AlertDescription>
              </Alert>
            )}

            <ReturnManifestTable items={manifest.items} />
          </CardContent>
        </Card>
      </div>
    );
  }

  // List view
  return (
    <div className="container mx-auto py-6 space-y-6">
      <PageHeader
        title="Manifeste Retururi"
        description="Generare si verificare manifeste pentru stornare"
      />

      <div className="flex justify-end">
        <Button onClick={generateNewManifest} disabled={isGenerating}>
          <Plus className="h-4 w-4 mr-2" />
          {isGenerating ? "Se genereaza..." : "Genereaza Manifest Nou"}
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Manifeste Recente</CardTitle>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <p>Loading...</p>
          ) : manifests.length === 0 ? (
            <p className="text-muted-foreground">Nu exista manifeste. Genereaza unul nou din retururile scanate.</p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Data</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>AWB-uri</TableHead>
                  <TableHead>Procesate</TableHead>
                  <TableHead>Erori</TableHead>
                  <TableHead></TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {manifests.map((m) => (
                  <TableRow key={m.id}>
                    <TableCell>
                      {new Date(m.documentDate).toLocaleDateString("ro-RO")}
                    </TableCell>
                    <TableCell>{getStatusBadge(m.status)}</TableCell>
                    <TableCell>{m.itemCount}</TableCell>
                    <TableCell>{m.processedCount}</TableCell>
                    <TableCell>
                      {m.errorCount > 0 ? (
                        <Badge variant="destructive">{m.errorCount}</Badge>
                      ) : (
                        "-"
                      )}
                    </TableCell>
                    <TableCell>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => router.push(`/returns/manifest?id=${m.id}`)}
                      >
                        Deschide
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}

// Import Table components at top
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
```
  </action>
  <verify>
- Page shows manifest list when no ID parameter
- Page shows manifest detail when ID parameter present
- Generate button creates new manifest from scanned returns
- Confirm button transitions manifest to CONFIRMED status
- Process button triggers bulk stornare with confirmation dialog
- Results show success/error counts
  </verify>
  <done>Return manifest verification UI created with generation, confirmation, and processing</done>
</task>

</tasks>

<verification>
1. processReturnManifestStornare cancels each invoice via Oblio API
2. POST /api/manifests/returns/[id]/process returns detailed results
3. /returns/manifest page lists existing manifests
4. /returns/manifest?id=X shows manifest detail with items
5. Confirmation dialog warns before bulk stornare
6. Errors are displayed per item with messages
7. Audit logs created for each cancelled invoice
</verification>

<success_criteria>
- Office can view return manifest with all AWB and invoice details
- Office can confirm manifest after comparing with courier report
- Bulk stornare processes all invoices with individual error handling
- Results show success/failure counts for transparency
</success_criteria>

<output>
After completion, create `.planning/phases/07.10-borderou-curier-stornare/07.10-06-SUMMARY.md`
</output>
