---
phase: 07.10-borderou-curier-stornare
plan: 05
type: execute
wave: 2
depends_on: ["07.10-01", "07.10-04"]
files_modified:
  - src/lib/manifest/delivery-manifest.ts
  - src/app/api/manifests/deliveries/route.ts
  - src/app/api/manifests/deliveries/[id]/route.ts
  - src/app/api/manifests/deliveries/upload/route.ts
autonomous: true

must_haves:
  truths:
    - "Delivery manifest can be fetched from FanCourier API by date"
    - "Manual CSV upload fallback exists for delivery manifest"
    - "Manifest links delivered AWBs to their invoices"
  artifacts:
    - path: "src/lib/manifest/delivery-manifest.ts"
      provides: "Delivery manifest fetch and processing logic"
      exports: ["fetchDeliveryManifest", "parseDeliveryManifestCSV", "getDeliveryManifest"]
    - path: "src/app/api/manifests/deliveries/route.ts"
      provides: "POST to fetch/create, GET to list delivery manifests"
      exports: ["GET", "POST"]
    - path: "src/app/api/manifests/deliveries/upload/route.ts"
      provides: "POST for manual CSV upload fallback"
      exports: ["POST"]
  key_links:
    - from: "src/lib/manifest/delivery-manifest.ts"
      to: "src/lib/fancourier.ts"
      via: "getAllAWBsForDate"
      pattern: "getAllAWBsForDate"
    - from: "src/app/api/manifests/deliveries/route.ts"
      to: "src/lib/manifest/delivery-manifest.ts"
      via: "fetchDeliveryManifest import"
      pattern: "import.*delivery-manifest"
---

<objective>
Implement delivery manifest processing: fetch from FanCourier API (filtering by delivered status S2), or accept manual CSV upload. Create CourierManifest with DELIVERY type linking to invoices.

Purpose: Enable automatic payment marking by collecting delivered AWBs from courier manifest.
Output: Delivery manifest service with API fetch and CSV upload fallback.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.10-borderou-curier-stornare/07.10-RESEARCH.md
@src/lib/fancourier.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delivery manifest service</name>
  <files>src/lib/manifest/delivery-manifest.ts</files>
  <action>
Create src/lib/manifest/delivery-manifest.ts:

```typescript
/**
 * Delivery Manifest Service
 *
 * Fetches delivery manifest from FanCourier API or parses uploaded CSV.
 * Links delivered AWBs to invoices for automatic payment marking.
 *
 * FanCourier API: Uses getAllAWBsForDate() and filters by S2 (delivered) status.
 */

import prisma from "../db";
import { ManifestStatus, ManifestType, ManifestItemStatus } from "@prisma/client";
import { FanCourierAPI } from "../fancourier";

// Status codes that indicate delivery
const DELIVERED_STATUS_CODES = ["S2", "2", "livrat", "delivered"];

export interface DeliveryManifestResult {
  success: boolean;
  manifestId?: string;
  itemCount?: number;
  skippedCount?: number;
  error?: string;
}

/**
 * Fetch delivery manifest from FanCourier API for a specific date
 * Creates a CourierManifest with DELIVERY type containing delivered AWBs
 *
 * @param date - Date to fetch deliveries for (YYYY-MM-DD format)
 * @param companyId - Company ID to get FanCourier credentials
 */
export async function fetchDeliveryManifest(
  date: string,
  companyId: string
): Promise<DeliveryManifestResult> {
  try {
    // Get company with FanCourier credentials
    const company = await prisma.company.findUnique({
      where: { id: companyId },
      select: {
        id: true,
        fancourierClientId: true,
        fancourierUsername: true,
        fancourierPassword: true
      }
    });

    if (!company?.fancourierClientId || !company?.fancourierUsername || !company?.fancourierPassword) {
      return {
        success: false,
        error: "FanCourier credentials not configured for this company"
      };
    }

    // Initialize FanCourier client
    const fanCourier = new FanCourierAPI({
      clientId: company.fancourierClientId,
      username: company.fancourierUsername,
      password: company.fancourierPassword
    });

    // Fetch all AWBs for the date
    const response = await fanCourier.getAllAWBsForDate(date);

    if (!response.success || !response.data) {
      return {
        success: false,
        error: response.error || "Failed to fetch AWBs from FanCourier"
      };
    }

    // Filter for delivered AWBs (S2 status)
    const deliveredAwbs = response.data.filter(awb => {
      const statusCode = awb.status_code || awb.statusCode || awb.status;
      return DELIVERED_STATUS_CODES.some(code =>
        String(statusCode).toLowerCase().includes(code.toLowerCase())
      );
    });

    if (deliveredAwbs.length === 0) {
      return {
        success: false,
        error: `No delivered AWBs found for ${date}`
      };
    }

    // Create manifest from delivered AWBs
    return await createDeliveryManifestFromAwbs(deliveredAwbs, date);
  } catch (error: any) {
    console.error("Error fetching delivery manifest:", error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Parse CSV content for delivery manifest (manual upload fallback)
 * Expected columns: AWB, Status (or similar)
 *
 * @param csvContent - Raw CSV content
 * @param date - Manifest date
 */
export async function parseDeliveryManifestCSV(
  csvContent: string,
  date: string
): Promise<DeliveryManifestResult> {
  try {
    const lines = csvContent.trim().split("\n");
    if (lines.length < 2) {
      return { success: false, error: "CSV file is empty or has no data rows" };
    }

    // Parse header to find AWB column
    const header = lines[0].split(",").map(h => h.trim().toLowerCase());
    const awbIndex = header.findIndex(h =>
      ["awb", "awb_number", "awbnumber", "nr_awb", "colet"].includes(h)
    );

    if (awbIndex === -1) {
      return { success: false, error: "Could not find AWB column in CSV" };
    }

    // Parse data rows
    const awbs: { awbNumber: string }[] = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(",").map(c => c.trim().replace(/"/g, ""));
      if (cols[awbIndex]) {
        awbs.push({ awbNumber: cols[awbIndex] });
      }
    }

    if (awbs.length === 0) {
      return { success: false, error: "No valid AWB numbers found in CSV" };
    }

    return await createDeliveryManifestFromAwbs(awbs, date);
  } catch (error: any) {
    console.error("Error parsing delivery manifest CSV:", error);
    return { success: false, error: error.message };
  }
}

/**
 * Internal: Create manifest from AWB list
 */
async function createDeliveryManifestFromAwbs(
  awbList: Array<{ awbNumber?: string; awb?: string; [key: string]: any }>,
  date: string
): Promise<DeliveryManifestResult> {
  // Extract AWB numbers
  const awbNumbers = awbList.map(a => a.awbNumber || a.awb || "").filter(Boolean);

  // Find existing AWBs in database to link to orders and invoices
  const existingAwbs = await prisma.aWB.findMany({
    where: {
      awbNumber: { in: awbNumbers }
    },
    include: {
      order: {
        include: {
          invoice: true
        }
      }
    }
  });

  const awbMap = new Map(existingAwbs.map(a => [a.awbNumber, a]));

  // Check which AWBs are already in a non-processed delivery manifest
  const existingManifestItems = await prisma.manifestItem.findMany({
    where: {
      manifest: {
        type: ManifestType.DELIVERY,
        status: { not: ManifestStatus.PROCESSED }
      },
      awbNumber: { in: awbNumbers }
    },
    select: { awbNumber: true }
  });

  const existingInManifest = new Set(existingManifestItems.map(i => i.awbNumber));

  // Build manifest items, skipping those already in a manifest
  const manifestItems: Array<{
    awbNumber: string;
    orderId: string | null;
    invoiceId: string | null;
    status: ManifestItemStatus;
  }> = [];

  let skippedCount = 0;

  for (const awbNumber of awbNumbers) {
    if (existingInManifest.has(awbNumber)) {
      skippedCount++;
      continue;
    }

    const awb = awbMap.get(awbNumber);
    manifestItems.push({
      awbNumber,
      orderId: awb?.order?.id || null,
      invoiceId: awb?.order?.invoice?.id || null,
      status: ManifestItemStatus.PENDING
    });
  }

  if (manifestItems.length === 0) {
    return {
      success: false,
      error: "All AWBs are already in pending manifests",
      skippedCount
    };
  }

  // Create the manifest
  const manifest = await prisma.courierManifest.create({
    data: {
      type: ManifestType.DELIVERY,
      status: ManifestStatus.DRAFT,
      documentDate: new Date(date),
      items: {
        create: manifestItems
      }
    }
  });

  return {
    success: true,
    manifestId: manifest.id,
    itemCount: manifestItems.length,
    skippedCount
  };
}

/**
 * Get delivery manifest by ID with all items
 */
export async function getDeliveryManifest(manifestId: string) {
  return prisma.courierManifest.findUnique({
    where: { id: manifestId },
    include: {
      items: {
        include: {
          invoice: {
            select: {
              id: true,
              invoiceNumber: true,
              invoiceSeriesName: true,
              status: true,
              paymentStatus: true,
              paidAt: true
            }
          },
          order: {
            select: {
              id: true,
              orderNumber: true,
              shopifyOrderNumber: true,
              totalPrice: true
            }
          }
        },
        orderBy: { awbNumber: 'asc' }
      },
      confirmedBy: {
        select: { id: true, name: true }
      }
    }
  });
}

/**
 * List delivery manifests with pagination
 */
export async function listDeliveryManifests({
  status,
  limit = 20,
  offset = 0
}: {
  status?: ManifestStatus;
  limit?: number;
  offset?: number;
} = {}) {
  const where: any = {
    type: ManifestType.DELIVERY
  };

  if (status) {
    where.status = status;
  }

  const [manifests, total] = await Promise.all([
    prisma.courierManifest.findMany({
      where,
      include: {
        items: {
          select: { id: true, status: true }
        },
        confirmedBy: {
          select: { name: true }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: limit,
      skip: offset
    }),
    prisma.courierManifest.count({ where })
  ]);

  return {
    manifests: manifests.map(m => ({
      ...m,
      itemCount: m.items.length,
      processedCount: m.items.filter(i => i.status === ManifestItemStatus.PROCESSED).length,
      errorCount: m.items.filter(i => i.status === ManifestItemStatus.ERROR).length
    })),
    total,
    limit,
    offset
  };
}
```
  </action>
  <verify>File exports fetchDeliveryManifest, parseDeliveryManifestCSV, getDeliveryManifest, listDeliveryManifests</verify>
  <done>Delivery manifest service created with FanCourier fetch and CSV parsing</done>
</task>

<task type="auto">
  <name>Task 2: Create delivery manifest API endpoints</name>
  <files>
    src/app/api/manifests/deliveries/route.ts
    src/app/api/manifests/deliveries/[id]/route.ts
    src/app/api/manifests/deliveries/upload/route.ts
  </files>
  <action>
Create src/app/api/manifests/deliveries/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import {
  fetchDeliveryManifest,
  listDeliveryManifests
} from "@/lib/manifest/delivery-manifest";
import { ManifestStatus } from "@prisma/client";

/**
 * GET /api/manifests/deliveries
 * List delivery manifests
 */
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canView = await hasPermission(session.user.id, "invoices.view");
    if (!canView) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a vizualiza manifestele" },
        { status: 403 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get("status") as ManifestStatus | undefined;
    const limit = parseInt(searchParams.get("limit") || "20");
    const offset = parseInt(searchParams.get("offset") || "0");

    const result = await listDeliveryManifests({ status, limit, offset });

    return NextResponse.json({
      success: true,
      data: result
    });
  } catch (error: any) {
    console.error("Error in GET /api/manifests/deliveries:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

/**
 * POST /api/manifests/deliveries
 * Fetch delivery manifest from FanCourier API
 *
 * Body: { date: string (YYYY-MM-DD), companyId: string }
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canCreate = await hasPermission(session.user.id, "invoices.edit");
    if (!canCreate) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a genera manifeste" },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { date, companyId } = body;

    if (!date) {
      return NextResponse.json(
        { success: false, error: "Date is required (YYYY-MM-DD format)" },
        { status: 400 }
      );
    }

    if (!companyId) {
      return NextResponse.json(
        { success: false, error: "Company ID is required" },
        { status: 400 }
      );
    }

    const result = await fetchDeliveryManifest(date, companyId);

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error, skippedCount: result.skippedCount },
        { status: 400 }
      );
    }

    return NextResponse.json({
      success: true,
      manifestId: result.manifestId,
      itemCount: result.itemCount,
      skippedCount: result.skippedCount
    });
  } catch (error: any) {
    console.error("Error in POST /api/manifests/deliveries:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

Create src/app/api/manifests/deliveries/[id]/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { getDeliveryManifest } from "@/lib/manifest/delivery-manifest";
import prisma from "@/lib/db";
import { ManifestStatus } from "@prisma/client";

/**
 * GET /api/manifests/deliveries/[id]
 * Get specific delivery manifest
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canView = await hasPermission(session.user.id, "invoices.view");
    if (!canView) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a vizualiza manifestul" },
        { status: 403 }
      );
    }

    const { id } = await params;
    const manifest = await getDeliveryManifest(id);

    if (!manifest) {
      return NextResponse.json(
        { error: "Manifestul nu a fost gasit" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      data: manifest
    });
  } catch (error: any) {
    console.error("Error in GET /api/manifests/deliveries/[id]:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/manifests/deliveries/[id]
 * Update delivery manifest status
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canEdit = await hasPermission(session.user.id, "invoices.edit");
    if (!canEdit) {
      return NextResponse.json(
        { error: "Nu ai permisiunea pentru aceasta operatie" },
        { status: 403 }
      );
    }

    const { id } = await params;
    const body = await request.json();
    const { status } = body;

    if (!status || !Object.values(ManifestStatus).includes(status)) {
      return NextResponse.json(
        { error: "Invalid status" },
        { status: 400 }
      );
    }

    const updateData: any = { status };

    if (status === ManifestStatus.CONFIRMED) {
      updateData.confirmedAt = new Date();
      updateData.confirmedById = session.user.id;
    }

    if (status === ManifestStatus.PROCESSED) {
      updateData.processedAt = new Date();
    }

    await prisma.courierManifest.update({
      where: { id },
      data: updateData
    });

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error("Error in PATCH /api/manifests/deliveries/[id]:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```

Create src/app/api/manifests/deliveries/upload/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { parseDeliveryManifestCSV } from "@/lib/manifest/delivery-manifest";

/**
 * POST /api/manifests/deliveries/upload
 * Upload CSV for manual delivery manifest creation
 *
 * Body: FormData with 'file' (CSV) and 'date' (YYYY-MM-DD)
 */
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    const canCreate = await hasPermission(session.user.id, "invoices.edit");
    if (!canCreate) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a incarca manifeste" },
        { status: 403 }
      );
    }

    const formData = await request.formData();
    const file = formData.get("file") as File | null;
    const date = formData.get("date") as string | null;

    if (!file) {
      return NextResponse.json(
        { success: false, error: "CSV file is required" },
        { status: 400 }
      );
    }

    if (!date) {
      return NextResponse.json(
        { success: false, error: "Date is required (YYYY-MM-DD format)" },
        { status: 400 }
      );
    }

    // Read file content
    const csvContent = await file.text();

    const result = await parseDeliveryManifestCSV(csvContent, date);

    if (!result.success) {
      return NextResponse.json(
        { success: false, error: result.error, skippedCount: result.skippedCount },
        { status: 400 }
      );
    }

    return NextResponse.json({
      success: true,
      manifestId: result.manifestId,
      itemCount: result.itemCount,
      skippedCount: result.skippedCount
    });
  } catch (error: any) {
    console.error("Error in POST /api/manifests/deliveries/upload:", error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>
- POST /api/manifests/deliveries fetches from FanCourier
- POST /api/manifests/deliveries/upload accepts CSV file
- GET endpoints return manifest data correctly
  </verify>
  <done>Delivery manifest API endpoints created with fetch and upload capabilities</done>
</task>

</tasks>

<verification>
1. fetchDeliveryManifest filters FanCourier results for S2 (delivered) status
2. parseDeliveryManifestCSV parses AWB column from uploaded CSV
3. POST /api/manifests/deliveries creates manifest from API
4. POST /api/manifests/deliveries/upload creates manifest from CSV
5. Manifest items link to orders and invoices for payment marking
6. Duplicate AWBs (already in pending manifest) are skipped
</verification>

<success_criteria>
- FanCourier API integration fetches delivered AWBs by date
- CSV upload fallback accepts simple AWB list
- Each manifest item links AWB to invoice for payment processing
- Manifests have proper status workflow support
</success_criteria>

<output>
After completion, create `.planning/phases/07.10-borderou-curier-stornare/07.10-05-SUMMARY.md`
</output>
