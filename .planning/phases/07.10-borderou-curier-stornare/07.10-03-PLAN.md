---
phase: 07.10-borderou-curier-stornare
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/returns/route.ts
  - src/lib/returns.ts
autonomous: true

must_haves:
  truths:
    - "Returns API supports offset-based pagination"
    - "Returns page shows more than 100 items when available"
    - "Pagination parameters are properly validated"
  artifacts:
    - path: "src/app/api/returns/route.ts"
      provides: "GET endpoint with offset and limit parameters"
      contains: "offset"
    - path: "src/lib/returns.ts"
      provides: "getScannedReturns with offset support"
      contains: "skip"
  key_links:
    - from: "src/app/api/returns/route.ts"
      to: "src/lib/returns.ts"
      via: "getScannedReturns call"
      pattern: "getScannedReturns"
---

<objective>
Fix returns page pagination bug - currently only shows 100 items. Add offset parameter to API and update the returns library function.

Purpose: Enable viewing all returns, not just first 100.
Output: Returns API with proper offset-based pagination support.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/app/api/returns/route.ts
@src/lib/returns.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update returns API with offset pagination and total count</name>
  <files>src/app/api/returns/route.ts</files>
  <action>
Update src/app/api/returns/route.ts to add offset pagination:

1. Parse offset parameter from query string (default: 0)
2. Add limit validation (max 100, default 50)
3. Pass offset to getScannedReturns
4. Return total count for pagination UI

Updated implementation:

```typescript
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { hasPermission } from "@/lib/permissions";
import { getScannedReturns, getPendingReturns, getTotalScannedReturnsCount } from "@/lib/returns";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Neautorizat" }, { status: 401 });
    }

    // Check permission
    const canView = await hasPermission(session.user.id, "handover.scan");
    if (!canView) {
      return NextResponse.json(
        { error: "Nu ai permisiunea de a vizualiza retururile" },
        { status: 403 }
      );
    }

    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get("status") || undefined;
    const unmappedOnly = searchParams.get("unmappedOnly") === "true";

    // Pagination parameters with validation
    const limit = Math.min(
      parseInt(searchParams.get("limit") || "50"),
      100 // Max 100 per page
    );
    const offset = Math.max(
      parseInt(searchParams.get("offset") || "0"),
      0 // Min 0
    );

    const [scannedReturns, pendingReturns, totalCount] = await Promise.all([
      getScannedReturns({ status, unmappedOnly, limit, offset }),
      getPendingReturns(),
      getTotalScannedReturnsCount({ status, unmappedOnly }),
    ]);

    // Calculate stats (for today only, not affected by pagination)
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Stats are for displayed page, but totalScannedToday needs full count
    const todayScans = scannedReturns.filter(
      (r) => new Date(r.scannedAt) >= today
    );
    const unmappedCount = scannedReturns.filter((r) => !r.orderId).length;

    return NextResponse.json({
      success: true,
      data: {
        scannedReturns,
        pendingReturns,
        stats: {
          totalScannedToday: todayScans.length,
          totalUnmapped: unmappedCount,
          totalPendingReturns: pendingReturns.length,
        },
        pagination: {
          total: totalCount,
          limit,
          offset,
          hasMore: offset + scannedReturns.length < totalCount,
        },
      },
    });
  } catch (error: unknown) {
    console.error("Error in GET /api/returns:", error);
    const errorMessage =
      error instanceof Error ? error.message : "Eroare la incarcarea retururilor";
    return NextResponse.json(
      {
        success: false,
        message: errorMessage,
      },
      { status: 500 }
    );
  }
}
```
  </action>
  <verify>API endpoint parses offset and limit parameters and returns pagination object</verify>
  <done>Returns API updated with offset-based pagination and total count</done>
</task>

<task type="auto">
  <name>Task 2: Update returns library to support offset and add count function</name>
  <files>src/lib/returns.ts</files>
  <action>
Update src/lib/returns.ts to support offset pagination:

1. Add offset parameter to getScannedReturns function signature
2. Pass offset as `skip` to Prisma query
3. Add new getTotalScannedReturnsCount function for pagination

Find the getScannedReturns function and update it:

```typescript
// Update the interface for options
interface GetScannedReturnsOptions {
  status?: string;
  unmappedOnly?: boolean;
  limit?: number;
  offset?: number;  // NEW: Add offset parameter
}

// Update the getScannedReturns function
export async function getScannedReturns({
  status,
  unmappedOnly = false,
  limit = 50,
  offset = 0,  // NEW: Default offset to 0
}: GetScannedReturnsOptions = {}) {
  const where: any = {};

  if (status) {
    where.status = status;
  }

  if (unmappedOnly) {
    where.orderId = null;
  }

  const returns = await prisma.returnAWB.findMany({
    where,
    orderBy: { scannedAt: "desc" },
    take: limit,
    skip: offset,  // NEW: Add skip for offset pagination
    include: {
      originalAwb: {
        include: {
          order: {
            select: {
              id: true,
              orderNumber: true,
              shopifyOrderNumber: true,
              billingAddress: true,
            },
          },
        },
      },
      order: {
        select: {
          id: true,
          orderNumber: true,
          shopifyOrderNumber: true,
          billingAddress: true,
        },
      },
    },
  });

  return returns;
}

// NEW: Add function to get total count for pagination
export async function getTotalScannedReturnsCount({
  status,
  unmappedOnly = false,
}: {
  status?: string;
  unmappedOnly?: boolean;
} = {}): Promise<number> {
  const where: any = {};

  if (status) {
    where.status = status;
  }

  if (unmappedOnly) {
    where.orderId = null;
  }

  return prisma.returnAWB.count({ where });
}
```

Make sure to export the new function at the bottom of the file if there's an explicit exports section.
  </action>
  <verify>
- getScannedReturns accepts offset parameter
- Prisma query includes `skip: offset`
- getTotalScannedReturnsCount function exists and is exported
  </verify>
  <done>Returns library updated with offset support and count function for pagination</done>
</task>

</tasks>

<verification>
1. API returns pagination object with total, limit, offset, hasMore
2. Requesting offset=0, limit=50 returns first 50 items
3. Requesting offset=50, limit=50 returns next 50 items
4. Total count reflects all matching records, not just current page
5. curl test: `curl "/api/returns?limit=10&offset=0"` returns first 10 items with pagination info
</verification>

<success_criteria>
- Returns API accepts offset and limit query parameters
- Limit is capped at 100 to prevent large queries
- Response includes pagination.total for UI pagination controls
- Multiple pages of returns can be retrieved by incrementing offset
</success_criteria>

<output>
After completion, create `.planning/phases/07.10-borderou-curier-stornare/07.10-03-SUMMARY.md`
</output>
