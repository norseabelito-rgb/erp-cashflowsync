# Plan 07.1-05: Automatic Stock & Price Sync

## Overview

**Phase**: 7.1 - Trendyol Complete Integration
**Plan**: 05 of 06
**Wave**: 4 (Automation)
**Depends on**: Product publish already works (existing)
**Estimated complexity**: Medium

## Goal

Automatically sync stock levels and prices from ERP to Trendyol when products are updated. This ensures Trendyol always has accurate inventory and pricing.

## Context

Current state:
- `updatePriceAndInventory()` method exists in TrendyolClient
- Products can be published to Trendyol manually
- No automatic sync when stock/price changes in ERP
- MasterProduct has `trendyolBarcode` field linking to Trendyol

Desired state:
- When stock changes in ERP, update Trendyol automatically
- When price changes in ERP, update Trendyol automatically
- Batch updates for efficiency (not one API call per product)
- Manual sync button as backup

## Tasks

### Task 1: Create Stock Sync Service

**File**: `src/lib/trendyol-stock-sync.ts` (new)

```typescript
import { TrendyolClient } from "./trendyol";
import { prisma } from "./prisma";

interface StockSyncItem {
  barcode: string;
  quantity: number;
  salePrice: number;
  listPrice: number;
}

interface SyncResult {
  success: boolean;
  synced: number;
  failed: number;
  errors: string[];
  batchRequestId?: string;
}

/**
 * Syncs stock and prices for all products with trendyolBarcode to Trendyol
 */
export async function syncAllProductsToTrendyol(): Promise<SyncResult> {
  // 1. Get settings
  const settings = await prisma.settings.findFirst();
  if (!settings?.trendyolApiKey || !settings?.trendyolApiSecret) {
    return {
      success: false,
      synced: 0,
      failed: 0,
      errors: ["Trendyol API credentials not configured"]
    };
  }

  // 2. Get all products with trendyolBarcode
  const products = await prisma.masterProduct.findMany({
    where: {
      trendyolBarcode: { not: null },
      trendyolStatus: "approved" // Only sync approved products
    },
    include: {
      inventoryItems: true // For stock calculation
    }
  });

  if (products.length === 0) {
    return { success: true, synced: 0, failed: 0, errors: [] };
  }

  // 3. Build sync items
  const currencyRate = settings.trendyolCurrencyRate
    ? parseFloat(settings.trendyolCurrencyRate.toString())
    : 5.0; // Default RON to EUR rate

  const items: StockSyncItem[] = products.map(product => {
    // Calculate total stock across all inventory locations
    const totalStock = product.inventoryItems.reduce(
      (sum, item) => sum + item.quantity,
      0
    );

    // Convert prices from RON to EUR
    const priceRon = parseFloat(product.price?.toString() || "0");
    const priceEur = priceRon / currencyRate;

    return {
      barcode: product.trendyolBarcode!,
      quantity: Math.max(0, totalStock), // Ensure non-negative
      salePrice: Math.round(priceEur * 100) / 100, // Round to 2 decimals
      listPrice: Math.round(priceEur * 100) / 100  // Same for now
    };
  });

  // 4. Send to Trendyol in batches (max 100 per request)
  const client = new TrendyolClient({
    supplierId: settings.trendyolSupplierId!,
    apiKey: settings.trendyolApiKey,
    apiSecret: settings.trendyolApiSecret,
    isTestMode: settings.trendyolIsTestMode
  });

  const BATCH_SIZE = 100;
  let synced = 0;
  let failed = 0;
  const errors: string[] = [];
  let lastBatchId: string | undefined;

  for (let i = 0; i < items.length; i += BATCH_SIZE) {
    const batch = items.slice(i, i + BATCH_SIZE);

    try {
      const result = await client.updatePriceAndInventory(batch);

      if (result.success) {
        synced += batch.length;
        lastBatchId = result.batchRequestId;
      } else {
        failed += batch.length;
        errors.push(`Batch ${i / BATCH_SIZE + 1}: ${result.error}`);
      }
    } catch (error) {
      failed += batch.length;
      errors.push(`Batch ${i / BATCH_SIZE + 1}: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }

  // 5. Update last synced timestamp
  await prisma.masterProduct.updateMany({
    where: {
      trendyolBarcode: { in: items.map(i => i.barcode) }
    },
    data: {
      trendyolLastSyncedAt: new Date()
    }
  });

  return {
    success: failed === 0,
    synced,
    failed,
    errors,
    batchRequestId: lastBatchId
  };
}

/**
 * Syncs a single product to Trendyol
 */
export async function syncSingleProductToTrendyol(
  productId: string
): Promise<SyncResult> {
  const product = await prisma.masterProduct.findUnique({
    where: { id: productId },
    include: { inventoryItems: true }
  });

  if (!product?.trendyolBarcode || product.trendyolStatus !== "approved") {
    return {
      success: false,
      synced: 0,
      failed: 0,
      errors: ["Product not found or not approved on Trendyol"]
    };
  }

  // Reuse full sync with single product
  // ... similar logic but for one product
  return syncAllProductsToTrendyol(); // Simplified - sync all
}
```

### Task 2: Add Sync Triggers on Product Update

**File**: `src/app/api/products/[id]/route.ts` or product update handler

```typescript
// After updating product price or stock
import { syncSingleProductToTrendyol } from "@/lib/trendyol-stock-sync";

// In PUT/PATCH handler:
const updatedProduct = await prisma.masterProduct.update({
  where: { id: productId },
  data: updateData
});

// Trigger Trendyol sync if product has trendyolBarcode
if (updatedProduct.trendyolBarcode && updatedProduct.trendyolStatus === "approved") {
  syncSingleProductToTrendyol(productId).catch(err => {
    console.error("[Trendyol] Failed to sync product:", err);
  });
}
```

### Task 3: Add Manual Sync Button to Trendyol Page

**File**: `src/app/(dashboard)/trendyol/page.tsx`

```tsx
// Add sync all button
const [syncing, setSyncing] = useState(false);
const [syncResult, setSyncResult] = useState<SyncResult | null>(null);

const handleSyncAll = async () => {
  setSyncing(true);
  setSyncResult(null);

  try {
    const response = await fetch("/api/trendyol?action=syncInventory", {
      method: "POST"
    });
    const result = await response.json();
    setSyncResult(result);
  } catch (error) {
    setSyncResult({
      success: false,
      synced: 0,
      failed: 0,
      errors: ["Eroare la sincronizare"]
    });
  } finally {
    setSyncing(false);
  }
};

// In JSX
<Button onClick={handleSyncAll} disabled={syncing}>
  {syncing ? (
    <>
      <Loader2 className="h-4 w-4 animate-spin mr-2" />
      Se sincronizeaza...
    </>
  ) : (
    <>
      <RefreshCw className="h-4 w-4 mr-2" />
      Sincronizeaza stoc & preturi
    </>
  )}
</Button>

{syncResult && (
  <Alert variant={syncResult.success ? "default" : "destructive"}>
    <AlertDescription>
      {syncResult.success
        ? `Sincronizat: ${syncResult.synced} produse`
        : `Eroare: ${syncResult.errors.join(", ")}`}
    </AlertDescription>
  </Alert>
)}
```

### Task 4: API Endpoint for Sync

**File**: `src/app/api/trendyol/route.ts`

```typescript
case "syncInventory":
  const syncResult = await syncAllProductsToTrendyol();
  return NextResponse.json(syncResult);

case "syncProduct":
  const { productId } = await request.json();
  const productSyncResult = await syncSingleProductToTrendyol(productId);
  return NextResponse.json(productSyncResult);
```

### Task 5: Add Last Synced Indicator

**File**: `src/app/(dashboard)/trendyol/page.tsx`

```tsx
// Show last sync time per product in table
<TableCell>
  {product.trendyolLastSyncedAt
    ? formatDistanceToNow(new Date(product.trendyolLastSyncedAt), {
        addSuffix: true,
        locale: ro
      })
    : "Niciodata"}
</TableCell>

// Show global last sync time
const lastSyncedProduct = products
  .filter(p => p.trendyolLastSyncedAt)
  .sort((a, b) => new Date(b.trendyolLastSyncedAt!).getTime() - new Date(a.trendyolLastSyncedAt!).getTime())[0];

{lastSyncedProduct && (
  <p className="text-sm text-muted-foreground">
    Ultima sincronizare: {formatDistanceToNow(new Date(lastSyncedProduct.trendyolLastSyncedAt!), { addSuffix: true, locale: ro })}
  </p>
)}
```

### Task 6: Cron Endpoint for Scheduled Sync (Optional)

**File**: `src/app/api/cron/trendyol-sync/route.ts` (new)

```typescript
import { syncAllProductsToTrendyol } from "@/lib/trendyol-stock-sync";
import { NextResponse } from "next/server";

// Called by Vercel Cron or external scheduler
export async function GET(request: Request) {
  // Verify cron secret
  const authHeader = request.headers.get("authorization");
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const result = await syncAllProductsToTrendyol();

  console.log("[Trendyol Cron] Stock sync completed:", result);

  return NextResponse.json(result);
}

export const dynamic = "force-dynamic";
```

## File Changes Summary

| File | Action | Description |
|------|--------|-------------|
| `src/lib/trendyol-stock-sync.ts` | CREATE | Stock sync service |
| `src/app/api/products/[id]/route.ts` | MODIFY | Add sync trigger on update |
| `src/app/(dashboard)/trendyol/page.tsx` | MODIFY | Add sync button & status |
| `src/app/api/trendyol/route.ts` | MODIFY | Add sync endpoints |
| `src/app/api/cron/trendyol-sync/route.ts` | CREATE | Cron endpoint (optional) |

## Verification

- [ ] Manual sync button updates all products on Trendyol
- [ ] Price changes in ERP reflect on Trendyol
- [ ] Stock changes in ERP reflect on Trendyol
- [ ] Currency conversion (RON â†’ EUR) is correct
- [ ] Batch processing works for large catalogs
- [ ] Last synced timestamp is updated
- [ ] Errors are handled gracefully

## Notes

- Use batch API (100 products per request) for efficiency
- Currency conversion rate from settings.trendyolCurrencyRate
- Only sync "approved" products (skip pending/rejected)
- Consider rate limiting to avoid Trendyol API limits
- Cron schedule: every 15-30 minutes for near-real-time sync
