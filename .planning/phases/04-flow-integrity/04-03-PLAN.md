---
phase: 04-flow-integrity
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/orders/[id]/check-transfer/route.ts
  - src/app/api/orders/check-transfers/route.ts
autonomous: true

must_haves:
  truths:
    - "Single-order API endpoint returns transfer status for a given order"
    - "Batch API endpoint returns transfer status for multiple orders"
    - "Response includes transfer number, status, and whether confirmation is needed"
    - "Both endpoints are authenticated and check permissions"
  artifacts:
    - path: "src/app/api/orders/[id]/check-transfer/route.ts"
      provides: "Pre-flight check for single order transfer status"
      exports: ["GET"]
    - path: "src/app/api/orders/check-transfers/route.ts"
      provides: "Batch transfer status check"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/orders/[id]/check-transfer/route.ts"
      to: "prisma.order"
      via: "database query with requiredTransfer include"
      pattern: "prisma.order.findUnique.*requiredTransfer"
    - from: "src/app/api/orders/check-transfers/route.ts"
      to: "prisma.order"
      via: "batch database query with requiredTransfer include"
      pattern: "prisma.order.findMany.*requiredTransfer"
---

<objective>
Create API endpoint for pre-flight transfer status check

Purpose: Allow the UI to check transfer status before attempting invoice generation. This enables showing a confirmation modal without making the actual invoice API call fail.
Output: New GET endpoint at /api/orders/[id]/check-transfer
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-flow-integrity/04-CONTEXT.md
@.planning/phases/04-flow-integrity/04-RESEARCH.md
@.planning/phases/04-flow-integrity/04-01-SUMMARY.md
@src/app/api/orders/[id]/route.ts
@src/lib/invoice-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create check-transfer API endpoint</name>
  <files>src/app/api/orders/[id]/check-transfer/route.ts</files>
  <action>
  Create a new API route that checks if an order has a pending transfer:

  ```typescript
  import { NextRequest, NextResponse } from "next/server";
  import { getServerSession } from "next-auth";
  import { authOptions } from "@/lib/auth";
  import prisma from "@/lib/db";
  import { hasPermission } from "@/lib/permissions";

  interface TransferCheckResponse {
    orderId: string;
    orderNumber: string;
    hasUnfinishedTransfer: boolean;
    transfer?: {
      id: string;
      transferNumber: string;
      status: string;
      createdAt: string;
    };
    message?: string;
  }

  export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
  ) {
    try {
      const { id: orderId } = await params;

      // Verificăm autentificarea
      const session = await getServerSession(authOptions);
      if (!session?.user?.id) {
        return NextResponse.json(
          { error: "Trebuie să fii autentificat" },
          { status: 401 }
        );
      }

      // Verificăm permisiunea de vizualizare comenzi (sau facturi)
      const canView = await hasPermission(session.user.id, "orders.view");
      if (!canView) {
        return NextResponse.json(
          { error: "Nu ai permisiunea de a vizualiza comenzi" },
          { status: 403 }
        );
      }

      // Obținem comanda cu informații despre transfer
      const order = await prisma.order.findUnique({
        where: { id: orderId },
        select: {
          id: true,
          shopifyOrderNumber: true,
          requiredTransferId: true,
          requiredTransfer: {
            select: {
              id: true,
              transferNumber: true,
              status: true,
              createdAt: true,
            },
          },
        },
      });

      if (!order) {
        return NextResponse.json(
          { error: "Comanda nu a fost găsită" },
          { status: 404 }
        );
      }

      // Determinăm dacă are transfer nefinalizat
      const hasUnfinishedTransfer = !!(
        order.requiredTransferId &&
        order.requiredTransfer &&
        order.requiredTransfer.status !== "COMPLETED"
      );

      const response: TransferCheckResponse = {
        orderId: order.id,
        orderNumber: order.shopifyOrderNumber,
        hasUnfinishedTransfer,
      };

      if (hasUnfinishedTransfer && order.requiredTransfer) {
        response.transfer = {
          id: order.requiredTransfer.id,
          transferNumber: order.requiredTransfer.transferNumber,
          status: order.requiredTransfer.status,
          createdAt: order.requiredTransfer.createdAt.toISOString(),
        };
        response.message = `Atenție! Transferul #${order.requiredTransfer.transferNumber} nu e finalizat. Risc de eroare la facturare.`;
      }

      return NextResponse.json(response);
    } catch (error: any) {
      console.error("Error checking transfer status:", error);
      return NextResponse.json(
        { error: error.message || "Eroare la verificarea transferului" },
        { status: 500 }
      );
    }
  }
  ```

  Key aspects:
  - Uses the same auth pattern as other order API routes
  - Returns structured response with transfer details
  - Includes Romanian warning message matching CONTEXT.md
  </action>
  <verify>
  - `npm run build` passes
  - File exists at src/app/api/orders/[id]/check-transfer/route.ts
  - `curl` or API test shows proper response structure
  </verify>
  <done>
  - GET /api/orders/[id]/check-transfer endpoint exists
  - Returns hasUnfinishedTransfer boolean
  - Includes transfer details and warning message when applicable
  - Properly authenticated and permission-checked
  </done>
</task>

<task type="auto">
  <name>Task 2: Add batch check endpoint for multiple orders</name>
  <files>src/app/api/orders/check-transfers/route.ts</files>
  <action>
  Create a batch endpoint for checking multiple orders at once (useful for bulk invoice generation):

  ```typescript
  import { NextRequest, NextResponse } from "next/server";
  import { getServerSession } from "next-auth";
  import { authOptions } from "@/lib/auth";
  import prisma from "@/lib/db";
  import { hasPermission } from "@/lib/permissions";

  interface OrderTransferStatus {
    orderId: string;
    orderNumber: string;
    hasUnfinishedTransfer: boolean;
    transferNumber?: string;
    transferStatus?: string;
  }

  export async function POST(request: NextRequest) {
    try {
      // Verificăm autentificarea
      const session = await getServerSession(authOptions);
      if (!session?.user?.id) {
        return NextResponse.json(
          { error: "Trebuie să fii autentificat" },
          { status: 401 }
        );
      }

      // Verificăm permisiunea
      const canView = await hasPermission(session.user.id, "orders.view");
      if (!canView) {
        return NextResponse.json(
          { error: "Nu ai permisiunea de a vizualiza comenzi" },
          { status: 403 }
        );
      }

      const body = await request.json();
      const { orderIds } = body;

      if (!orderIds || !Array.isArray(orderIds) || orderIds.length === 0) {
        return NextResponse.json(
          { error: "Specifică cel puțin un orderId" },
          { status: 400 }
        );
      }

      // Limităm la 100 comenzi per request
      const limitedIds = orderIds.slice(0, 100);

      const orders = await prisma.order.findMany({
        where: { id: { in: limitedIds } },
        select: {
          id: true,
          shopifyOrderNumber: true,
          requiredTransferId: true,
          requiredTransfer: {
            select: {
              transferNumber: true,
              status: true,
            },
          },
        },
      });

      const results: OrderTransferStatus[] = orders.map((order) => {
        const hasUnfinishedTransfer = !!(
          order.requiredTransferId &&
          order.requiredTransfer &&
          order.requiredTransfer.status !== "COMPLETED"
        );

        return {
          orderId: order.id,
          orderNumber: order.shopifyOrderNumber,
          hasUnfinishedTransfer,
          ...(hasUnfinishedTransfer && order.requiredTransfer
            ? {
                transferNumber: order.requiredTransfer.transferNumber,
                transferStatus: order.requiredTransfer.status,
              }
            : {}),
        };
      });

      // Count how many have unfinished transfers
      const withPendingTransfer = results.filter((r) => r.hasUnfinishedTransfer);

      return NextResponse.json({
        orders: results,
        summary: {
          total: results.length,
          withPendingTransfer: withPendingTransfer.length,
          readyForInvoice: results.length - withPendingTransfer.length,
        },
      });
    } catch (error: any) {
      console.error("Error checking transfers:", error);
      return NextResponse.json(
        { error: error.message || "Eroare la verificarea transferurilor" },
        { status: 500 }
      );
    }
  }
  ```

  This batch endpoint is useful for the orders page where multiple orders can be selected for bulk invoice generation.
  </action>
  <verify>
  - `npm run build` passes
  - File exists at src/app/api/orders/check-transfers/route.ts
  </verify>
  <done>
  - POST /api/orders/check-transfers endpoint exists
  - Accepts array of orderIds
  - Returns per-order transfer status and summary
  - Limits to 100 orders per request
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `ls src/app/api/orders/*/check-transfer*/route.ts` shows both endpoints exist
3. Both endpoints follow existing auth patterns
</verification>

<success_criteria>
- Single order check endpoint at /api/orders/[id]/check-transfer
- Batch check endpoint at /api/orders/check-transfers
- Both return consistent transfer status information
- Both are authenticated and permission-checked
</success_criteria>

<output>
After completion, create `.planning/phases/04-flow-integrity/04-03-SUMMARY.md`
</output>
