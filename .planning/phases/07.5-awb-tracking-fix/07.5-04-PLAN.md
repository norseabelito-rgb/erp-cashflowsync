---
phase: 07.5-awb-tracking-fix
plan: 04
type: execute
wave: 2
depends_on: ["07.5-01"]
files_modified:
  - src/lib/dashboard-stats.ts
  - src/app/(dashboard)/settings/awb-statuses/page.tsx
  - src/app/api/settings/unknown-awb-statuses/route.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard 'Expediate' count matches tracking page 'In tranzit' counts exactly"
    - "Both dashboard and tracking use the same categorization logic from awb-status.ts"
    - "Admin settings page shows unknown AWB statuses logged in database"
    - "Admin can view and manage unknown status mappings"
  artifacts:
    - path: "src/lib/dashboard-stats.ts"
      provides: "Dashboard stats using unified categorization"
      exports: ["getFilteredDashboardStats"]
    - path: "src/app/(dashboard)/settings/awb-statuses/page.tsx"
      provides: "Admin page for viewing unknown AWB statuses"
      min_lines: 100
    - path: "src/app/api/settings/unknown-awb-statuses/route.ts"
      provides: "API for CRUD on unknown AWB statuses"
      exports: ["GET", "PATCH"]
  key_links:
    - from: "src/lib/dashboard-stats.ts"
      to: "src/lib/awb-status.ts"
      via: "getCategoryFilterConditions import"
      pattern: "import.*getCategoryFilterConditions.*from.*awb-status"
---

<objective>
Verify and ensure dashboard-tracking alignment, and create admin settings page for managing unknown AWB statuses.

Purpose: Dashboard "Expediate" card must show the same count as tracking page "In tranzit" statuses. Additionally, admins need visibility into unknown statuses so they can map new FanCourier codes as they appear.

Output: Verified dashboard-tracking alignment and functional admin page for unknown status management.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.5-awb-tracking-fix/07.5-CONTEXT.md
@.planning/phases/07.5-awb-tracking-fix/07.5-RESEARCH.md
@.planning/phases/07.5-awb-tracking-fix/07.5-01-SUMMARY.md
@src/lib/dashboard-stats.ts
@src/lib/awb-status.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify and update dashboard-stats.ts alignment</name>
  <files>src/lib/dashboard-stats.ts</files>
  <action>
Review and update src/lib/dashboard-stats.ts to ensure it uses the refactored awb-status.ts logic:

1. Verify the import is correct:
```typescript
import { getCategoryFilterConditions } from "@/lib/awb-status";
```

2. Verify the inTransit query uses getCategoryFilterConditions("in_transit"):
```typescript
// In transit AWBs (matches tracking page "In tranzit" count)
inTransit = await prisma.aWB.count({
  where: {
    createdAt: dateWhere,
    ...(filters.storeId && filters.storeId !== "all" && {
      order: { storeId: filters.storeId },
    }),
    OR: getCategoryFilterConditions("in_transit") || [],
  },
});
```

3. Add a secondary query using fanCourierStatusCode for verification:
```typescript
// Verify count matches code-based lookup
const inTransitByCode = await prisma.aWB.count({
  where: {
    createdAt: dateWhere,
    ...(filters.storeId && filters.storeId !== "all" && {
      order: { storeId: filters.storeId },
    }),
    fanCourierStatusCode: {
      in: Object.entries(FANCOURIER_STATUSES)
        .filter(([_, s]) => ["pickup", "transit", "delivery"].includes(s.category))
        .map(([code]) => code),
    },
  },
});

// Log if counts differ (indicates string matching found something code lookup missed)
if (inTransit !== inTransitByCode) {
  console.warn(`[Dashboard Stats] In Transit count mismatch: string=${inTransit}, code=${inTransitByCode}`);
}
```

4. Update returns query similarly to use getCategoryFilterConditions("returned").

This task ensures dashboard uses the same categorization as the refactored awb-status.ts.
  </action>
  <verify>
Run programmatic verification script to compare dashboard and tracking stats:

```bash
# Create and run verification script
cat > /tmp/verify-dashboard-tracking.ts << 'EOF'
// Run with: npx tsx /tmp/verify-dashboard-tracking.ts
import { PrismaClient } from '@prisma/client';
import { FANCOURIER_STATUSES } from '../src/lib/fancourier-statuses';

const prisma = new PrismaClient();

async function verify() {
  // Get in-transit codes from FANCOURIER_STATUSES
  const inTransitCodes = Object.entries(FANCOURIER_STATUSES)
    .filter(([_, s]) => ["pickup", "transit", "delivery"].includes(s.category))
    .map(([code]) => code);

  // Dashboard query (by code)
  const dashboardInTransit = await prisma.aWB.count({
    where: { fanCourierStatusCode: { in: inTransitCodes } }
  });

  // Tracking API query (groupBy code, sum transit categories)
  const statusCounts = await prisma.aWB.groupBy({
    by: ["fanCourierStatusCode"],
    _count: { id: true },
  });

  const trackingInTransit = statusCounts
    .filter(s => s.fanCourierStatusCode && inTransitCodes.includes(s.fanCourierStatusCode))
    .reduce((sum, s) => sum + s._count.id, 0);

  console.log('Dashboard In Transit:', dashboardInTransit);
  console.log('Tracking In Transit:', trackingInTransit);
  console.log('Match:', dashboardInTransit === trackingInTransit ? 'PASS' : 'FAIL');

  if (dashboardInTransit !== trackingInTransit) {
    process.exit(1);
  }

  await prisma.$disconnect();
}

verify().catch(e => { console.error(e); process.exit(1); });
EOF

npx tsx /tmp/verify-dashboard-tracking.ts
```

Alternative: Use curl to compare API responses:
```bash
# Fetch both endpoints and compare
DASHBOARD=$(curl -s http://localhost:3000/api/dashboard/stats | jq '.inTransit')
TRACKING=$(curl -s http://localhost:3000/api/awb/stats | jq '[.statusStats[] | select(.code | test("^[HC]|^S[013]$|^A[01]$")) | .count] | add')
echo "Dashboard: $DASHBOARD, Tracking: $TRACKING"
test "$DASHBOARD" = "$TRACKING" && echo "PASS" || echo "FAIL"
```
  </verify>
  <done>Dashboard stats uses unified categorization from awb-status.ts and counts match tracking page.</done>
</task>

<task type="auto">
  <name>Task 2: Create API for unknown AWB statuses</name>
  <files>src/app/api/settings/unknown-awb-statuses/route.ts</files>
  <action>
Create src/app/api/settings/unknown-awb-statuses/route.ts:

```typescript
import { NextRequest, NextResponse } from "next/server";
import prisma from "@/lib/db";

// GET: List all unknown AWB statuses
export async function GET() {
  const unknownStatuses = await prisma.unknownAWBStatus.findMany({
    orderBy: [
      { seenCount: "desc" },
      { lastSeenAt: "desc" },
    ],
  });

  return NextResponse.json({ unknownStatuses });
}

// PATCH: Update an unknown status (add mapping or notes)
export async function PATCH(request: NextRequest) {
  const body = await request.json();
  const { id, mappedCategory, mappedName, notes } = body;

  if (!id) {
    return NextResponse.json({ error: "ID is required" }, { status: 400 });
  }

  const updated = await prisma.unknownAWBStatus.update({
    where: { id },
    data: {
      mappedCategory,
      mappedName,
      notes,
    },
  });

  return NextResponse.json({ unknownStatus: updated });
}

// DELETE: Remove an unknown status entry
export async function DELETE(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const id = searchParams.get("id");

  if (!id) {
    return NextResponse.json({ error: "ID is required" }, { status: 400 });
  }

  await prisma.unknownAWBStatus.delete({
    where: { id },
  });

  return NextResponse.json({ success: true });
}
```

This API allows:
- GET: List all unknown statuses with counts
- PATCH: Update mapping/notes for a status
- DELETE: Remove an entry (if it was a false positive)
  </action>
  <verify>Call `curl http://localhost:3000/api/settings/unknown-awb-statuses` - should return JSON with unknownStatuses array.</verify>
  <done>Unknown AWB statuses API exists with GET, PATCH, DELETE methods.</done>
</task>

<task type="auto">
  <name>Task 3: Create admin settings page for unknown statuses</name>
  <files>src/app/(dashboard)/settings/awb-statuses/page.tsx</files>
  <action>
Create src/app/(dashboard)/settings/awb-statuses/page.tsx:

```typescript
"use client";

import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { formatDate } from "@/lib/utils";
import { AlertCircle, Save, Trash2, RefreshCw } from "lucide-react";

interface UnknownStatus {
  id: string;
  statusCode: string;
  statusName: string | null;
  firstSeenAt: string;
  lastSeenAt: string;
  seenCount: number;
  sampleAwbNumber: string | null;
  mappedCategory: string | null;
  mappedName: string | null;
  notes: string | null;
}

const CATEGORIES = [
  { value: "pickup", label: "Ridicare" },
  { value: "transit", label: "Tranzit" },
  { value: "delivery", label: "Livrare" },
  { value: "notice", label: "Avizare" },
  { value: "problem", label: "Problema" },
  { value: "return", label: "Retur" },
  { value: "cancel", label: "Anulat" },
  { value: "other", label: "Altele" },
];

export default function AWBStatusesPage() {
  const queryClient = useQueryClient();
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editData, setEditData] = useState<Partial<UnknownStatus>>({});

  const { data, isLoading, refetch } = useQuery({
    queryKey: ["unknown-awb-statuses"],
    queryFn: async () => {
      const res = await fetch("/api/settings/unknown-awb-statuses");
      return res.json();
    },
  });

  const updateMutation = useMutation({
    mutationFn: async (data: { id: string; mappedCategory?: string; mappedName?: string; notes?: string }) => {
      const res = await fetch("/api/settings/unknown-awb-statuses", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["unknown-awb-statuses"] });
      setEditingId(null);
      setEditData({});
    },
  });

  const deleteMutation = useMutation({
    mutationFn: async (id: string) => {
      const res = await fetch(`/api/settings/unknown-awb-statuses?id=${id}`, {
        method: "DELETE",
      });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["unknown-awb-statuses"] });
    },
  });

  const unknownStatuses: UnknownStatus[] = data?.unknownStatuses || [];

  const startEditing = (status: UnknownStatus) => {
    setEditingId(status.id);
    setEditData({
      mappedCategory: status.mappedCategory || "",
      mappedName: status.mappedName || "",
      notes: status.notes || "",
    });
  };

  const saveEdit = () => {
    if (editingId) {
      updateMutation.mutate({
        id: editingId,
        ...editData,
      });
    }
  };

  return (
    <div className="p-4 md:p-6 lg:p-8">
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold">Statusuri AWB Necunoscute</h1>
          <p className="text-muted-foreground mt-1">
            Statusuri FanCourier care nu sunt inca mapate in sistem
          </p>
        </div>
        <Button variant="outline" onClick={() => refetch()}>
          <RefreshCw className="h-4 w-4 mr-2" />
          Actualizeaza
        </Button>
      </div>

      {unknownStatuses.length === 0 ? (
        <Card>
          <CardContent className="p-12 text-center">
            <AlertCircle className="h-12 w-12 mx-auto mb-4 text-muted-foreground/50" />
            <p className="text-muted-foreground">
              Nu exista statusuri necunoscute. Toate statusurile FanCourier sunt mapate.
            </p>
          </CardContent>
        </Card>
      ) : (
        <Card>
          <CardHeader>
            <CardTitle>Statusuri Necunoscute ({unknownStatuses.length})</CardTitle>
            <CardDescription>
              Aceste coduri de status au fost primite de la FanCourier dar nu sunt in baza de date.
              Puteti adauga mapari manuale pentru a le categoriza corect.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Cod</TableHead>
                  <TableHead>Nume FanCourier</TableHead>
                  <TableHead>Vazut</TableHead>
                  <TableHead>Exemplu AWB</TableHead>
                  <TableHead>Categorie mapata</TableHead>
                  <TableHead>Nume mapat</TableHead>
                  <TableHead>Note</TableHead>
                  <TableHead className="text-right">Actiuni</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {unknownStatuses.map((status) => (
                  <TableRow key={status.id}>
                    <TableCell>
                      <Badge variant="outline" className="font-mono">
                        {status.statusCode}
                      </Badge>
                    </TableCell>
                    <TableCell>{status.statusName || "-"}</TableCell>
                    <TableCell>
                      <span className="text-sm">{status.seenCount}x</span>
                      <br />
                      <span className="text-xs text-muted-foreground">
                        {formatDate(status.lastSeenAt)}
                      </span>
                    </TableCell>
                    <TableCell className="font-mono text-xs">
                      {status.sampleAwbNumber || "-"}
                    </TableCell>
                    <TableCell>
                      {editingId === status.id ? (
                        <Select
                          value={editData.mappedCategory || ""}
                          onValueChange={(v) => setEditData({ ...editData, mappedCategory: v })}
                        >
                          <SelectTrigger className="w-32">
                            <SelectValue placeholder="Selecteaza" />
                          </SelectTrigger>
                          <SelectContent>
                            {CATEGORIES.map((cat) => (
                              <SelectItem key={cat.value} value={cat.value}>
                                {cat.label}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      ) : (
                        status.mappedCategory || "-"
                      )}
                    </TableCell>
                    <TableCell>
                      {editingId === status.id ? (
                        <Input
                          value={editData.mappedName || ""}
                          onChange={(e) => setEditData({ ...editData, mappedName: e.target.value })}
                          placeholder="Nume romanesc"
                          className="w-40"
                        />
                      ) : (
                        status.mappedName || "-"
                      )}
                    </TableCell>
                    <TableCell>
                      {editingId === status.id ? (
                        <Textarea
                          value={editData.notes || ""}
                          onChange={(e) => setEditData({ ...editData, notes: e.target.value })}
                          placeholder="Note..."
                          className="min-h-[60px] w-40"
                        />
                      ) : (
                        <span className="text-xs">{status.notes || "-"}</span>
                      )}
                    </TableCell>
                    <TableCell className="text-right">
                      {editingId === status.id ? (
                        <div className="flex gap-2 justify-end">
                          <Button size="sm" onClick={saveEdit}>
                            <Save className="h-4 w-4" />
                          </Button>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => setEditingId(null)}
                          >
                            Anuleaza
                          </Button>
                        </div>
                      ) : (
                        <div className="flex gap-2 justify-end">
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={() => startEditing(status)}
                          >
                            Editeaza
                          </Button>
                          <Button
                            size="sm"
                            variant="ghost"
                            className="text-destructive"
                            onClick={() => deleteMutation.mutate(status.id)}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      )}
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

The admin page:
- Lists all unknown statuses with counts and dates
- Shows sample AWB number for debugging
- Allows admin to assign category and Romanian name
- Supports notes for documentation
- Can delete false positives
  </action>
  <verify>Navigate to /settings/awb-statuses - page should load and show table (empty if no unknown statuses).</verify>
  <done>Admin settings page exists for managing unknown AWB statuses.</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Dashboard-Tracking alignment:
   - Load dashboard and note "Expediate" (In Tranzit) count
   - Load tracking page and count AWBs in transit-related status cards
   - Counts must match exactly

2. Unknown statuses admin page:
   - Navigate to /settings/awb-statuses
   - If no unknown statuses, page shows "Nu exista statusuri necunoscute"
   - If unknown statuses exist, they appear in table
   - Edit a status - add category and name - save works
   - Delete a status - confirmation and removal works

3. API functionality:
   - GET /api/settings/unknown-awb-statuses returns list
   - PATCH updates a status
   - DELETE removes a status
</verification>

<success_criteria>
- Dashboard "Expediate" count matches tracking "In Tranzit" total
- dashboard-stats.ts imports and uses getCategoryFilterConditions from awb-status.ts
- /api/settings/unknown-awb-statuses API exists with GET, PATCH, DELETE
- /settings/awb-statuses page exists and functions
- Admin can view, edit, and delete unknown status entries
- Empty state shown when no unknown statuses exist
</success_criteria>

<output>
After completion, create `.planning/phases/07.5-awb-tracking-fix/07.5-04-SUMMARY.md`
</output>
