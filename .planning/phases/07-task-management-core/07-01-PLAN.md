---
phase: 07-task-management-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/task-utils.ts
autonomous: true

must_haves:
  truths:
    - "Task model exists in database with all required fields"
    - "Task types (PICKING, VERIFICARE, EXPEDIERE, etc.) are enumerated"
    - "Priority levels (LOW, MEDIUM, HIGH, URGENT) are enumerated"
    - "Tasks can link to Order, Product, or Invoice"
    - "Date grouping helper returns correct groups (overdue, today, tomorrow, this_week, later)"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Task and TaskAttachment models"
      contains: "model Task"
    - path: "src/lib/task-utils.ts"
      provides: "Date grouping and priority sorting helpers"
      exports: ["groupTasksByDate", "DATE_GROUP_LABELS", "PRIORITY_ORDER", "sortTasksByPriority"]
  key_links:
    - from: "prisma/schema.prisma"
      to: "User model"
      via: "assigneeId, createdById, completedById relations"
      pattern: "@relation.*TaskAssignee|TaskCreator|TaskCompleter"
    - from: "prisma/schema.prisma"
      to: "Order, MasterProduct, Invoice models"
      via: "linkedOrderId, linkedProductId, linkedInvoiceId"
      pattern: "linked(Order|Product|Invoice)Id"
---

<objective>
Create the Task data model and utility helpers for the task management system.

Purpose: Establish the database foundation and helper functions that all other task management features depend on.
Output: Prisma schema with Task/TaskAttachment models + task-utils.ts with date grouping and sorting helpers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-task-management-core/07-CONTEXT.md
@.planning/phases/07-task-management-core/07-RESEARCH.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Task enums and models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following to the Prisma schema after the existing models:

1. Add three enums:
   - TaskType: PICKING, VERIFICARE, EXPEDIERE, MEETING, DEADLINE, FOLLOW_UP, BUSINESS, OTHER
   - TaskPriority: LOW, MEDIUM, HIGH, URGENT
   - TaskStatus: PENDING, COMPLETED

2. Add Task model with fields:
   - id: String @id @default(cuid())
   - title: String
   - description: String? @db.Text
   - type: TaskType @default(BUSINESS)
   - priority: TaskPriority @default(MEDIUM)
   - status: TaskStatus @default(PENDING)
   - deadline: DateTime? (optional per CONTEXT.md)
   - assigneeId: String? with User relation "TaskAssignee"
   - createdById: String with User relation "TaskCreator"
   - linkedOrderId: String? with Order relation
   - linkedProductId: String? with MasterProduct relation
   - linkedInvoiceId: String? with Invoice relation
   - completedAt: DateTime?
   - completedById: String? with User relation "TaskCompleter"
   - reassignmentNote: String? @db.Text
   - attachments: TaskAttachment[]
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt
   - Add indexes on: assigneeId, status, deadline, type, and composite (priority, deadline)
   - Map to "tasks" table

3. Add TaskAttachment model with fields:
   - id: String @id @default(cuid())
   - taskId: String with Task relation (onDelete: Cascade)
   - filename: String
   - storagePath: String
   - mimeType: String
   - size: Int
   - uploadedById: String with User relation
   - createdAt: DateTime @default(now())
   - Add index on taskId
   - Map to "task_attachments" table

4. Update User model to add the reverse relations:
   - tasksAssigned: Task[] @relation("TaskAssignee")
   - tasksCreated: Task[] @relation("TaskCreator")
   - tasksCompleted: Task[] @relation("TaskCompleter")
   - taskAttachments: TaskAttachment[]

5. Add reverse relations to Order, MasterProduct, and Invoice models:
   - tasks: Task[] (on each model)

IMPORTANT: Match existing codebase patterns for model structure (see AWBComment, Invoice models as reference).
  </action>
  <verify>Run `npx prisma validate` - should return with no errors</verify>
  <done>Prisma schema contains Task, TaskAttachment models with all enums and relations</done>
</task>

<task type="auto">
  <name>Task 2: Run database migration</name>
  <files>prisma/migrations/</files>
  <action>
Generate and run the Prisma migration for the new Task models:

1. Run `npx prisma migrate dev --name add-task-management`
2. This creates the migration file and applies it to the database
3. Run `npx prisma generate` to regenerate the Prisma client

If migration fails due to existing data constraints, check the error and resolve accordingly.
  </action>
  <verify>Run `npx prisma db pull` followed by `npx prisma validate` - both should succeed with no errors</verify>
  <done>Database has tasks and task_attachments tables with all columns and indexes</done>
</task>

<task type="auto">
  <name>Task 3: Create task-utils.ts helper functions</name>
  <files>src/lib/task-utils.ts</files>
  <action>
Create a new file `src/lib/task-utils.ts` with the following exports:

1. PRIORITY_ORDER constant:
   - Map TaskPriority values to numeric order for sorting
   - URGENT: 0, HIGH: 1, MEDIUM: 2, LOW: 3 (lower = higher priority)

2. DATE_GROUP_LABELS constant (Romanian, no diacritics):
   - overdue: "Intarziate"
   - today: "Astazi"
   - tomorrow: "Maine"
   - this_week: "Saptamana aceasta"
   - later: "Mai tarziu"
   - no_deadline: "Fara deadline"
   - completed: "Finalizate"

3. groupTasksByDate function:
   - Input: array of tasks with deadline (string | null) and status fields
   - Output: Record<DateGroup, Task[]>
   - Logic:
     a. If status === "COMPLETED" -> completed group
     b. If no deadline -> no_deadline group
     c. If deadline < today (start of day) -> overdue
     d. If isToday(deadline) -> today
     e. If isTomorrow(deadline) -> tomorrow
     f. If isThisWeek(deadline) -> this_week
     g. Otherwise -> later

4. sortTasksByPriority function:
   - Input: array of tasks with priority field
   - Output: sorted array (URGENT first, then HIGH, MEDIUM, LOW)
   - Use PRIORITY_ORDER for comparison

5. isOverdue helper:
   - Input: deadline string
   - Output: boolean
   - Returns true if deadline is before start of today

Use date-fns for date comparisons (isToday, isTomorrow, isThisWeek, isBefore, startOfDay).
Import from "date-fns".

Add TypeScript types for DateGroup and the task interface shape used by these functions.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>task-utils.ts exports groupTasksByDate, DATE_GROUP_LABELS, PRIORITY_ORDER, sortTasksByPriority, and isOverdue</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx prisma db pull && npx prisma validate` passes (database schema matches)
3. `npx tsc --noEmit` passes (TypeScript compiles)
4. Task enums visible in schema: TaskType, TaskPriority, TaskStatus
5. Task model has all required fields including linked entity relations
6. User model has reverse relations for tasks
</verification>

<success_criteria>
- Database has tasks table with columns: id, title, description, type, priority, status, deadline, assignee_id, created_by_id, linked_order_id, linked_product_id, linked_invoice_id, completed_at, completed_by_id, reassignment_note, created_at, updated_at
- Database has task_attachments table with columns: id, task_id, filename, storage_path, mime_type, size, uploaded_by_id, created_at
- task-utils.ts compiles and exports all helper functions
- All TypeScript types are properly defined
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-management-core/07-01-SUMMARY.md`
</output>
