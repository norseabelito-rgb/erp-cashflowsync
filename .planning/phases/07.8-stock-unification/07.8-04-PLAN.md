---
phase: 07.8-stock-unification
plan: 04
type: execute
wave: 2
depends_on: ["07.8-01"]
files_modified:
  - src/app/api/picking/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Picking stock deduction uses InventoryItem.currentStock instead of MasterProduct.stock"
    - "InventoryStockMovement records created when items are picked"
    - "Picking uses deductInventoryStockFromWarehouse() for stock updates"
    - "Fallback to MasterProduct.stock for unmapped products with warning log"
  artifacts:
    - path: "src/app/api/picking/[id]/route.ts"
      provides: "Picking API with NEW stock system"
      contains: "deductInventoryStockFromWarehouse"
  key_links:
    - from: "src/app/api/picking/[id]/route.ts"
      to: "deductInventoryStockFromWarehouse"
      via: "import and function call"
      pattern: "import.*deductInventoryStockFromWarehouse.*from.*inventory-stock"
    - from: "picking route"
      to: "InventoryItem.currentStock"
      via: "deductInventoryStockFromWarehouse"
      pattern: "await deductInventoryStockFromWarehouse"
---

<objective>
Migrate picking list stock deduction to use the NEW stock system.

Purpose: Currently picking directly updates MasterProduct.stock without creating any movement records. This migrates to use deductInventoryStockFromWarehouse() which updates InventoryItem.currentStock via WarehouseStock and creates proper audit trail with InventoryStockMovement records.

Output: Picking operations update InventoryItem.currentStock and create movement records for full traceability.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.8-stock-unification/07.8-RESEARCH.md
@.planning/phases/07.8-stock-unification/07.8-01-SUMMARY.md

# Key source files
@src/app/api/picking/[id]/route.ts
@src/lib/inventory-stock.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports for inventory-stock functions</name>
  <files>src/app/api/picking/[id]/route.ts</files>
  <action>
Add the necessary imports at the top of the file:

```typescript
import { deductInventoryStockFromWarehouse, getPrimaryWarehouse } from "@/lib/inventory-stock";
```

Place this with the other imports at the top of the file.

Note: The picking route likely already imports from @/lib/db (prisma). Add the new import near other library imports.
  </action>
  <verify>
`grep "deductInventoryStockFromWarehouse" src/app/api/picking/[id]/route.ts | grep import`
  </verify>
  <done>Import statements added for deductInventoryStockFromWarehouse and getPrimaryWarehouse</done>
</task>

<task type="auto">
  <name>Task 2: Replace MasterProduct.stock update with inventory-stock function</name>
  <files>src/app/api/picking/[id]/route.ts</files>
  <action>
Find the stock deduction code block (around lines 192-221) and replace it.

Current code pattern:
```typescript
// 2. Decrementam stocul din MasterProduct (daca exista legatura)
if (item.masterProductId && quantityToDeduct > 0) {
  const masterProduct = await tx.masterProduct.findUnique({
    where: { id: item.masterProductId },
    select: { id: true, stock: true },
  });

  if (masterProduct) {
    await tx.masterProduct.update({
      where: { id: item.masterProductId },
      data: {
        stock: Math.max(0, masterProduct.stock - quantityToDeduct),
      },
    });
  }
} else if (!item.masterProductId && item.sku && quantityToDeduct > 0) {
  // Try to find by SKU
  const masterProduct = await tx.masterProduct.findUnique({
    where: { sku: item.sku },
    select: { id: true, stock: true },
  });

  if (masterProduct) {
    await tx.masterProduct.update({
      where: { id: masterProduct.id },
      data: {
        stock: Math.max(0, masterProduct.stock - quantityToDeduct),
      },
    });
  }
}
```

Replace with:
```typescript
// 2. Decrementam stocul din InventoryItem (NEW system)
if (quantityToDeduct > 0) {
  // Get the masterProduct with inventoryItem link
  let masterProduct = null;
  if (item.masterProductId) {
    masterProduct = await tx.masterProduct.findUnique({
      where: { id: item.masterProductId },
      select: { id: true, sku: true, stock: true, inventoryItemId: true },
    });
  } else if (item.sku) {
    masterProduct = await tx.masterProduct.findUnique({
      where: { sku: item.sku },
      select: { id: true, sku: true, stock: true, inventoryItemId: true },
    });
  }

  if (masterProduct?.inventoryItemId) {
    // Use NEW inventory system
    const primaryWarehouse = await getPrimaryWarehouse();
    if (primaryWarehouse) {
      // Note: deductInventoryStockFromWarehouse handles transactions internally,
      // but we're already in a transaction, so we call it outside the tx block
      // Actually, we should call it after the transaction for the PickingListItem update
    }
  } else if (masterProduct) {
    // Fallback for unmapped products (log warning, use old behavior temporarily)
    console.warn(`[Picking] MasterProduct ${masterProduct.sku} not mapped to InventoryItem - using legacy stock`);
    await tx.masterProduct.update({
      where: { id: masterProduct.id },
      data: {
        stock: Math.max(0, masterProduct.stock - quantityToDeduct),
      },
    });
  }
}
```

IMPORTANT: The deductInventoryStockFromWarehouse function uses its own transaction. Since the picking route is already in a transaction for PickingListItem update, we need to:
1. Keep the PickingListItem update inside the existing transaction
2. Call deductInventoryStockFromWarehouse AFTER the transaction commits (or make it part of the tx)

Refactor approach:
- Move the stock deduction OUTSIDE the prisma.$transaction block
- Call it after the PickingListItem update succeeds
- This ensures the picking item is updated even if stock deduction has issues (non-blocking pattern like invoice-service)

The refactored structure should be:
```typescript
// Inside transaction: update PickingListItem only
const [updatedItem] = await prisma.$transaction(async (tx) => {
  // ... PickingListItem update logic
  return [updated];
});

// Outside transaction: deduct stock (non-blocking)
if (quantityToDeduct > 0) {
  try {
    let masterProduct = null;
    if (item.masterProductId) {
      masterProduct = await prisma.masterProduct.findUnique({
        where: { id: item.masterProductId },
        select: { id: true, sku: true, stock: true, inventoryItemId: true },
      });
    } else if (item.sku) {
      masterProduct = await prisma.masterProduct.findUnique({
        where: { sku: item.sku },
        select: { id: true, sku: true, stock: true, inventoryItemId: true },
      });
    }

    if (masterProduct?.inventoryItemId) {
      const primaryWarehouse = await getPrimaryWarehouse();
      if (primaryWarehouse) {
        const stockResult = await deductInventoryStockFromWarehouse(
          masterProduct.inventoryItemId,
          primaryWarehouse.id,
          quantityToDeduct,
          { reason: `Picking - ${pickingList.code}, Item: ${item.title}` }
        );
        if (!stockResult.success) {
          console.warn(`[Picking] Stock deduction warning: ${stockResult.error}`);
        }
      }
    } else if (masterProduct) {
      // Legacy fallback
      console.warn(`[Picking] MasterProduct ${masterProduct.sku} not mapped to InventoryItem`);
      await prisma.masterProduct.update({
        where: { id: masterProduct.id },
        data: { stock: Math.max(0, masterProduct.stock - quantityToDeduct) },
      });
    }
  } catch (stockError) {
    // Non-blocking - picking item was updated, stock can be corrected manually
    console.error("[Picking] Error deducting stock:", stockError);
  }
}
```
  </action>
  <verify>
`grep "deductInventoryStockFromWarehouse" src/app/api/picking/[id]/route.ts | grep -v import`
`grep "inventoryItemId" src/app/api/picking/[id]/route.ts`
  </verify>
  <done>Stock deduction refactored to use deductInventoryStockFromWarehouse for mapped products, with fallback for unmapped</done>
</task>

<task type="auto">
  <name>Task 3: Verify TypeScript compilation</name>
  <files>src/app/api/picking/[id]/route.ts</files>
  <action>
1. Run TypeScript compilation: `npx tsc --noEmit src/app/api/picking/[id]/route.ts`
2. Fix any type errors that appear
3. Verify the picking route still works logically:
   - PickingListItem update happens first (in transaction)
   - Stock deduction happens after (non-blocking)
   - Fallback exists for unmapped products

Common issues to watch for:
- getPrimaryWarehouse returns Promise, need await
- deductInventoryStockFromWarehouse returns { success, error, movements }
- Make sure quantityToDeduct variable is accessible outside transaction if moved
  </action>
  <verify>
`npx tsc --noEmit` completes without errors
  </verify>
  <done>TypeScript compiles, picking route fully migrated to use NEW stock system with proper fallback</done>
</task>

</tasks>

<verification>
After completion:
1. `grep "import.*deductInventoryStockFromWarehouse.*inventory-stock" src/app/api/picking/[id]/route.ts` returns a match
2. `grep "await deductInventoryStockFromWarehouse" src/app/api/picking/[id]/route.ts` returns a match
3. `grep "inventoryItemId" src/app/api/picking/[id]/route.ts` returns a match (checking for mapping)
4. `npx tsc --noEmit` completes without errors
5. Fallback code exists for unmapped products with warning log
</verification>

<success_criteria>
- picking/[id]/route.ts imports deductInventoryStockFromWarehouse and getPrimaryWarehouse
- Stock deduction uses NEW inventory system for mapped products
- Fallback to legacy MasterProduct.stock for unmapped products (with warning log)
- Stock deduction is non-blocking (picking succeeds even if stock deduction fails)
- InventoryStockMovement records created for picked items
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.8-stock-unification/07.8-04-SUMMARY.md`
</output>
