---
phase: 07.8-stock-unification
plan: 04
type: execute
wave: 2
depends_on: ["07.8-01"]
files_modified:
  - src/app/api/picking/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Picking stock deduction uses InventoryItem.currentStock instead of MasterProduct.stock"
    - "InventoryStockMovement records created when items are picked"
    - "Picking uses deductInventoryStockFromWarehouse() for stock updates"
    - "Fallback to MasterProduct.stock for unmapped products with warning log"
    - "Stock deduction is non-blocking - picking succeeds even if stock operations fail"
  artifacts:
    - path: "src/app/api/picking/[id]/route.ts"
      provides: "Picking API with NEW stock system"
      contains: "deductInventoryStockFromWarehouse"
  key_links:
    - from: "src/app/api/picking/[id]/route.ts"
      to: "deductInventoryStockFromWarehouse"
      via: "import and function call"
      pattern: "import.*deductInventoryStockFromWarehouse.*from.*inventory-stock"
    - from: "picking route"
      to: "InventoryItem.currentStock"
      via: "deductInventoryStockFromWarehouse"
      pattern: "await deductInventoryStockFromWarehouse"
---

<objective>
Migrate picking list stock deduction to use the NEW stock system.

Purpose: Currently picking directly updates MasterProduct.stock without creating any movement records. This migrates to use deductInventoryStockFromWarehouse() which updates InventoryItem.currentStock via WarehouseStock and creates proper audit trail with InventoryStockMovement records.

Output: Picking operations update InventoryItem.currentStock and create movement records for full traceability.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.8-stock-unification/07.8-RESEARCH.md
@.planning/phases/07.8-stock-unification/07.8-01-SUMMARY.md

# Key source files
@src/app/api/picking/[id]/route.ts
@src/lib/inventory-stock.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports for inventory-stock functions</name>
  <files>src/app/api/picking/[id]/route.ts</files>
  <action>
Add the necessary imports at the top of the file:

```typescript
import { deductInventoryStockFromWarehouse, getPrimaryWarehouse } from "@/lib/inventory-stock";
```

Place this with the other imports at the top of the file.

Note: The picking route likely already imports from @/lib/db (prisma). Add the new import near other library imports.
  </action>
  <verify>
`grep "deductInventoryStockFromWarehouse" src/app/api/picking/[id]/route.ts | grep import`
  </verify>
  <done>Import statements added for deductInventoryStockFromWarehouse and getPrimaryWarehouse</done>
</task>

<task type="auto">
  <name>Task 2: Replace MasterProduct.stock update with inventory-stock function (non-blocking)</name>
  <files>src/app/api/picking/[id]/route.ts</files>
  <action>
Find the stock deduction code block (around lines 192-221) and replace it.

Current code pattern:
```typescript
// 2. Decrementam stocul din MasterProduct (daca exista legatura)
if (item.masterProductId && quantityToDeduct > 0) {
  const masterProduct = await tx.masterProduct.findUnique({
    where: { id: item.masterProductId },
    select: { id: true, stock: true },
  });

  if (masterProduct) {
    await tx.masterProduct.update({
      where: { id: item.masterProductId },
      data: {
        stock: Math.max(0, masterProduct.stock - quantityToDeduct),
      },
    });
  }
} else if (!item.masterProductId && item.sku && quantityToDeduct > 0) {
  // Try to find by SKU
  const masterProduct = await tx.masterProduct.findUnique({
    where: { sku: item.sku },
    select: { id: true, stock: true },
  });

  if (masterProduct) {
    await tx.masterProduct.update({
      where: { id: masterProduct.id },
      data: {
        stock: Math.max(0, masterProduct.stock - quantityToDeduct),
      },
    });
  }
}
```

IMPORTANT - NON-BLOCKING PATTERN:
The stock deduction MUST be non-blocking. This means:
1. Picking item update (PickingListItem status change) MUST succeed regardless of stock errors
2. Stock deduction errors should be caught and logged, NOT thrown
3. The picking operation completes successfully even if stock deduction fails

Refactored structure - move stock deduction OUTSIDE the transaction with try-catch:
```typescript
// Inside transaction: update PickingListItem only
const [updatedItem] = await prisma.$transaction(async (tx) => {
  // ... PickingListItem update logic
  return [updated];
});

// Outside transaction: deduct stock (NON-BLOCKING - errors logged, not thrown)
if (quantityToDeduct > 0) {
  try {
    let masterProduct = null;
    if (item.masterProductId) {
      masterProduct = await prisma.masterProduct.findUnique({
        where: { id: item.masterProductId },
        select: { id: true, sku: true, stock: true, inventoryItemId: true },
      });
    } else if (item.sku) {
      masterProduct = await prisma.masterProduct.findUnique({
        where: { sku: item.sku },
        select: { id: true, sku: true, stock: true, inventoryItemId: true },
      });
    }

    if (masterProduct?.inventoryItemId) {
      const primaryWarehouse = await getPrimaryWarehouse();
      if (primaryWarehouse) {
        const stockResult = await deductInventoryStockFromWarehouse(
          masterProduct.inventoryItemId,
          primaryWarehouse.id,
          quantityToDeduct,
          { reason: `Picking - ${pickingList.code}, Item: ${item.title}` }
        );
        if (!stockResult.success) {
          // Log warning but DO NOT throw - picking already succeeded
          console.warn(`[Picking] Stock deduction warning for ${masterProduct.sku}: ${stockResult.error}`);
        }
      }
    } else if (masterProduct) {
      // Legacy fallback for unmapped products
      console.warn(`[Picking] MasterProduct ${masterProduct.sku} not mapped to InventoryItem - using legacy stock`);
      await prisma.masterProduct.update({
        where: { id: masterProduct.id },
        data: { stock: Math.max(0, masterProduct.stock - quantityToDeduct) },
      });
    }
  } catch (stockError) {
    // NON-BLOCKING: picking item was already updated successfully
    // Stock discrepancy can be corrected manually via inventory adjustment
    console.error("[Picking] Stock deduction error (non-blocking):", stockError);
    // DO NOT re-throw - picking must succeed even if stock ops fail
  }
}
```

KEY POINTS:
- The try-catch wraps the ENTIRE stock deduction block
- Errors are logged with console.error but NEVER re-thrown
- The picking operation (PickingListItem update) happens BEFORE stock deduction
- If stock deduction fails, picking still succeeds - stock can be corrected later
  </action>
  <verify>
`grep "deductInventoryStockFromWarehouse" src/app/api/picking/[id]/route.ts | grep -v import`
`grep "inventoryItemId" src/app/api/picking/[id]/route.ts`
`grep "catch.*stockError" src/app/api/picking/[id]/route.ts` - confirms try-catch wrapper exists
  </verify>
  <done>Stock deduction refactored to use deductInventoryStockFromWarehouse with non-blocking pattern - picking succeeds even if stock operations fail, errors are caught and logged</done>
</task>

<task type="auto">
  <name>Task 3: Verify TypeScript compilation</name>
  <files>src/app/api/picking/[id]/route.ts</files>
  <action>
1. Run TypeScript compilation: `npx tsc --noEmit src/app/api/picking/[id]/route.ts`
2. Fix any type errors that appear
3. Verify the picking route still works logically:
   - PickingListItem update happens first (in transaction)
   - Stock deduction happens after (non-blocking, wrapped in try-catch)
   - Fallback exists for unmapped products
   - Errors are logged but never thrown

Common issues to watch for:
- getPrimaryWarehouse returns Promise, need await
- deductInventoryStockFromWarehouse returns { success, error, movements }
- Make sure quantityToDeduct variable is accessible outside transaction if moved
  </action>
  <verify>
`npx tsc --noEmit` completes without errors
  </verify>
  <done>TypeScript compiles, picking route fully migrated to use NEW stock system with non-blocking pattern and proper fallback</done>
</task>

</tasks>

<verification>
After completion:
1. `grep "import.*deductInventoryStockFromWarehouse.*inventory-stock" src/app/api/picking/[id]/route.ts` returns a match
2. `grep "await deductInventoryStockFromWarehouse" src/app/api/picking/[id]/route.ts` returns a match
3. `grep "inventoryItemId" src/app/api/picking/[id]/route.ts` returns a match (checking for mapping)
4. `grep "catch.*stockError\|Stock deduction error" src/app/api/picking/[id]/route.ts` returns a match (non-blocking error handling)
5. `npx tsc --noEmit` completes without errors
6. Fallback code exists for unmapped products with warning log
</verification>

<success_criteria>
- picking/[id]/route.ts imports deductInventoryStockFromWarehouse and getPrimaryWarehouse
- Stock deduction uses NEW inventory system for mapped products
- Fallback to legacy MasterProduct.stock for unmapped products (with warning log)
- Stock deduction is non-blocking - picking succeeds even if stock deduction fails
- Stock errors are caught and logged (console.error), NEVER re-thrown
- InventoryStockMovement records created for picked items
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.8-stock-unification/07.8-04-SUMMARY.md`
</output>
