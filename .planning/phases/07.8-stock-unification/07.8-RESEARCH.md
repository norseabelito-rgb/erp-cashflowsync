# Phase 7.8: Stock Unification - Research

**Researched:** 2026-02-05
**Domain:** Internal stock system migration (no external libraries)
**Confidence:** HIGH

## Summary

This phase addresses a critical internal architecture issue: two parallel stock systems that don't synchronize. The "OLD" system (`Product.stockQuantity` + `StockMovement`) is used by invoice generation, returns, and picking. The "NEW" system (`InventoryItem.currentStock` + `InventoryStockMovement` + `WarehouseStock`) is used by NIR/GoodsReceipt. When goods are received via NIR, the stock goes into InventoryItem, but when orders are invoiced or picked, the system reads/writes from Product/MasterProduct - causing permanent desync.

The solution is straightforward: migrate all stock-consuming flows to use the NEW system. Critically, `processInventoryStockForOrderFromPrimary()` already exists and is fully functional (inventory-stock.ts:1068-1216). The migration involves:
1. Creating `addInventoryStockForReturn()` to mirror the deduction logic
2. Replacing `processStockForOrder()` calls with `processInventoryStockForOrderFromPrimary()`
3. Replacing `processStockReturnForOrder()` calls with `addInventoryStockForReturn()`
4. Updating picking to decrement `InventoryItem.currentStock` instead of `MasterProduct.stock`
5. Ensuring all MasterProducts are mapped to InventoryItems via `inventoryItemId`

**Primary recommendation:** Use existing `processInventoryStockForOrderFromPrimary()` for invoice stock deduction, create parallel `addInventoryStockForReturn()` for returns, and update picking to use the same InventoryItem system.

## Standard Stack

This phase involves internal refactoring only - no new libraries required.

### Core
| Component | Location | Purpose | Status |
|-----------|----------|---------|--------|
| inventory-stock.ts | src/lib/inventory-stock.ts | NEW stock system functions | EXISTS, USE THIS |
| stock.ts | src/lib/stock.ts | OLD stock system functions | EXISTS, DEPRECATE |
| Prisma | prisma/schema.prisma | Data models | EXISTS |

### Functions to Use (Already Exist)
| Function | File | Lines | Purpose |
|----------|------|-------|---------|
| `processInventoryStockForOrderFromPrimary()` | inventory-stock.ts | 1068-1216 | Deduct stock for order from primary warehouse |
| `deductInventoryStockFromWarehouse()` | inventory-stock.ts | 809-1042 | Low-level warehouse stock deduction |
| `getPrimaryWarehouse()` | inventory-stock.ts | 620-628 | Get primary warehouse for stock operations |
| `deductInventoryStock()` | inventory-stock.ts | 226-356 | Direct InventoryItem stock deduction |

### Functions to Create
| Function | File | Purpose | Based On |
|----------|------|---------|----------|
| `addInventoryStockForReturn()` | inventory-stock.ts | Add stock back for returns | Mirror of `processInventoryStockForOrderFromPrimary()` |
| `addInventoryStockFromWarehouse()` | inventory-stock.ts | Low-level warehouse stock addition | Mirror of `deductInventoryStockFromWarehouse()` |

### Functions to Deprecate (Keep but Mark)
| Function | File | Replacement |
|----------|------|-------------|
| `processStockForOrder()` | stock.ts | `processInventoryStockForOrderFromPrimary()` |
| `processStockReturnForOrder()` | stock.ts | `addInventoryStockForReturn()` |
| `recordStockMovement()` | stock.ts | `InventoryStockMovement` creation |

## Architecture Patterns

### Current Dual System Structure

```
LEGACY SYSTEM (stock.ts)                    NEW SYSTEM (inventory-stock.ts)
================================            ================================
Product.stockQuantity                       InventoryItem.currentStock
    |                                           |
    v                                           v
StockMovement                               InventoryStockMovement
(type: IN/OUT)                              (type: SALE/RETURN/TRANSFER/etc)
    |                                           |
    +-- MasterProduct.stock (synced)            +-- WarehouseStock.currentStock
                                                    (per warehouse)
```

### Target Unified System

```
UNIFIED SYSTEM (inventory-stock.ts only)
=========================================
InventoryItem.currentStock  <-- Source of Truth
    |
    v
InventoryStockMovement
    |
    v
WarehouseStock.currentStock (per warehouse)
    |
    v
MasterProduct.inventoryItemId --> links to InventoryItem (for channel sync)
```

### Pattern 1: Stock Deduction (Invoice Generation)

**Current (invoice-service.ts:725):**
```typescript
// LEGACY - uses Product.stockQuantity
const stockResult = await processStockForOrder(order.id, savedInvoice.id);
```

**Target:**
```typescript
// NEW - uses InventoryItem.currentStock via primary warehouse
const stockResult = await processInventoryStockForOrderFromPrimary(order.id, savedInvoice.id);
```

### Pattern 2: Stock Addition (Returns)

**Current (returns.ts:123, reprocess-stock/route.ts:62):**
```typescript
// LEGACY - adds to Product.stockQuantity
const stockResult = await processStockReturnForOrder(orderId, returnAwbId);
```

**Target:**
```typescript
// NEW - adds to InventoryItem.currentStock
const stockResult = await addInventoryStockForReturn(orderId, returnAwbId);
```

### Pattern 3: Picking Stock Decrement

**Current (picking/[id]/route.ts:199-220):**
```typescript
// LEGACY - decrements MasterProduct.stock directly
await tx.masterProduct.update({
  where: { id: item.masterProductId },
  data: {
    stock: Math.max(0, masterProduct.stock - quantityToDeduct),
  },
});
```

**Target:**
```typescript
// NEW - use inventory-stock.ts function to decrement InventoryItem
const result = await deductInventoryStockFromWarehouse(
  masterProduct.inventoryItemId,
  primaryWarehouse.id,
  quantityToDeduct,
  { reason: `Picking - ${pickingListCode}` }
);
```

### Anti-Patterns to Avoid

- **Direct Model Updates:** Never update `InventoryItem.currentStock` or `WarehouseStock.currentStock` directly. Always use the functions in `inventory-stock.ts` that create proper movement records.

- **Mixed System Usage:** Don't use OLD functions for some operations and NEW for others within the same flow. Migrate entire flows at once.

- **Deleting Old Code:** Mark as `@deprecated` but don't delete. Other parts of system may still reference for backward compatibility.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Stock deduction | Custom decrement logic | `deductInventoryStockFromWarehouse()` | Handles transactions, movements, composite items, warehouse totals |
| Stock addition | Custom increment logic | Create `addInventoryStockFromWarehouse()` following existing pattern | Same reasons as above |
| Composite item handling | Manual recipe iteration | Existing `recipeComponents` handling in inventory-stock.ts | Already handles nested recipes, quantity multiplication |
| Warehouse total sync | Manual SUM queries | Existing `syncItemTotalStock()` | Transaction-safe, called automatically |

**Key insight:** The NEW system already handles all the edge cases (composite items, multi-warehouse, transactions, movement logging). The OLD system was simpler but incomplete.

## Common Pitfalls

### Pitfall 1: Forgetting MasterProduct->InventoryItem Mapping

**What goes wrong:** SKUs exist in MasterProduct but have no `inventoryItemId`, causing stock operations to skip them silently.

**Why it happens:** MasterProduct records were created before InventoryItem system existed.

**How to avoid:** Migration script (07.8-05) must create InventoryItems for unmapped MasterProducts and set the `inventoryItemId` relationship.

**Warning signs:**
- "nu este mapat la inventar - skip" log messages
- `result.skipped` count high in stock processing results

### Pitfall 2: Breaking Trendyol/Temu Stock Sync

**What goes wrong:** Stock sync to channels stops working or reports wrong quantities.

**Why it happens:** Trendyol/Temu sync already uses InventoryItem with fallback to MasterProduct.stock.

**How to avoid:** The existing fallback pattern in trendyol-stock-sync.ts:121-128 is correct:
```typescript
// Get stock from linked InventoryItem if available
const inventoryStock = product.inventoryItem
  ? Number(product.inventoryItem.currentStock)
  : 0;
// Fall back to MasterProduct.stock if no inventory item linked
const finalStock = inventoryStock > 0 ? inventoryStock : Math.max(0, product.stock);
```

After migration, `inventoryStock` will always be the source of truth, and fallback will rarely trigger (only for unmapped products).

**Warning signs:** Trendyol batch sync errors, channel stock not matching ERP

### Pitfall 3: Double Deduction on Invoice

**What goes wrong:** Stock gets deducted twice - once by old function, once by new.

**Why it happens:** Migration not complete, both functions called accidentally.

**How to avoid:** Single switch - replace the import and function call in one commit. Don't have both active.

**Warning signs:** `InventoryStockMovement` AND `StockMovement` records for same order

### Pitfall 4: Picking Doesn't Create Movement Records

**What goes wrong:** Picking decrements stock but no audit trail exists.

**Why it happens:** Current picking code directly updates MasterProduct.stock without creating any movement record.

**How to avoid:** When migrating picking, use `deductInventoryStockFromWarehouse()` which automatically creates `InventoryStockMovement` records.

**Warning signs:** Stock discrepancies with no explanation, missing audit trail for picked items

### Pitfall 5: Return Stock Goes to Wrong Warehouse

**What goes wrong:** Returns add stock back but to wrong warehouse (or no warehouse).

**Why it happens:** Not specifying warehouse when adding return stock.

**How to avoid:** Use primary warehouse (same as invoice deduction) or add parameter for specific warehouse.

**Warning signs:** WarehouseStock totals don't match InventoryItem.currentStock

## Code Examples

### Example 1: addInventoryStockForReturn() Structure

```typescript
// Source: Based on processInventoryStockForOrderFromPrimary() pattern
export async function addInventoryStockForReturn(
  orderId: string,
  returnAwbId: string
): Promise<{
  success: boolean;
  processed: number;
  skipped: number;
  errors: string[];
  movements: Array<{
    sku: string;
    itemName: string;
    quantity: number;
    previousStock: number;
    newStock: number;
    warehouseId: string;
  }>;
  alreadyProcessed?: boolean;
}> {
  // 1. Check if already processed (idempotency)
  const existing = await prisma.inventoryStockMovement.findFirst({
    where: {
      type: "RETURN",
      reason: { contains: returnAwbId }
    }
  });
  if (existing) return { success: true, processed: 0, skipped: 0, errors: [], movements: [], alreadyProcessed: true };

  // 2. Get primary warehouse
  const primaryWarehouse = await getPrimaryWarehouse();
  if (!primaryWarehouse) return { success: false, processed: 0, skipped: 0, errors: ["No primary warehouse"], movements: [] };

  // 3. Get line items from order
  const lineItems = await prisma.lineItem.findMany({ where: { orderId } });

  // 4. For each line item with SKU
  for (const lineItem of lineItems) {
    if (!lineItem.sku) { result.skipped++; continue; }

    // 5. Find MasterProduct -> InventoryItem mapping
    const masterProduct = await prisma.masterProduct.findUnique({
      where: { sku: lineItem.sku },
      include: { inventoryItem: true }
    });
    if (!masterProduct?.inventoryItemId) { result.skipped++; continue; }

    // 6. Add stock back using addInventoryStockFromWarehouse()
    const addResult = await addInventoryStockFromWarehouse(
      masterProduct.inventoryItemId,
      primaryWarehouse.id,
      lineItem.quantity,
      { reason: `Retur - ${returnAwbId}`, orderId }
    );
    // ... handle result
  }

  return result;
}
```

### Example 2: addInventoryStockFromWarehouse() Structure

```typescript
// Source: Mirror of deductInventoryStockFromWarehouse()
export async function addInventoryStockFromWarehouse(
  itemId: string,
  warehouseId: string,
  quantity: number,
  options: {
    orderId?: string;
    reason?: string;
  } = {}
): Promise<{
  success: boolean;
  movements: Array<{
    itemId: string;
    sku: string;
    quantity: number;
    previousStock: number;
    newStock: number;
    warehouseId: string;
  }>;
  error?: string;
}> {
  const movements = [];

  try {
    const item = await prisma.inventoryItem.findUnique({
      where: { id: itemId },
      include: { recipeComponents: { include: { componentItem: true } } }
    });
    if (!item) return { success: false, movements, error: "Item not found" };

    await prisma.$transaction(async (tx) => {
      if (!item.isComposite) {
        // Simple item - add stock directly
        const warehouseStock = await tx.warehouseStock.findUnique({
          where: { warehouseId_itemId: { warehouseId, itemId } }
        });
        const previousStock = Number(warehouseStock?.currentStock || 0);
        const newStock = previousStock + quantity;

        // Upsert WarehouseStock
        await tx.warehouseStock.upsert({
          where: { warehouseId_itemId: { warehouseId, itemId } },
          create: { warehouseId, itemId, currentStock: newStock },
          update: { currentStock: newStock }
        });

        // Create movement record
        await tx.inventoryStockMovement.create({
          data: {
            itemId,
            type: "RETURN",
            quantity: quantity, // Positive for addition
            previousStock,
            newStock,
            warehouseId,
            orderId: options.orderId,
            reason: options.reason || "Retur"
          }
        });

        // Sync total
        const totalStock = await tx.warehouseStock.aggregate({
          where: { itemId },
          _sum: { currentStock: true }
        });
        await tx.inventoryItem.update({
          where: { id: itemId },
          data: { currentStock: totalStock._sum.currentStock || 0 }
        });

        movements.push({ itemId, sku: item.sku, quantity, previousStock, newStock, warehouseId });
      } else {
        // Composite item - add stock to components
        for (const comp of item.recipeComponents) {
          const componentQuantity = Number(comp.quantity) * quantity;
          // ... same logic for each component
        }
      }
    });

    return { success: true, movements };
  } catch (error: any) {
    return { success: false, movements, error: error.message };
  }
}
```

### Example 3: Migrated Picking Stock Update

```typescript
// Source: Replacement for picking/[id]/route.ts:192-220
// Inside transaction block:

// Get MasterProduct with inventoryItem link
const masterProduct = await tx.masterProduct.findUnique({
  where: { id: item.masterProductId },
  include: { inventoryItem: true }
});

if (masterProduct?.inventoryItemId) {
  // Use NEW system
  const primaryWarehouse = await getPrimaryWarehouse();
  if (primaryWarehouse) {
    // Import at top of file:
    // import { deductInventoryStockFromWarehouse } from "@/lib/inventory-stock";

    await deductInventoryStockFromWarehouse(
      masterProduct.inventoryItemId,
      primaryWarehouse.id,
      quantityToDeduct,
      {
        reason: `Picking - ${pickingList.code}, Item: ${item.title}`
      }
    );
  }
} else {
  // Fallback for unmapped products (should be rare after migration)
  console.warn(`[Picking] MasterProduct ${item.sku} not mapped to InventoryItem`);
  // Keep old behavior as fallback
  await tx.masterProduct.update({
    where: { id: masterProduct.id },
    data: { stock: Math.max(0, masterProduct.stock - quantityToDeduct) }
  });
}
```

### Example 4: Deprecation Markers

```typescript
// Source: Add to stock.ts functions

/**
 * @deprecated Use processInventoryStockForOrderFromPrimary() from inventory-stock.ts instead.
 * This function uses the legacy Product.stockQuantity system which doesn't sync with
 * InventoryItem.currentStock used by NIR/GoodsReceipt.
 *
 * Migration: Replace `import { processStockForOrder } from "@/lib/stock"`
 * with `import { processInventoryStockForOrderFromPrimary } from "@/lib/inventory-stock"`
 */
export async function processStockForOrder(/* ... */) {
  // existing implementation unchanged
}

/**
 * @deprecated Use addInventoryStockForReturn() from inventory-stock.ts instead.
 * See processStockForOrder deprecation note for details.
 */
export async function processStockReturnForOrder(/* ... */) {
  // existing implementation unchanged
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Product.stockQuantity | InventoryItem.currentStock | GoodsReceipt feature added | NIR uses new system |
| Single warehouse | Multi-warehouse via WarehouseStock | Multi-warehouse feature | Primary warehouse concept |
| StockMovement (IN/OUT only) | InventoryStockMovement (typed) | Inventory rewrite | Better audit trail |
| Direct MasterProduct.stock update | Via inventoryItemId mapping | Phase 7.1 | Channel sync ready |

**Current state:**
- Goods receipt (NIR) uses NEW system (InventoryItem)
- Invoice/returns/picking use OLD system (Product/MasterProduct)
- Trendyol/Temu sync uses NEW with fallback to OLD
- This causes permanent desync between systems

**After Phase 7.8:**
- All flows use NEW system (InventoryItem)
- OLD system deprecated but functional (backward compat)
- Single source of truth for stock

## Open Questions

None - this is internal code migration with clear patterns already established.

## Sources

### Primary (HIGH confidence)
- **src/lib/inventory-stock.ts** - Full implementation of NEW stock system, reviewed lines 1-1217
- **src/lib/stock.ts** - Full implementation of OLD stock system, reviewed lines 1-621
- **src/lib/invoice-service.ts:700-735** - Current stock deduction call site
- **src/app/api/picking/[id]/route.ts:192-224** - Current picking stock logic
- **src/lib/returns.ts:121-143** - Current return stock processing
- **src/app/api/returns/reprocess-stock/route.ts** - Batch return stock processing
- **src/lib/trendyol-stock-sync.ts:121-139** - Channel sync stock source logic
- **.planning/phases/01-system-audit/audit-output/flows/stock-management.md** - System audit documentation

### Secondary (MEDIUM confidence)
- **.planning/ROADMAP.md:383-415** - Phase requirements and success criteria
- **.planning/STATE.md:474-505** - Current context and problem statement

### Tertiary (LOW confidence)
- None - all findings verified against codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all code reviewed directly in codebase
- Architecture: HIGH - patterns derived from existing working code
- Pitfalls: HIGH - based on actual code paths and prior phase decisions

**Research date:** 2026-02-05
**Valid until:** 60 days (internal refactor, no external dependencies)
