---
phase: 06-ux-foundation
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/app/(dashboard)/orders/page.tsx
  - src/app/(dashboard)/invoices/page.tsx
  - src/app/(dashboard)/inventory/page.tsx
  - src/app/(dashboard)/products/page.tsx
  - src/hooks/use-error-modal.tsx
autonomous: true

must_haves:
  truths:
    - "Orders page shows skeleton loading state while fetching data"
    - "Invoices page shows skeleton loading state while fetching data"
    - "Error modal appears on API errors with user-friendly message"
    - "useErrorModal hook provides consistent error handling pattern"
  artifacts:
    - path: "src/hooks/use-error-modal.tsx"
      provides: "Hook for error modal state management"
      exports: ["useErrorModal"]
    - path: "src/app/(dashboard)/orders/page.tsx"
      provides: "Orders page with skeleton loading"
      contains: "Skeleton"
    - path: "src/app/(dashboard)/invoices/page.tsx"
      provides: "Invoices page with skeleton loading"
      contains: "Skeleton"
  key_links:
    - from: "src/app/(dashboard)/orders/page.tsx"
      to: "src/components/ui/skeleton.tsx"
      via: "Skeleton import"
      pattern: "import.*Skeleton"
    - from: "src/hooks/use-error-modal.tsx"
      to: "src/components/ui/error-modal.tsx"
      via: "ErrorModal import"
      pattern: "import.*ErrorModal"
---

<objective>
Apply skeleton loading states and error modal handling to key dashboard pages (Orders, Invoices, Inventory, Products). Create a reusable useErrorModal hook for consistent error state management.

Purpose: Replace loading spinners with skeleton screens for better perceived performance. Standardize error handling across pages using ErrorModal.

Output: Four key pages updated with skeleton loading states, plus useErrorModal hook for consistent error handling.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ux-foundation/06-CONTEXT.md
@.planning/phases/06-ux-foundation/06-01-SUMMARY.md

# Components created in prior plans:
@src/components/ui/skeleton.tsx
@src/components/ui/error-modal.tsx
@src/lib/error-messages.ts

# Pages to modify:
@src/app/(dashboard)/orders/page.tsx
@src/app/(dashboard)/invoices/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useErrorModal hook</name>
  <files>src/hooks/use-error-modal.tsx</files>
  <action>
Create a reusable hook for managing error modal state.

```typescript
"use client";

import { useState, useCallback } from "react";
import { ErrorModal, ErrorModalProps } from "@/components/ui/error-modal";
import { getErrorMessage } from "@/lib/error-messages";

interface UseErrorModalReturn {
  /** Show error modal with automatic message mapping */
  showError: (error: unknown, customTitle?: string) => void;
  /** Clear the error and close modal */
  clearError: () => void;
  /** The ErrorModal component to render */
  ErrorModalComponent: React.FC;
  /** Whether there's an active error */
  hasError: boolean;
}

export function useErrorModal(): UseErrorModalReturn {
  const [error, setError] = useState<{
    title: string;
    description: string;
    details?: string;
  } | null>(null);

  const showError = useCallback((rawError: unknown, customTitle?: string) => {
    const mapped = getErrorMessage(rawError);
    setError({
      title: customTitle || mapped.title,
      description: mapped.description,
      details: mapped.details,
    });
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const ErrorModalComponent = useCallback(() => {
    if (!error) return null;
    return (
      <ErrorModal
        open={!!error}
        onClose={clearError}
        title={error.title}
        description={error.description}
        details={error.details}
      />
    );
  }, [error, clearError]);

  return {
    showError,
    clearError,
    ErrorModalComponent,
    hasError: !!error,
  };
}
```

Usage pattern for pages:
```typescript
const { showError, ErrorModalComponent } = useErrorModal();

// In fetch/mutation error handler:
try {
  await fetchData();
} catch (error) {
  showError(error);
}

// In JSX:
return (
  <>
    <ErrorModalComponent />
    {/* rest of page */}
  </>
);
```
  </action>
  <verify>
- File exists: src/hooks/use-error-modal.tsx
- Exports useErrorModal
- Imports ErrorModal and getErrorMessage
  </verify>
  <done>useErrorModal hook created for consistent error handling</done>
</task>

<task type="auto">
  <name>Task 2: Update Orders page with skeleton loading</name>
  <files>src/app/(dashboard)/orders/page.tsx</files>
  <action>
Update the Orders page to use skeleton loading states.

1. Import components:
```typescript
import { SkeletonTableRow } from "@/components/ui/skeleton";
import { useErrorModal } from "@/hooks/use-error-modal";
```

2. Find the existing loading state (look for isLoading, loading, or Loader2 spinner).

3. Replace spinner with skeleton:
```typescript
// Instead of:
{isLoading && <Loader2 className="animate-spin" />}

// Use:
{isLoading && (
  <div className="space-y-2 p-4">
    {Array.from({ length: 10 }).map((_, i) => (
      <SkeletonTableRow key={i} cols={6} />
    ))}
  </div>
)}
```

4. Add error modal hook:
```typescript
const { showError, ErrorModalComponent } = useErrorModal();

// In error handling:
.catch((error) => {
  showError(error);
});
```

5. Render ErrorModalComponent at top of JSX.

Note: Preserve existing functionality. Only add skeleton loading and error modal.
  </action>
  <verify>
- grep for "SkeletonTableRow" in orders/page.tsx
- grep for "useErrorModal" in orders/page.tsx
- grep for "ErrorModalComponent" in orders/page.tsx
  </verify>
  <done>Orders page updated with skeleton loading and error modal</done>
</task>

<task type="auto">
  <name>Task 3: Update Invoices page with skeleton loading</name>
  <files>src/app/(dashboard)/invoices/page.tsx</files>
  <action>
Update the Invoices page to use skeleton loading states.

1. Import components:
```typescript
import { SkeletonTableRow } from "@/components/ui/skeleton";
import { useErrorModal } from "@/hooks/use-error-modal";
```

2. Find and replace loading spinner with skeleton (same pattern as orders).

3. Add useErrorModal hook and ErrorModalComponent.

4. Replace any inline error handling with showError().

Note: Invoices page may have different column count. Adjust SkeletonTableRow cols prop accordingly (likely 5-7 columns based on invoice data: number, date, client, amount, status, actions).
  </action>
  <verify>
- grep for "SkeletonTableRow" in invoices/page.tsx
- grep for "useErrorModal" in invoices/page.tsx
  </verify>
  <done>Invoices page updated with skeleton loading and error modal</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Hook check:
```bash
grep -n "export function useErrorModal" src/hooks/use-error-modal.tsx
```

2. Orders page check:
```bash
grep -c "Skeleton" src/app/\(dashboard\)/orders/page.tsx
grep -n "ErrorModalComponent" src/app/\(dashboard\)/orders/page.tsx
```

3. Invoices page check:
```bash
grep -c "Skeleton" src/app/\(dashboard\)/invoices/page.tsx
grep -n "ErrorModalComponent" src/app/\(dashboard\)/invoices/page.tsx
```

4. Build check:
```bash
npm run build 2>&1 | head -30
```
</verification>

<success_criteria>
- useErrorModal hook exists and exports showError, clearError, ErrorModalComponent
- Orders page imports and uses SkeletonTableRow for loading state
- Invoices page imports and uses SkeletonTableRow for loading state
- Both pages use useErrorModal for error handling
- ErrorModalComponent rendered in both pages
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-ux-foundation/06-04-SUMMARY.md`
</output>
