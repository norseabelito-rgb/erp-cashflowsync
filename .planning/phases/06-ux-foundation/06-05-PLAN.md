---
phase: 06-ux-foundation
plan: 05
type: execute
wave: 3
depends_on: ["06-03", "06-04"]
files_modified:
  - src/lib/empty-states.ts
  - src/app/(dashboard)/orders/page.tsx
  - src/app/(dashboard)/invoices/page.tsx
  - src/app/(dashboard)/products/page.tsx
  - src/app/(dashboard)/inventory/page.tsx
autonomous: true

must_haves:
  truths:
    - "Empty states show context-appropriate Romanian messages"
    - "Empty states include relevant call-to-action buttons"
    - "First-time empty states differ from filtered/search empty states"
    - "Success empty states (e.g., no errors) have positive messaging"
  artifacts:
    - path: "src/lib/empty-states.ts"
      provides: "Centralized empty state configurations"
      exports: ["EMPTY_STATES", "getEmptyState"]
    - path: "src/app/(dashboard)/orders/page.tsx"
      provides: "Orders page with context-aware empty state"
      contains: "EmptyState"
  key_links:
    - from: "src/app/(dashboard)/orders/page.tsx"
      to: "src/lib/empty-states.ts"
      via: "Empty state config import"
      pattern: "getEmptyState|EMPTY_STATES"
---

<objective>
Create centralized empty state configurations and apply context-appropriate empty states across key pages. Differentiate between first-time, filtered, and success empty states.

Purpose: Guide users when they encounter empty views with helpful, actionable messages in Romanian. Different contexts need different messages (new user vs. no search results vs. all tasks done).

Output: Centralized empty state definitions and updated pages with context-aware empty states.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-ux-foundation/06-CONTEXT.md
@.planning/phases/06-ux-foundation/06-03-SUMMARY.md
@.planning/phases/06-ux-foundation/06-04-SUMMARY.md

# Existing empty state component:
@src/components/ui/empty-state.tsx

# Pages to update:
@src/app/(dashboard)/orders/page.tsx
@src/app/(dashboard)/invoices/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create centralized empty state configurations</name>
  <files>src/lib/empty-states.ts</files>
  <action>
Create a centralized configuration for empty states across the application.

```typescript
import { LucideIcon, Package, FileText, ShoppingCart, Search, CheckCircle, AlertTriangle, Warehouse, BarChart3 } from "lucide-react";

export interface EmptyStateConfig {
  icon: LucideIcon;
  title: string;
  description: string;
  action?: {
    label: string;
    href?: string;
    onClick?: string; // Name of callback to use, e.g., "clearFilters"
  };
}

export type EmptyStateType = "first_time" | "filtered" | "success" | "error";

/**
 * Empty state configurations by module and type
 */
export const EMPTY_STATES: Record<string, Record<EmptyStateType, EmptyStateConfig>> = {
  orders: {
    first_time: {
      icon: ShoppingCart,
      title: "Nicio comanda inca",
      description: "Comenzile vor aparea aici dupa ce magazinul va primi prima comanda din platforma.",
      action: {
        label: "Configureaza magazin",
        href: "/stores"
      }
    },
    filtered: {
      icon: Search,
      title: "Niciun rezultat gasit",
      description: "Nu am gasit comenzi care sa corespunda criteriilor de cautare.",
      action: {
        label: "Reseteaza filtrele",
        onClick: "clearFilters"
      }
    },
    success: {
      icon: CheckCircle,
      title: "Toate comenzile procesate",
      description: "Nu ai comenzi in asteptare. Buna treaba!"
    },
    error: {
      icon: AlertTriangle,
      title: "Eroare la incarcarea comenzilor",
      description: "Nu am putut incarca lista de comenzi. Incearca din nou.",
      action: {
        label: "Reincarca",
        onClick: "refresh"
      }
    }
  },

  invoices: {
    first_time: {
      icon: FileText,
      title: "Nicio factura inca",
      description: "Facturile vor aparea aici dupa ce vei genera prima factura dintr-o comanda.",
      action: {
        label: "Vezi comenzi",
        href: "/orders"
      }
    },
    filtered: {
      icon: Search,
      title: "Niciun rezultat gasit",
      description: "Nu am gasit facturi care sa corespunda criteriilor de cautare.",
      action: {
        label: "Reseteaza filtrele",
        onClick: "clearFilters"
      }
    },
    success: {
      icon: CheckCircle,
      title: "Totul este la zi",
      description: "Nu ai facturi in asteptare sau cu probleme."
    },
    error: {
      icon: AlertTriangle,
      title: "Eroare la incarcarea facturilor",
      description: "Nu am putut incarca lista de facturi. Incearca din nou.",
      action: {
        label: "Reincarca",
        onClick: "refresh"
      }
    }
  },

  products: {
    first_time: {
      icon: Package,
      title: "Niciun produs inca",
      description: "Produsele vor aparea aici dupa sincronizarea cu magazinul Shopify.",
      action: {
        label: "Sincronizeaza produse",
        onClick: "syncProducts"
      }
    },
    filtered: {
      icon: Search,
      title: "Niciun produs gasit",
      description: "Nu am gasit produse care sa corespunda cautarii tale.",
      action: {
        label: "Reseteaza filtrele",
        onClick: "clearFilters"
      }
    },
    success: {
      icon: CheckCircle,
      title: "Toate produsele sunt configurate",
      description: "Nu ai produse care necesita atentie."
    },
    error: {
      icon: AlertTriangle,
      title: "Eroare la incarcarea produselor",
      description: "Nu am putut incarca lista de produse. Incearca din nou.",
      action: {
        label: "Reincarca",
        onClick: "refresh"
      }
    }
  },

  inventory: {
    first_time: {
      icon: Warehouse,
      title: "Niciun articol in inventar",
      description: "Adauga primul articol pentru a incepe gestionarea stocurilor.",
      action: {
        label: "Adauga articol",
        href: "/inventory/new"
      }
    },
    filtered: {
      icon: Search,
      title: "Niciun rezultat gasit",
      description: "Nu am gasit articole care sa corespunda cautarii tale.",
      action: {
        label: "Reseteaza filtrele",
        onClick: "clearFilters"
      }
    },
    success: {
      icon: CheckCircle,
      title: "Inventar complet",
      description: "Toate articolele au stoc suficient."
    },
    error: {
      icon: AlertTriangle,
      title: "Eroare la incarcarea inventarului",
      description: "Nu am putut incarca inventarul. Incearca din nou.",
      action: {
        label: "Reincarca",
        onClick: "refresh"
      }
    }
  },

  failed_invoices: {
    first_time: {
      icon: CheckCircle,
      title: "Nicio factura esuata",
      description: "Toate facturile au fost generate cu succes. Buna treaba!"
    },
    filtered: {
      icon: Search,
      title: "Niciun rezultat gasit",
      description: "Nu am gasit facturi esuate care sa corespunda cautarii.",
      action: {
        label: "Reseteaza filtrele",
        onClick: "clearFilters"
      }
    },
    success: {
      icon: CheckCircle,
      title: "Totul este rezolvat",
      description: "Nu ai facturi esuate de remediat. Excelent!"
    },
    error: {
      icon: AlertTriangle,
      title: "Eroare la incarcare",
      description: "Nu am putut incarca lista. Incearca din nou.",
      action: {
        label: "Reincarca",
        onClick: "refresh"
      }
    }
  }
};

/**
 * Get empty state config for a module and type
 */
export function getEmptyState(
  module: keyof typeof EMPTY_STATES,
  type: EmptyStateType = "first_time"
): EmptyStateConfig {
  return EMPTY_STATES[module]?.[type] || EMPTY_STATES[module]?.first_time || {
    icon: Package,
    title: "Nu sunt date",
    description: "Nu exista date de afisat."
  };
}

/**
 * Determine empty state type based on context
 */
export function determineEmptyStateType(
  hasFilters: boolean,
  hasError: boolean,
  isSuccessContext: boolean = false
): EmptyStateType {
  if (hasError) return "error";
  if (hasFilters) return "filtered";
  if (isSuccessContext) return "success";
  return "first_time";
}
```
  </action>
  <verify>
- File exists: src/lib/empty-states.ts
- Exports EMPTY_STATES, getEmptyState, determineEmptyStateType
- Contains configurations for orders, invoices, products, inventory
  </verify>
  <done>Centralized empty state configurations created with Romanian messages</done>
</task>

<task type="auto">
  <name>Task 2: Update Orders page with context-aware empty state</name>
  <files>src/app/(dashboard)/orders/page.tsx</files>
  <action>
Update the Orders page to use the centralized empty state configurations.

1. Import empty state utilities:
```typescript
import { getEmptyState, determineEmptyStateType } from "@/lib/empty-states";
import { EmptyState } from "@/components/ui/empty-state";
```

2. Find existing empty state or "no data" condition.

3. Replace with context-aware empty state:
```typescript
// Determine if filters are active (check for any filter state)
const hasActiveFilters = !!searchQuery || !!statusFilter || !!dateFilter;

// Determine empty state type
const emptyStateType = determineEmptyStateType(
  hasActiveFilters,
  hasError,
  false // Not a success context like "no errors"
);

// Get configuration
const emptyConfig = getEmptyState("orders", emptyStateType);

// In JSX, when no data:
{!isLoading && data.length === 0 && (
  <EmptyState
    icon={emptyConfig.icon}
    title={emptyConfig.title}
    description={emptyConfig.description}
    action={emptyConfig.action?.href ? {
      label: emptyConfig.action.label,
      href: emptyConfig.action.href
    } : emptyConfig.action?.onClick ? {
      label: emptyConfig.action.label,
      onClick: emptyConfig.action.onClick === "clearFilters" ? clearFilters : undefined
    } : undefined}
  />
)}
```

4. Ensure loading state check comes before empty state:
```typescript
{isLoading && <SkeletonRows />}
{!isLoading && data.length === 0 && <EmptyState ... />}
{!isLoading && data.length > 0 && <DataTable ... />}
```
  </action>
  <verify>
- grep for "getEmptyState" in orders/page.tsx
- grep for "determineEmptyStateType" in orders/page.tsx
  </verify>
  <done>Orders page updated with context-aware empty state</done>
</task>

<task type="auto">
  <name>Task 3: Update Invoices page with context-aware empty state</name>
  <files>src/app/(dashboard)/invoices/page.tsx</files>
  <action>
Update the Invoices page to use the centralized empty state configurations.

Same pattern as Orders page:
1. Import getEmptyState, determineEmptyStateType, EmptyState
2. Determine hasActiveFilters based on page's filter state
3. Get emptyConfig using getEmptyState("invoices", emptyStateType)
4. Render EmptyState with config when !isLoading && data.length === 0

Ensure proper order: loading -> empty -> data
  </action>
  <verify>
- grep for "getEmptyState" in invoices/page.tsx
- grep for "determineEmptyStateType" in invoices/page.tsx
  </verify>
  <done>Invoices page updated with context-aware empty state</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Empty states config check:
```bash
grep -c "first_time:" src/lib/empty-states.ts  # Should be >= 5
grep -n "export function getEmptyState" src/lib/empty-states.ts
grep -n "export function determineEmptyStateType" src/lib/empty-states.ts
```

2. Orders page check:
```bash
grep -n "getEmptyState.*orders" src/app/\(dashboard\)/orders/page.tsx
```

3. Invoices page check:
```bash
grep -n "getEmptyState.*invoices" src/app/\(dashboard\)/invoices/page.tsx
```

4. Build check:
```bash
npm run build 2>&1 | head -30
```
</verification>

<success_criteria>
- EMPTY_STATES contains configs for 5+ modules (orders, invoices, products, inventory, failed_invoices)
- Each module has 4 types: first_time, filtered, success, error
- getEmptyState function returns correct config for module/type
- determineEmptyStateType helper works correctly
- Orders page uses context-aware empty state
- Invoices page uses context-aware empty state
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-ux-foundation/06-05-SUMMARY.md`
</output>
