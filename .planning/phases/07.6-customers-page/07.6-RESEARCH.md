# Phase 7.6: Customers Page - Research

**Researched:** 2026-02-04
**Domain:** Customer data aggregation from existing Order schema, Next.js page with TanStack Query
**Confidence:** HIGH

## Summary

This phase involves building a Customers page that aggregates customer data from existing Order records. Customer data is NOT stored in a separate table - it exists as fields within the Order model (customerEmail, customerPhone, customerFirstName, customerLastName, shipping address fields). The implementation requires:

1. **API endpoint** for aggregating unique customers from orders with computed analytics (total spent, order count, most ordered products)
2. **Frontend page** following existing patterns (PageHeader, Cards, Tables, Store Tabs)
3. **Customer detail view** (modal or slide-over) showing order history and purchase analytics

The architecture follows established patterns in the codebase: `useQuery` for data fetching, URL-based tab persistence, server-side aggregation via Prisma, and the existing UI component library.

**Primary recommendation:** Create a virtual customer list by grouping orders by a customer identifier (email or phone), compute analytics server-side with Prisma raw queries or groupBy, and reuse the existing ChannelTabs pattern for store filtering.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Next.js App Router | 14.x | Page routing, API routes | Already in use throughout |
| TanStack React Query | ^5.28.0 | Data fetching, caching | Used in Orders page, Dashboard |
| Prisma | ^5.10.2 | Database queries, aggregation | All data access uses Prisma |
| date-fns | ^3.3.1 | Date formatting | Used consistently for dates |
| lucide-react | ^0.344.0 | Icons | Icon library across all pages |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| class-variance-authority | existing | Badge/button variants | Status badges |
| tailwind-merge + clsx | existing | Class merging | Via `cn()` utility |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Server-side page | Client-side only | Server-side matches existing Dashboard pattern, better for initial aggregation |
| Separate Customer table | Virtual customer list | No schema change needed, but requires aggregation on each request - acceptable for this use case |

**Installation:**
```bash
# No new dependencies needed - all libraries already in use
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── app/(dashboard)/customers/
│   └── page.tsx              # Customer list page (client component)
├── app/api/customers/
│   └── route.ts              # GET customers with aggregation
├── components/customers/
│   ├── customer-detail-modal.tsx   # Customer detail view
│   ├── customer-analytics.tsx      # Analytics cards (total spent, etc.)
│   └── store-tabs.tsx              # Reuse ChannelTabs pattern
└── lib/
    └── customer-service.ts         # Customer aggregation logic
```

### Pattern 1: Customer Identifier Strategy
**What:** Use email as primary customer identifier, fallback to phone
**When to use:** Always - for grouping orders into customer records
**Example:**
```typescript
// Source: Derived from existing Order schema analysis
// Customer identity is determined by email (primary) or phone (fallback)
// This matches how orders store customer data

interface CustomerIdentifier {
  email: string | null;
  phone: string | null;
}

// In SQL/Prisma: COALESCE(customerEmail, customerPhone) as identifier
// Ensures unique customers even when email is missing
```

### Pattern 2: Server-Side Aggregation with Prisma
**What:** Compute customer analytics (total spent, order count, top products) server-side
**When to use:** For the customers list endpoint
**Example:**
```typescript
// Source: dashboard-stats.ts pattern for aggregations
// Use Prisma groupBy for basic aggregations
const customerStats = await prisma.order.groupBy({
  by: ['customerEmail'],
  _sum: { totalPrice: true },
  _count: { _all: true },
  where: {
    customerEmail: { not: null },
    ...(storeId && storeId !== 'all' && { storeId }),
  },
});

// For complex aggregations (most ordered products), use $queryRaw
const topProducts = await prisma.$queryRaw`
  SELECT
    COALESCE(o."customerEmail", o."customerPhone") as customer_id,
    li.sku,
    li.title,
    SUM(li.quantity) as total_quantity
  FROM orders o
  JOIN "LineItem" li ON li."orderId" = o.id
  WHERE o."customerEmail" = ${email}
  GROUP BY customer_id, li.sku, li.title
  ORDER BY total_quantity DESC
  LIMIT 5
`;
```

### Pattern 3: URL-Based Tab State (from prior decisions)
**What:** Store active store tab in URL query parameter
**When to use:** For store filtering tabs
**Example:**
```typescript
// Source: 07.4-01 decision - Tab state persists in URL via ?tab= parameter
const searchParams = useSearchParams();
const router = useRouter();
const activeTab = searchParams.get('tab') || 'all';

const handleTabChange = (newTab: string) => {
  const params = new URLSearchParams(searchParams.toString());
  params.set('tab', newTab);
  router.push(`/customers?${params.toString()}`);
};
```

### Pattern 4: Detail Modal Pattern
**What:** Show customer details in a Dialog/Sheet component
**When to use:** When clicking a customer row
**Example:**
```typescript
// Source: Orders page viewModalOpen/viewOrder pattern
const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);
const [detailOpen, setDetailOpen] = useState(false);

const handleViewCustomer = (customer: Customer) => {
  setSelectedCustomer(customer);
  setDetailOpen(true);
};
```

### Anti-Patterns to Avoid
- **Creating a Customer table:** Unnecessary schema change for this feature
- **Client-side aggregation:** Would be slow with many orders, do it server-side
- **Multiple separate queries:** Use parallel Promise.all() like dashboard-stats.ts
- **Ignoring store filter reset:** Per 07.4-01, auto-reset store filter when switching channels

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Search across fields | Custom search logic | Prisma OR with contains | Already pattern in /api/orders |
| Date formatting | Manual formatting | `formatDate()` from utils | Consistent with rest of app |
| Empty states | Custom empty view | `EmptyState` component | Standardized across app |
| Loading skeletons | Custom loading UI | `SkeletonTableRow` | Consistent loading states |
| Store tabs | Custom tabs | Copy `ChannelTabs` pattern | Matches Orders page UX |
| Page headers | Custom header | `PageHeader` component | Design system standard |
| Status badges | Manual badge styling | `Badge` component with variants | Color tokens already defined |

**Key insight:** The codebase has a rich component library and established patterns. Reference Orders page, Dashboard, and design-system.ts for all UI decisions.

## Common Pitfalls

### Pitfall 1: N+1 Queries for Customer Details
**What goes wrong:** Fetching order history separately for each customer in the list
**Why it happens:** Eager to show analytics on list view
**How to avoid:**
- List view: Only show basic info (name, email, order count, total spent)
- Detail view: Fetch full order history only when modal opens
- Use single aggregation query for list, separate query for detail
**Warning signs:** Slow list loading, many database queries per page load

### Pitfall 2: Customer Deduplication Issues
**What goes wrong:** Same customer appears multiple times due to email/phone variations
**Why it happens:** Customer might have orders with different email capitalizations or phone formats
**How to avoid:**
- Normalize email to lowercase: `LOWER(customerEmail)`
- Consider phone normalization (strip spaces, country codes)
- Primary grouping by email, secondary by phone for email-less customers
**Warning signs:** Customer count significantly higher than expected

### Pitfall 3: Search Performance on Large Datasets
**What goes wrong:** Search becomes slow with many customers
**Why it happens:** LIKE queries with wildcards don't use indexes efficiently
**How to avoid:**
- Add database indexes on search fields (already exist: customerEmail, customerPhone)
- Limit results with pagination
- Consider search debouncing on frontend (300ms)
**Warning signs:** Search takes > 1 second

### Pitfall 4: Missing Store Filter Context
**What goes wrong:** Customers appear from all stores when store filter is active
**Why it happens:** Forgetting to propagate store filter to aggregation query
**How to avoid:**
- Always include storeId in WHERE clause when filter is set
- Test with store filter active
- Follow 07.4-01: auto-reset filter when switching channels
**Warning signs:** Customer counts don't change when switching store tabs

### Pitfall 5: Order Number Search Not Working
**What goes wrong:** User searches by order number but customer not found
**Why it happens:** Order number is on Order, not aggregated to customer
**How to avoid:**
- Include `shopifyOrderNumber` in search OR clause
- When order match found, return the customer who placed that order
**Warning signs:** Users report can't find customers by order number

## Code Examples

Verified patterns from official sources:

### Customer List API Endpoint
```typescript
// Source: /api/orders/route.ts pattern
// File: src/app/api/customers/route.ts

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import prisma from "@/lib/db";
import { hasPermission } from "@/lib/permissions";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Use orders.view permission (customers derived from orders)
  const canView = await hasPermission(session.user.id, "orders.view");
  if (!canView) {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  const searchParams = request.nextUrl.searchParams;
  const search = searchParams.get("search");
  const storeId = searchParams.get("storeId");
  const page = parseInt(searchParams.get("page") || "1");
  const limit = parseInt(searchParams.get("limit") || "50");

  // Build where clause for orders
  const where: any = {
    customerEmail: { not: null }, // Only orders with email
  };

  if (storeId && storeId !== "all") {
    where.storeId = storeId;
  }

  if (search) {
    where.OR = [
      { customerEmail: { contains: search, mode: "insensitive" } },
      { customerPhone: { contains: search, mode: "insensitive" } },
      { customerFirstName: { contains: search, mode: "insensitive" } },
      { customerLastName: { contains: search, mode: "insensitive" } },
      { shopifyOrderNumber: { contains: search, mode: "insensitive" } },
    ];
  }

  // Aggregate customers with stats
  const [customers, stores] = await Promise.all([
    prisma.$queryRaw`
      SELECT
        LOWER(o."customerEmail") as email,
        MAX(o."customerPhone") as phone,
        MAX(o."customerFirstName") as "firstName",
        MAX(o."customerLastName") as "lastName",
        COUNT(*)::int as "orderCount",
        COALESCE(SUM(o."totalPrice"::numeric), 0) as "totalSpent",
        MAX(o."createdAt") as "lastOrderDate",
        MIN(o."createdAt") as "firstOrderDate"
      FROM orders o
      WHERE o."customerEmail" IS NOT NULL
        ${storeId && storeId !== "all" ? prisma.$queryRaw`AND o."storeId" = ${storeId}` : prisma.$queryRaw``}
      GROUP BY LOWER(o."customerEmail")
      ORDER BY "totalSpent" DESC
      LIMIT ${limit}
      OFFSET ${(page - 1) * limit}
    `,
    prisma.store.findMany({ where: { isActive: true } }),
  ]);

  return NextResponse.json({ customers, stores });
}
```

### Customer List Page Component
```typescript
// Source: Orders page pattern
// File: src/app/(dashboard)/customers/page.tsx

"use client";

import { useState, useCallback } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import { Users, Search, Phone, Mail, ShoppingCart } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { PageHeader } from "@/components/ui/page-header";
import { EmptyState } from "@/components/ui/empty-state";
import { Badge } from "@/components/ui/badge";
import { formatCurrency } from "@/lib/utils";
import { SkeletonTableRow } from "@/components/ui/skeleton";

export default function CustomersPage() {
  const searchParams = useSearchParams();
  const router = useRouter();

  const [searchQuery, setSearchQuery] = useState("");
  const storeFilter = searchParams.get("tab") || "all";

  const { data, isLoading } = useQuery({
    queryKey: ["customers", storeFilter, searchQuery],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (storeFilter !== "all") params.set("storeId", storeFilter);
      if (searchQuery) params.set("search", searchQuery);
      const res = await fetch(`/api/customers?${params}`);
      return res.json();
    },
  });

  const handleTabChange = useCallback((newTab: string) => {
    const params = new URLSearchParams(searchParams.toString());
    params.set("tab", newTab);
    router.push(`/customers?${params.toString()}`);
  }, [searchParams, router]);

  return (
    <div className="p-4 md:p-6 lg:p-8">
      <PageHeader
        title="Clienti"
        description="Vizualizeaza toti clientii si istoricul comenzilor"
      />

      {/* Store Tabs - follow ChannelTabs pattern */}
      {/* Search and filters */}
      {/* Customer table */}
    </div>
  );
}
```

### Customer Detail Modal Pattern
```typescript
// Source: Orders page view modal pattern
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { useQuery } from "@tanstack/react-query";

interface CustomerDetailModalProps {
  customer: Customer | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function CustomerDetailModal({ customer, open, onOpenChange }: CustomerDetailModalProps) {
  // Fetch full details only when modal is open
  const { data: details, isLoading } = useQuery({
    queryKey: ["customer-detail", customer?.email],
    queryFn: async () => {
      const res = await fetch(`/api/customers/${encodeURIComponent(customer!.email)}`);
      return res.json();
    },
    enabled: open && !!customer?.email,
  });

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {customer?.firstName} {customer?.lastName}
          </DialogTitle>
        </DialogHeader>

        {/* Analytics cards: total spent, order count, etc. */}
        {/* Order history table */}
        {/* Most ordered products */}
      </DialogContent>
    </Dialog>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Separate Customer table | Virtual customers from Orders | N/A - design decision | Simpler schema, no migration needed |
| Client-side filtering | URL-based filters (07.4-01) | Phase 7.4 | Shareable links, back button works |

**Deprecated/outdated:**
- None identified - this is a new feature

## Open Questions

Things that couldn't be fully resolved:

1. **Phone-only customers handling**
   - What we know: Some orders have phone but no email
   - What's unclear: Should these be separate "customers" or merged?
   - Recommendation: Treat as separate customers, show "(Fara email)" indicator

2. **Customer merge/dedup strategy**
   - What we know: Same person might have orders with different emails
   - What's unclear: Manual merge needed? Auto-detect?
   - Recommendation: Phase 1 - no merge, accept duplicates. Future enhancement if needed.

3. **Permission model**
   - What we know: No `customers.view` permission exists
   - What's unclear: Create new permission or reuse `orders.view`?
   - Recommendation: Reuse `orders.view` - customers are derived from orders

## Sources

### Primary (HIGH confidence)
- `/src/prisma/schema.prisma` - Order model fields for customer data
- `/src/app/(dashboard)/orders/page.tsx` - UI patterns, TanStack Query usage
- `/src/app/api/orders/route.ts` - API patterns, Prisma queries
- `/src/lib/dashboard-stats.ts` - Aggregation patterns with $queryRaw
- `/src/components/orders/channel-tabs.tsx` - Tab component pattern
- `/src/lib/design-system.ts` - UI constants and patterns

### Secondary (MEDIUM confidence)
- `/src/components/ui/*.tsx` - Component library (Button, Badge, Card, etc.)
- `/src/lib/utils.ts` - Utility functions (formatCurrency, formatDate)

### Tertiary (LOW confidence)
- None - all findings based on codebase analysis

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use in codebase
- Architecture: HIGH - Patterns derived from existing pages (Orders, Dashboard)
- Pitfalls: HIGH - Based on similar features in codebase and common patterns

**Research date:** 2026-02-04
**Valid until:** 60 days (stable patterns, no external dependencies)
