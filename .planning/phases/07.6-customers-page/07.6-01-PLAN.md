---
phase: 07.6-customers-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/customers/route.ts
  - src/app/api/customers/[email]/route.ts
autonomous: true

must_haves:
  truths:
    - "Customer list API returns unique customers aggregated from orders"
    - "Customer detail API returns order history and purchase analytics"
    - "Search works across email, phone, name, and order number"
    - "Store filter limits customers to those with orders from that store"
  artifacts:
    - path: "src/app/api/customers/route.ts"
      provides: "Customer list with aggregation"
      exports: ["GET"]
    - path: "src/app/api/customers/[email]/route.ts"
      provides: "Customer detail with order history"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/customers/route.ts"
      to: "prisma.$queryRaw"
      via: "SQL aggregation for customer stats"
      pattern: "\\$queryRaw"
    - from: "src/app/api/customers/[email]/route.ts"
      to: "prisma.order.findMany"
      via: "Order history fetch"
      pattern: "order\\.findMany"
---

<objective>
Create Customer APIs for aggregating customer data from Order records with purchase analytics.

Purpose: Provide backend endpoints for customer list with statistics and individual customer details with order history.
Output: Two API routes - customer list with aggregation, customer detail with order history and analytics.
</objective>

<execution_context>
@/Users/stefanpanaite/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stefanpanaite/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.6-customers-page/07.6-RESEARCH.md

# Existing patterns to follow
@src/app/api/orders/route.ts
@src/lib/dashboard-stats.ts
@src/lib/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Customer List API with aggregation</name>
  <files>src/app/api/customers/route.ts</files>
  <action>
Create GET endpoint at /api/customers that aggregates customer data from Order table.

**Query parameters:**
- search: string (optional) - searches email, phone, firstName, lastName, shopifyOrderNumber
- storeId: string (optional) - filter by store, "all" means no filter
- page: number (default 1) - pagination page
- limit: number (default 50) - items per page

**Implementation details:**

1. Auth check: Use getServerSession(authOptions), require session.user.id
2. Permission check: Use hasPermission for "orders.view" (customers derived from orders)
3. Use Prisma $queryRaw for efficient aggregation:

```sql
SELECT
  LOWER(o."customerEmail") as email,
  MAX(o."customerPhone") as phone,
  MAX(o."customerFirstName") as "firstName",
  MAX(o."customerLastName") as "lastName",
  COUNT(*)::int as "orderCount",
  COALESCE(SUM(o."totalPrice"::numeric), 0) as "totalSpent",
  MAX(o."createdAt") as "lastOrderDate",
  MIN(o."createdAt") as "firstOrderDate"
FROM orders o
WHERE o."customerEmail" IS NOT NULL
  [AND o."storeId" = $storeId if provided]
GROUP BY LOWER(o."customerEmail")
ORDER BY "totalSpent" DESC
LIMIT $limit OFFSET $offset
```

4. For search, use a separate raw query with OR conditions:
   - LOWER(customerEmail) LIKE '%search%'
   - customerPhone LIKE '%search%'
   - LOWER(customerFirstName) LIKE '%search%'
   - LOWER(customerLastName) LIKE '%search%'
   - shopifyOrderNumber LIKE '%search%'

5. Get total count for pagination (separate count query)

6. Also fetch stores for dropdown (prisma.store.findMany where isActive: true)

**Response format:**
```typescript
{
  customers: Array<{
    email: string;
    phone: string | null;
    firstName: string | null;
    lastName: string | null;
    orderCount: number;
    totalSpent: number;
    lastOrderDate: Date;
    firstOrderDate: Date;
  }>;
  stores: Array<{ id: string; name: string }>;
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}
```

**Important:**
- Use LOWER() normalization on email for consistent grouping
- Cast totalPrice to numeric for SUM (avoid Decimal issues)
- Return 401 for unauthorized, 403 for forbidden
  </action>
  <verify>
1. Start dev server: npm run dev
2. Test without auth (should return 401):
   curl http://localhost:3000/api/customers
3. After logging in via browser, copy cookies and test:
   - Basic fetch returns customer list
   - Search param filters results
   - storeId param filters by store
   - Pagination works (page=2)
  </verify>
  <done>GET /api/customers returns paginated customer list with aggregated stats from orders, filtered by search and store.</done>
</task>

<task type="auto">
  <name>Task 2: Create Customer Detail API with order history</name>
  <files>src/app/api/customers/[email]/route.ts</files>
  <action>
Create GET endpoint at /api/customers/[email] that returns full customer details with order history and purchase analytics.

**Path parameter:**
- email: URL-encoded customer email (use decodeURIComponent)

**Query parameters:**
- storeId: string (optional) - filter orders by store

**Implementation details:**

1. Auth + permission check (same as list API)
2. Decode email parameter: decodeURIComponent(params.email)
3. Normalize email: email.toLowerCase()

4. Fetch all orders for this customer:
```typescript
const orders = await prisma.order.findMany({
  where: {
    customerEmail: { equals: normalizedEmail, mode: 'insensitive' },
    ...(storeId && storeId !== 'all' && { storeId }),
  },
  include: {
    store: true,
    invoice: { select: { id: true, invoiceNumber: true, status: true } },
    awb: { select: { id: true, awbNumber: true, currentStatus: true } },
    lineItems: true,
  },
  orderBy: { createdAt: 'desc' },
});
```

5. Compute analytics from orders:
```typescript
const analytics = {
  totalSpent: orders.reduce((sum, o) => sum + Number(o.totalPrice), 0),
  orderCount: orders.length,
  firstOrderDate: orders.length ? orders[orders.length - 1].createdAt : null,
  lastOrderDate: orders.length ? orders[0].createdAt : null,
  averageOrderValue: orders.length ? totalSpent / orders.length : 0,
};
```

6. Compute most ordered products from lineItems:
```typescript
const productMap = new Map<string, { title: string; sku: string; quantity: number }>();
for (const order of orders) {
  for (const item of order.lineItems || []) {
    const key = item.sku || item.title;
    const existing = productMap.get(key);
    if (existing) {
      existing.quantity += item.quantity;
    } else {
      productMap.set(key, { title: item.title, sku: item.sku, quantity: item.quantity });
    }
  }
}
const topProducts = Array.from(productMap.values())
  .sort((a, b) => b.quantity - a.quantity)
  .slice(0, 5);
```

7. Extract customer info from first order (most recent):
```typescript
const customer = orders[0] ? {
  email: orders[0].customerEmail,
  phone: orders[0].customerPhone,
  firstName: orders[0].customerFirstName,
  lastName: orders[0].customerLastName,
  // Shipping address from most recent
  address: {
    address1: orders[0].shippingAddress1,
    address2: orders[0].shippingAddress2,
    city: orders[0].shippingCity,
    province: orders[0].shippingProvince,
    zip: orders[0].shippingZip,
    country: orders[0].shippingCountry,
  },
} : null;
```

**Response format:**
```typescript
{
  customer: {
    email: string;
    phone: string | null;
    firstName: string | null;
    lastName: string | null;
    address: { address1, address2, city, province, zip, country } | null;
  } | null;
  analytics: {
    totalSpent: number;
    orderCount: number;
    firstOrderDate: Date | null;
    lastOrderDate: Date | null;
    averageOrderValue: number;
  };
  topProducts: Array<{ title: string; sku: string; quantity: number }>;
  orders: Array<{
    id: string;
    shopifyOrderNumber: string;
    totalPrice: number;
    status: string;
    createdAt: Date;
    store: { id: string; name: string };
    invoice: { invoiceNumber: string | null; status: string } | null;
    awb: { awbNumber: string; currentStatus: string } | null;
  }>;
}
```

**Important:**
- Return 404 if no orders found for email
- Use case-insensitive email matching
- Sort orders by createdAt DESC (most recent first)
  </action>
  <verify>
1. Start dev server if not running
2. Get a valid customer email from previous API response
3. Test: curl http://localhost:3000/api/customers/{encoded-email}
4. Verify response includes:
   - customer info (name, phone, address)
   - analytics (totalSpent, orderCount, averageOrderValue)
   - topProducts array (sorted by quantity)
   - orders array with invoice/awb details
  </verify>
  <done>GET /api/customers/[email] returns customer details with order history, purchase analytics, and most ordered products.</done>
</task>

</tasks>

<verification>
1. Both API endpoints respond with correct data structure
2. Search filters work correctly (email, phone, name, order number)
3. Store filter limits results appropriately
4. Pagination returns correct totals
5. Customer detail returns complete order history
6. Top products correctly aggregated across all orders
</verification>

<success_criteria>
- /api/customers returns paginated customer list with aggregated stats
- /api/customers/[email] returns customer details with order history
- Search works across all specified fields
- Store filtering works on both endpoints
- Permission checks enforced (orders.view)
</success_criteria>

<output>
After completion, create `.planning/phases/07.6-customers-page/07.6-01-SUMMARY.md`
</output>
